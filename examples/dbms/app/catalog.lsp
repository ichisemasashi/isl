;; dbms/app/catalog.lsp
;; スキーマ管理層（MVP Core + Wiki Compatibility v1 の制約登録/検証）。

(load "./examples/dbms/app/repr.lsp")
(load "./examples/dbms/app/storage.lsp")

(defun dbms-catalog-new ()
  (dbms-empty-catalog))

(defun dbms-catalog-load ()
  (let ((raw (dbms-storage-load-catalog)))
    (if (dbms-catalog-p raw)
        raw
        (dbms-catalog-new))))

(defun dbms-catalog-save (catalog)
  (dbms-storage-save-catalog catalog))

(defun dbms-catalog-find-table (catalog table-name)
  (if (or (null table-name) (string= table-name ""))
      '()
      (dbms-catalog-find-table-def catalog table-name)))

(defun dbms-symbol-in-list-p (sym xs)
  (if (null xs)
      nil
      (if (eq sym (car xs))
          t
          (dbms-symbol-in-list-p sym (cdr xs)))))

(defun dbms-string-in-list-p (s xs)
  (if (null xs)
      nil
      (if (string= s (car xs))
          t
          (dbms-string-in-list-p s (cdr xs)))))

(defun dbms-reverse (xs)
  (let ((rest xs)
        (out '()))
    (while (not (null rest))
      (setq out (cons (car rest) out))
      (setq rest (cdr rest)))
    out))

(defun dbms-column-type-valid-p (type)
  (dbms-symbol-in-list-p type '(INT TEXT BOOL BIGINT INTEGER TIMESTAMPTZ)))

(defun dbms-column-attr-valid-p (attr)
  (dbms-symbol-in-list-p attr '(PRIMARY-KEY NOT-NULL UNIQUE)))

(defun dbms-column-list-valid-p (columns)
  (if (null columns)
      nil
      (let ((rest columns)
            (seen '())
            (ok t))
        (while (and ok (not (null rest)))
          (let* ((col (car rest))
                 (name (dbms-column-def-name col))
                 (type (dbms-column-def-type col))
                 (attrs (dbms-column-def-attrs col))
                 (attrs-rest attrs))
            (if (or (not (dbms-column-def-p col))
                    (null name)
                    (string= name "")
                    (not (stringp name))
                    (not (dbms-column-type-valid-p type))
                    (dbms-string-in-list-p name seen))
                (setq ok nil)
                (progn
                  (while (and ok (not (null attrs-rest)))
                    (if (dbms-column-attr-valid-p (car attrs-rest))
                        (setq attrs-rest (cdr attrs-rest))
                        (setq ok nil)))
                  (setq seen (cons name seen))
                  (setq rest (cdr rest))))))
        ok)))

(defun dbms-column-name-list (columns)
  (let ((rest columns)
        (out '()))
    (while (not (null rest))
      (setq out (cons (dbms-column-def-name (car rest)) out))
      (setq rest (cdr rest)))
    (dbms-reverse out)))

(defun dbms-column-has-attr-p (column-def attr)
  (dbms-symbol-in-list-p attr (dbms-column-def-attrs column-def)))

(defun dbms-pk-columns-from-attrs (columns)
  (let ((rest columns)
        (out '()))
    (while (not (null rest))
      (let ((col (car rest)))
        (if (dbms-column-has-attr-p col 'PRIMARY-KEY)
            (setq out (cons (dbms-column-def-name col) out))
            nil))
      (setq rest (cdr rest)))
    (dbms-reverse out)))

(defun dbms-constraint-columns-valid-p (cols table-col-names)
  (if (null cols)
      nil
      (let ((rest cols)
            (ok t)
            (seen '()))
        (while (and ok (not (null rest)))
          (let ((c (car rest)))
            (if (or (not (stringp c))
                    (string= c "")
                    (not (dbms-string-in-list-p c table-col-names))
                    (dbms-string-in-list-p c seen))
                (setq ok nil)
                (progn
                  (setq seen (cons c seen))
                  (setq rest (cdr rest))))))
        ok)))

(defun dbms-constraint-list-valid-p (catalog constraints table-col-names)
  (let ((rest constraints)
        (pk-count 0)
        (ok t)
        (err '()))
    (while (and ok (not (null rest)))
      (let* ((c (car rest))
             (kind (dbms-constraint-kind c))
             (spec (dbms-constraint-spec c)))
        (if (not (dbms-constraint-p c))
            (progn
              (setq ok nil)
              (setq err (dbms-make-error 'dbms/invalid-representation "constraint must be dbms-constraint" c)))
            (cond
             ((eq kind 'primary-key)
              (if (dbms-constraint-columns-valid-p spec table-col-names)
                  (progn
                    (if (= (length spec) 1)
                        (setq pk-count (+ pk-count 1))
                        (progn
                          (setq ok nil)
                          (setq err (dbms-make-error 'dbms/primary-key-violation "PRIMARY KEY must be single-column" spec)))))
                  (progn
                    (setq ok nil)
                    (setq err (dbms-make-error 'dbms/column-not-found "PRIMARY KEY refers unknown column" spec)))))
             ((eq kind 'unique)
              (if (dbms-constraint-columns-valid-p spec table-col-names)
                  nil
                  (progn
                    (setq ok nil)
                    (setq err (dbms-make-error 'dbms/column-not-found "UNIQUE refers unknown column" spec)))))
             ((eq kind 'check)
              (if (null spec)
                  (progn
                    (setq ok nil)
                    (setq err (dbms-make-error 'dbms/invalid-representation "CHECK spec must not be empty" c)))
                  nil))
             ((eq kind 'foreign-key)
              ;; spec: (<local-cols> <ref-table> <ref-cols> <on-delete>)
              (if (or (not (listp spec)) (< (length spec) 4))
                  (progn
                    (setq ok nil)
                    (setq err (dbms-make-error 'dbms/invalid-representation "FOREIGN KEY spec must be (local-cols ref-table ref-cols on-delete)" spec)))
                  (let* ((local-cols (first spec))
                         (ref-table (second spec))
                         (ref-cols (third spec))
                         (on-delete (fourth spec))
                         (ref-def (dbms-catalog-find-table catalog ref-table))
                         (ref-col-names (if (null ref-def) '() (dbms-column-name-list (dbms-table-def-columns ref-def)))))
                    (if (not (dbms-constraint-columns-valid-p local-cols table-col-names))
                        (progn
                          (setq ok nil)
                          (setq err (dbms-make-error 'dbms/column-not-found "FOREIGN KEY local columns invalid" local-cols)))
                        (if (null ref-def)
                            (progn
                              (setq ok nil)
                              (setq err (dbms-make-error 'dbms/table-not-found "FOREIGN KEY referenced table not found" ref-table)))
                            (if (not (dbms-constraint-columns-valid-p ref-cols ref-col-names))
                                (progn
                                  (setq ok nil)
                                  (setq err (dbms-make-error 'dbms/column-not-found "FOREIGN KEY referenced columns invalid" ref-cols)))
                                (if (not (= (length local-cols) (length ref-cols)))
                                    (progn
                                      (setq ok nil)
                                      (setq err (dbms-make-error 'dbms/arity-mismatch "FOREIGN KEY local/ref column counts differ" spec)))
                                    (if (dbms-symbol-in-list-p on-delete '(CASCADE SET-NULL))
                                        nil
                                        (progn
                                          (setq ok nil)
                                          (setq err (dbms-make-error 'dbms/invalid-representation "FOREIGN KEY on-delete must be CASCADE or SET-NULL" on-delete)))))))))))
             (t
              (setq ok nil)
              (setq err (dbms-make-error 'dbms/invalid-representation "unknown constraint kind" kind))))))
      (setq rest (cdr rest)))
    (if ok
        (if (> pk-count 1)
            (dbms-make-error 'dbms/primary-key-violation "multiple PRIMARY KEY constraints" constraints)
            t)
        err)))

(defun dbms-primary-key-constraint-count (constraints)
  (let ((rest constraints)
        (n 0))
    (while (not (null rest))
      (let ((c (car rest)))
        (if (and (dbms-constraint-p c)
                 (eq (dbms-constraint-kind c) 'primary-key))
            (setq n (+ n 1))
            nil))
      (setq rest (cdr rest)))
    n))

(defun dbms-normalize-table-def (table-def)
  ;; PRIMARY-KEY 属性は NOT-NULL を含むように正規化する。
  (let ((columns (dbms-table-def-columns table-def))
        (constraints (dbms-table-def-constraints table-def))
        (options (dbms-table-def-options table-def))
        (name (dbms-table-def-name table-def))
        (new-cols '()))
    (dolist (col columns)
      (let ((attrs (dbms-column-def-attrs col)))
        (if (and (dbms-symbol-in-list-p 'PRIMARY-KEY attrs)
                 (not (dbms-symbol-in-list-p 'NOT-NULL attrs)))
            (setq attrs (cons 'NOT-NULL attrs))
            nil)
        (setq new-cols (cons (dbms-make-column-def (dbms-column-def-name col)
                                                   (dbms-column-def-type col)
                                                   attrs)
                             new-cols))))
    (dbms-make-table-def name (dbms-reverse new-cols) constraints options)))

(defun dbms-catalog-validate-table-def (catalog table-def)
  (if (not (dbms-table-def-p table-def))
      (dbms-make-error 'dbms/invalid-representation "table-def must be dbms-table-def" table-def)
      (let* ((name (dbms-table-def-name table-def))
             (columns (dbms-table-def-columns table-def))
             (constraints (dbms-table-def-constraints table-def))
             (table-col-names (dbms-column-name-list columns))
             (pk-cols (dbms-pk-columns-from-attrs columns))
             (pk-constraint-count (dbms-primary-key-constraint-count constraints))
             (constraint-check (dbms-constraint-list-valid-p catalog constraints table-col-names)))
        (if (or (null name) (not (stringp name)) (string= name ""))
            (dbms-make-error 'dbms/invalid-representation "table name must be non-empty string" name)
            (if (not (dbms-column-list-valid-p columns))
                (dbms-make-error 'dbms/duplicate-column "invalid or duplicate column definition" columns)
                (if (> (+ (length pk-cols) pk-constraint-count) 1)
                    (dbms-make-error 'dbms/primary-key-violation "multiple PRIMARY KEY definitions" table-def)
                    (if (eq constraint-check t)
                        (dbms-normalize-table-def table-def)
                        constraint-check)))))))

(defun dbms-catalog-create-table (catalog table-def)
  (if (not (dbms-catalog-p catalog))
      (dbms-make-error 'dbms/invalid-representation "catalog must be dbms-catalog" catalog)
      (let ((name (dbms-table-def-name table-def)))
        (if (not (null (dbms-catalog-find-table-def catalog name)))
            (dbms-make-error 'dbms/duplicate-table "table already exists" name)
            (let ((checked (dbms-catalog-validate-table-def catalog table-def)))
              (if (dbms-error-p checked)
                  checked
                  (dbms-catalog-add-table-def catalog checked)))))))
