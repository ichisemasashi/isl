(defun token-kind-in-p (token kinds)
  (let ((k (inline-token-kind token))
        (rest kinds)
        (ok nil))
    (while (and (not ok) (not (null rest)))
      (if (eq k (first rest))
          (setq ok t)
          nil)
      (setq rest (cdr rest)))
    ok))

(defun join-inline-token-lexemes (tokens)
  (let ((rest tokens)
        (out ""))
    (while (not (null rest))
      (setq out (string-append out (inline-token-lexeme (first rest))))
      (setq rest (cdr rest)))
    out))

(defun join-lines-space (lines)
  (let ((rest lines)
        (out ""))
    (while (not (null rest))
      (setq out (if (= (length out) 0)
                    (first rest)
                    (string-append out " " (first rest))))
      (setq rest (cdr rest)))
    out))

(defun join-lines-newline (lines)
  (let ((rest lines)
        (out ""))
    (while (not (null rest))
      (setq out (if (= (length out) 0)
                    (first rest)
                    (string-append out "\n" (first rest))))
      (setq rest (cdr rest)))
    out))

(defun trim-line (line)
  (let ((n (length line))
        (s 0)
        (e (- (length line) 1)))
    (while (and (< s n) (not (null (string-index (substring line s (+ s 1)) " \t\r"))))
      (setq s (+ s 1)))
    (while (and (>= e s) (not (null (string-index (substring line e (+ e 1)) " \t\r"))))
      (setq e (- e 1)))
    (if (> s e) "" (substring line s (+ e 1)))))

(defun count-char-and-check-others (line mark)
  (let ((i 0)
        (n (length line))
        (cnt 0)
        (ok t))
    (while (and ok (< i n))
      (let ((ch (substring line i (+ i 1))))
        (if (or (string= ch " ") (string= ch "\t"))
            nil
            (if (string= ch mark)
                (setq cnt (+ cnt 1))
                (setq ok nil))))
      (setq i (+ i 1)))
    (if ok cnt -1)))

(defun thematic-break-p (line)
  (let ((trimmed (trim-line line)))
    (if (= (length trimmed) 0)
        nil
        (or (>= (count-char-and-check-others line "*") 3)
            (>= (count-char-and-check-others line "_") 3)
            (>= (count-char-and-check-others line "-") 3)))))

(defun setext-level (line)
  (let ((trimmed (trim-line line)))
    (if (= (length trimmed) 0)
        '()
        (if (>= (count-char-and-check-others line "=") 1)
            1
            (if (>= (count-char-and-check-others line "-") 1)
                2
                '())))))

(defun skip-leading-ws (line)
  (let ((i 0)
        (n (length line)))
    (while (and (< i n) (not (null (string-index (substring line i (+ i 1)) " \t"))))
      (setq i (+ i 1)))
    i))

(defun count-leading-ws (line)
  (skip-leading-ws line))

(defun strip-prefix-count (line count)
  (if (<= count 0)
      line
      (if (>= count (length line))
          ""
          (substring line count (length line)))))

(defun strip-item-indent (line base-indent)
  (let ((lead (count-leading-ws line)))
    (if (>= lead (+ base-indent 2))
        (strip-prefix-count line (+ base-indent 2))
        (if (>= lead base-indent)
            (strip-prefix-count line base-indent)
            line))))

(defun all-digit-p (s)
  (let* ((i 0)
         (n (length s))
         (ok (> n 0)))
    (while (and ok (< i n))
      (if (null (string-index (substring s i (+ i 1)) "0123456789"))
          (setq ok nil)
          nil)
      (setq i (+ i 1)))
    ok))

(defun decimal-string->int (s)
  (let ((i 0)
        (n (length s))
        (v 0))
    (while (< i n)
      (let ((d (string-index (substring s i (+ i 1)) "0123456789")))
        (if (null d)
            (md-fail "E_PARSE" "invalid decimal integer" (md-pos 1 1 0) s)
            (setq v (+ (* v 10) d))))
      (setq i (+ i 1)))
    v))

(defun all-alpha-p (s)
  (let* ((i 0)
         (n (length s))
         (ok (> n 0)))
    (while (and ok (< i n))
      (if (null (string-index (substring s i (+ i 1)) "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))
          (setq ok nil)
          nil)
      (setq i (+ i 1)))
    ok))

(defun all-roman-p (s)
  (let* ((i 0)
         (n (length s))
         (ok (> n 0)))
    (while (and ok (< i n))
      (if (null (string-index (substring s i (+ i 1)) "ivxlcdmIVXLCDM"))
          (setq ok nil)
          nil)
      (setq i (+ i 1)))
    ok))

(defun roman-char-value (ch)
  (cond
   ((or (string= ch "i") (string= ch "I")) 1)
   ((or (string= ch "v") (string= ch "V")) 5)
   ((or (string= ch "x") (string= ch "X")) 10)
   ((or (string= ch "l") (string= ch "L")) 50)
   ((or (string= ch "c") (string= ch "C")) 100)
   ((or (string= ch "d") (string= ch "D")) 500)
   ((or (string= ch "m") (string= ch "M")) 1000)
   (t 0)))

(defun roman->int (s)
  (let ((i 0)
        (n (length s))
        (total 0))
    (while (< i n)
      (let ((v1 (roman-char-value (substring s i (+ i 1)))))
        (if (< (+ i 1) n)
            (let ((v2 (roman-char-value (substring s (+ i 1) (+ i 2)))))
              (if (< v1 v2)
                  (progn
                    (setq total (+ total (- v2 v1)))
                    (setq i (+ i 2)))
                  (progn
                    (setq total (+ total v1))
                    (setq i (+ i 1)))))
            (progn
              (setq total (+ total v1))
              (setq i (+ i 1))))))
    total))

(defun alpha-start-number (ch)
  (+ 1 (string-index ch "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")))

;; return:
;;   (indent kind list-type start content)
;; kind: 'ul | 'ol | 'example
;; list-type: "1" | "a" | "A" | "i" | "I"
(defun parse-ordered-marker (token content indent)
  (if (all-digit-p token)
      (list indent 'ol "1" (decimal-string->int token) content)
      (if (all-roman-p token)
          (if (null (string-index (substring token 0 1) "ivxlcdm"))
              (list indent 'ol "I" (roman->int token) content)
              (list indent 'ol "i" (roman->int token) content))
          (if (and (= (length token) 1) (all-alpha-p token))
              (if (null (string-index token "abcdefghijklmnopqrstuvwxyz"))
                  (list indent 'ol "A" (alpha-start-number token) content)
                  (list indent 'ol "a" (+ 1 (string-index token "abcdefghijklmnopqrstuvwxyz")) content))
              '()))))

(defun parse-list-marker-line (line)
  (let* ((indent (skip-leading-ws line))
         (line-len (length line)))
    (if (>= indent line-len)
        '()
        (let* ((rest (substring line indent line-len))
               (m (length rest)))
          (if (and (>= m 2)
                   (or (string= (substring rest 0 1) "-")
                       (string= (substring rest 0 1) "+")
                       (string= (substring rest 0 1) "*"))
                   (string= (substring rest 1 2) " "))
              (list indent 'ul "" 1 (substring rest 2 m))
              (if (and (>= m 4)
                       (string= (substring rest 0 1) "(")
                       (string= (substring rest 1 2) "@"))
                  (let ((j 2))
                    (while (and (< j m) (not (string= (substring rest j (+ j 1)) ")")))
                      (setq j (+ j 1)))
                    (if (and (< j m)
                             (< (+ j 1) m)
                             (string= (substring rest (+ j 1) (+ j 2)) " "))
                        (list indent 'example "1" 1 (substring rest (+ j 2) m))
                        '()))
                  (let ((sp (string-index " " rest)))
                    (if (null sp)
                        '()
                        (let* ((marker (substring rest 0 sp))
                               (k (length marker)))
                          (if (< k 2)
                              '()
                              (let* ((delim (substring marker (- k 1) k))
                                     (token (substring marker 0 (- k 1)))
                                     (content (substring rest (+ sp 1) m)))
                                (if (or (string= delim ".")
                                        (string= delim ")"))
                                    (parse-ordered-marker token content indent)
                                    '()))))))))))))

(defun list-compatible-p (info kind list-type indent)
  (and (= (first info) indent)
       (eq (second info) kind)
       (if (eq kind 'ol)
           (string= (third info) list-type)
           t)))

(defun parse-task-prefix (text)
  (if (and (>= (length text) 4)
           (string= (substring text 0 1) "[")
           (string= (substring text 2 3) "]")
           (string= (substring text 3 4) " "))
      (let ((mark (substring text 1 2)))
        (if (string= mark " ")
            (list 'unchecked (substring text 4))
            (if (or (string= mark "x") (string= mark "X"))
                (list 'checked (substring text 4))
                (list 'none text))))
      (list 'none text)))

(defun definition-line-content (line)
  (let* ((n (length line))
         (i (skip-leading-ws line)))
    (if (or (>= i n) (not (string= (substring line i (+ i 1)) ":")))
        '()
        (let ((j (+ i 1)))
          (if (and (< j n) (string= (substring line j (+ j 1)) " "))
              (setq j (+ j 1))
              nil)
          (substring line j n)))))

(defun all-space-tab-p (s)
  (let ((i 0)
        (n (length s))
        (ok t))
    (while (and ok (< i n))
      (if (null (string-index (substring s i (+ i 1)) " \t\r"))
          (setq ok nil)
          nil)
      (setq i (+ i 1)))
    ok))

(defun repeat-string (piece count)
  (let ((i 0)
        (out ""))
    (while (< i count)
      (setq out (string-append out piece))
      (setq i (+ i 1)))
    out))

(defun env-or-default (name default)
  (let ((v (getenv name)))
    (if (null v) default v)))

(defun bool-env-enabled-p (name)
  (string= (env-or-default name "0") "1"))

(defun literate-haskell-enabled-p ()
  (bool-env-enabled-p "MD2HTML_LITERATE_HASKELL"))

(defun gutenberg-enabled-p ()
  (bool-env-enabled-p "MD2HTML_GUTENBERG"))

(defun wikilink-order ()
  (let ((m (env-or-default "MD2HTML_WIKILINK_ORDER" "both")))
    (if (or (string= m "after")
            (string= m "before")
            (string= m "both"))
        m
        "both")))

(defun ascii-upper-char (ch)
  (let ((i (string-index ch "abcdefghijklmnopqrstuvwxyz")))
    (if (null i)
        ch
        (substring "ABCDEFGHIJKLMNOPQRSTUVWXYZ" i (+ i 1)))))

(defun upper-ascii-string (s)
  (let ((i 0)
        (n (length s))
        (out ""))
    (while (< i n)
      (setq out (string-append out (ascii-upper-char (substring s i (+ i 1)))))
      (setq i (+ i 1)))
    out))

(defun gutenberg-process-lines (lines)
  (if (not (gutenberg-enabled-p))
      lines
      (let ((r lines)
            (out '())
            (in-body nil))
        (while (not (null r))
          (let* ((ln (first r))
                 (tln (trim-line ln))
                 (up (upper-ascii-string tln)))
            (if (starts-with up "*** START OF")
                (progn
                  (setq in-body t)
                  (setq r (cdr r)))
                (if (starts-with up "*** END OF")
                    (progn
                      (setq in-body nil)
                      (setq r (cdr r)))
                    (progn
                      (if (or (not in-body)
                              (and (not (null (string-index "PROJECT GUTENBERG" up)))
                                   (not (starts-with up "***"))))
                          nil
                          (if (or (starts-with tln "CHAPTER ")
                                  (starts-with tln "BOOK "))
                              (setq out (append out (list (string-append "## " tln))))
                              (if (or (string= tln "* * *")
                                      (string= tln "***")
                                      (string= tln "* * * * *"))
                                  (setq out (append out (list "---")))
                                  (setq out (append out (list ln))))))
                      (setq r (cdr r)))))))
        out)))

(defun identifier-style ()
  (let ((s (env-or-default "MD2HTML_IDENTIFIER_STYLE" "auto")))
    (if (or (string= s "auto")
            (string= s "ascii")
            (string= s "gfm")
            (string= s "mmd"))
        s
        "auto")))

(defun ascii-char-p (ch)
  (< (char->integer ch) 128))

(defun ascii-lower-char (ch)
  (let ((i (string-index ch "ABCDEFGHIJKLMNOPQRSTUVWXYZ")))
    (if (null i)
        ch
        (substring "abcdefghijklmnopqrstuvwxyz" i (+ i 1)))))

(defun normalize-id-char (ch style)
  (let ((lower (ascii-lower-char ch)))
    (if (not (ascii-char-p ch))
        (if (or (string= style "ascii") (string= style "gfm")) "" lower)
        (if (not (null (string-index lower "abcdefghijklmnopqrstuvwxyz0123456789_-")))
            lower
            (if (string= ch " ") "-"
                "")))))

(defun slugify-identifier (text)
  (let* ((style (identifier-style))
         (i 0)
         (n (length text))
         (out ""))
    (while (< i n)
      (setq out (string-append out (normalize-id-char (substring text i (+ i 1)) style)))
      (setq i (+ i 1)))
    (let ((s out))
      (if (or (string= style "gfm") (string= style "mmd") (string= style "auto"))
          (let ((i 0)
                (collapsed "")
                (prev-dash nil))
            (while (< i (length s))
              (let ((ch (substring s i (+ i 1))))
                (if (string= ch "-")
                    (if prev-dash
                        nil
                        (progn
                          (setq collapsed (string-append collapsed ch))
                          (setq prev-dash t)))
                    (progn
                      (setq collapsed (string-append collapsed ch))
                      (setq prev-dash nil))))
              (setq i (+ i 1)))
            (setq s collapsed))
          nil)
      (while (and (> (length s) 0) (string= (substring s 0 1) "-"))
        (setq s (substring s 1 (length s))))
      (while (and (> (length s) 0) (string= (substring s (- (length s) 1) (length s)) "-"))
        (setq s (substring s 0 (- (length s) 1))))
      (if (= (length s) 0) "section" s))))

(defun maybe-strip-leading-colon (s)
  (let ((t (trim-line s)))
    (if (and (> (length t) 1) (string= (substring t 0 1) ":"))
        (trim-line (substring t 1 (length t)))
        t)))

(defun split-trailing-attrs (text)
  (let* ((t (trim-line text))
         (n (length t))
         (lb (last-index-of-char t "{")))
    (if (or (null lb) (<= lb 0) (not (string= (substring t (- n 1) n) "}")))
        (list t '() '() '())
        (let* ((body (substring t (+ lb 1) (- n 1)))
               (parsed (parse-attrs-body (maybe-strip-leading-colon body)))
               (head (trim-line (substring t 0 lb))))
          (list head (first parsed) (second parsed) (third parsed))))))

(defun heading-meta (text)
  (let* ((parts (split-trailing-attrs text))
         (head (first parts))
         (hid (second parts))
         (classes (third parts))
         (attrs (fourth parts))
         (final-id (if (null hid) (slugify-identifier head) hid)))
    (list head final-id classes attrs)))

(defglobal *md-link-refs* '())
(defglobal *md-abbrevs* '())
(defglobal *md-latex-macros* '())
(defglobal *md-metadata* '())
(defglobal *md-footnote-defs* '())
(defglobal *md-footnotes-used* '())
(defglobal *md-inline-note-counter* 0)
(defglobal *md-citations-used* '())
(defglobal *md-parse-depth* 0)

(defun lower-ascii-string (s)
  (let ((i 0)
        (n (length s))
        (out ""))
    (while (< i n)
      (setq out (string-append out (ascii-lower-char (substring s i (+ i 1)))))
      (setq i (+ i 1)))
    out))

(defun normalize-ref-key (s)
  (trim-line (lower-ascii-string s)))

(defun assoc-lookup (key alist)
  (let ((r alist)
        (v '()))
    (while (and (null v) (not (null r)))
      (if (string= key (first (first r)))
          (setq v (second (first r)))
          nil)
      (setq r (cdr r)))
    v))

(defun assoc-put (key value alist)
  (append alist (list (list key value))))

(defun line-key-value-or-nil (line)
  (let* ((t (trim-line line))
         (c (string-index ":" t)))
    (if (or (null c) (= c 0))
        '()
        (let ((k (lower-ascii-string (trim-line (substring t 0 c))))
              (v (trim-line (substring t (+ c 1) (length t)))))
          (if (= (length v) 0)
              '()
              (list k v))))))

(defun parse-footnote-def-line-or-nil (line)
  (let ((t (trim-line line)))
    (if (and (> (length t) 5)
             (starts-with t "[^"))
        (let ((rb (string-index "]" t))
              (colon (string-index ":" t)))
          (if (and (not (null rb))
                   (not (null colon))
                   (= rb (- colon 1)))
              (let ((id (substring t 2 rb))
                    (body (trim-line (substring t (+ colon 1) (length t)))))
                (if (> (length id) 0)
                    (list id body)
                    '()))
              '()))
        '())))

(defun parse-metadata-from-yaml-lines (lines)
  (let ((meta '()))
    (dolist (ln lines)
      (let ((kv (line-key-value-or-nil ln)))
        (if (null kv)
            nil
            (setq meta (assoc-put (first kv) (second kv) meta)))))
    meta))

(defun parse-ref-def-line-or-nil (line)
  (let ((t (trim-line line)))
    (if (and (> (length t) 4) (string= (substring t 0 1) "["))
        (let ((rb (string-index "]" t))
              (colon (string-index ":" t)))
          (if (and (not (null rb))
                   (not (null colon))
                   (< rb colon))
              (let* ((between (trim-line (substring t (+ rb 1) colon)))
                     (ok-space (or (= (length between) 0) (string= between "")))
                     (key (substring t 1 rb))
                     (url (trim-line (substring t (+ colon 1) (length t)))))
                (if (and ok-space (> (length url) 0))
                    (list (normalize-ref-key key) url)
                    '()))
              '()))
        '())))

(defun parse-abbrev-def-line-or-nil (line)
  (let ((t (trim-line line)))
    (if (and (> (length t) 4) (string= (substring t 0 2) "*["))
        (let ((rb (string-index "]" t))
              (colon (string-index ":" t)))
          (if (and (not (null rb))
                   (not (null colon))
                   (= rb (- colon 1)))
              (let ((key (substring t 2 rb))
                    (title (trim-line (substring t (+ colon 1) (length t)))))
                (if (> (length key) 0)
                    (list key title)
                    '()))
              '()))
        '())))

(defun parse-latex-macro-def-line-or-nil (line)
  (let ((t (trim-line line)))
    (if (or (starts-with t "\\newcommand{")
            (starts-with t "\\def\\"))
        (let ((lbrace (string-index "{" t))
              (rbrace (last-index-of-char t "}")))
          (if (or (null lbrace) (null rbrace) (<= rbrace lbrace))
              '()
              (let ((name "")
                    (body ""))
                (if (starts-with t "\\newcommand{")
                    (let ((rb (string-index "}" t)))
                      (if (and (not (null rb)) (> rb 12))
                          (progn
                            (setq name (substring t 12 rb))
                            (setq body (trim-line (substring t (+ rb 1) (length t)))))
                          nil))
                    (let ((sp (string-index " " t)))
                      (if (and (not (null sp)) (> sp 5))
                          (progn
                            (setq name (substring t 4 sp))
                            (setq body (trim-line (substring t (+ sp 1) (length t)))))
                          nil)))
                (if (or (= (length name) 0) (= (length body) 0))
                    '()
                    (list name body)))))
        '())))

(defun replace-all-local (s needle repl)
  (let ((n (length s))
        (m (length needle))
        (i 0)
        (out ""))
    (if (= m 0)
        s
        (progn
          (while (< i n)
            (if (and (<= (+ i m) n)
                     (string= (substring s i (+ i m)) needle))
                (progn
                  (setq out (string-append out repl))
                  (setq i (+ i m)))
                (progn
                  (setq out (string-append out (substring s i (+ i 1))))
                  (setq i (+ i 1)))))
          out))))

(defun apply-latex-macros (s)
  (let ((out s)
        (r *md-latex-macros*))
    (while (not (null r))
      (let ((name (first (first r)))
            (body (second (first r))))
        (setq out (replace-all-local out name body)))
      (setq r (cdr r)))
    out))

(defun consume-leading-blank-lines (lines)
  (let ((r lines))
    (while (and (not (null r)) (= (length (trim-line (first r))) 0))
      (setq r (cdr r)))
    r))

(defun consume-yaml-metadata (lines)
  (let ((r (consume-leading-blank-lines lines)))
    (if (or (null r) (not (string= (trim-line (first r)) "---")))
        (list '() lines)
        (let ((q (cdr r))
              (body '())
              (done nil))
          (while (and (not done) (not (null q)))
            (if (or (string= (trim-line (first q)) "---")
                    (string= (trim-line (first q)) "..."))
                (progn
                  (setq done t)
                  (setq q (cdr q)))
                (progn
                  (setq body (append body (list (first q))))
                  (setq q (cdr q)))))
          (if done
              (list (parse-metadata-from-yaml-lines body) q)
              (list '() lines))))))

(defun consume-pandoc-title-block (lines)
  (let ((r (consume-leading-blank-lines lines)))
    (if (or (null r) (not (starts-with (trim-line (first r)) "%")))
        (list '() lines)
        (let ((q r)
              (rows '()))
          (while (and (not (null q)) (starts-with (trim-line (first q)) "%"))
            (setq rows (append rows (list (trim-line (substring (trim-line (first q)) 1 (length (trim-line (first q))))))))
            (setq q (cdr q)))
          (let ((meta '()))
            (if (> (length rows) 0)
                (setq meta (assoc-put "title" (first rows) meta))
                nil)
            (if (> (length rows) 1)
                (setq meta (assoc-put "author" (second rows) meta))
                nil)
            (if (> (length rows) 2)
                (setq meta (assoc-put "date" (third rows) meta))
                nil)
            (list meta q))))))

(defun consume-mmd-title-block (lines)
  (let ((r (consume-leading-blank-lines lines))
        (meta '())
        (consumed nil))
    (while (and (not (null r))
                (not consumed)
                (> (length (trim-line (first r))) 0))
      (let ((kv (line-key-value-or-nil (first r))))
        (if (or (null kv)
                (and (not (string= (first kv) "title"))
                     (not (string= (first kv) "author"))
                     (not (string= (first kv) "date"))))
            (setq consumed t)
            (progn
              (setq meta (assoc-put (first kv) (second kv) meta))
              (setq r (cdr r))))))
    (if (= (length meta) 0)
        (list '() lines)
        (list meta r))))

(defun merge-metadata (a b)
  (append a b))

(defun footnote-used-index (id used)
  (let ((i 1)
        (r used)
        (hit '()))
    (while (and (null hit) (not (null r)))
      (if (string= id (first (first r)))
          (setq hit i)
          nil)
      (setq i (+ i 1))
      (setq r (cdr r)))
    hit))

(defun ensure-footnote-used (id text)
  (let ((idx (footnote-used-index id *md-footnotes-used*)))
    (if (null idx)
        (progn
          (setq *md-footnotes-used* (append *md-footnotes-used* (list (list id text))))
          (length *md-footnotes-used*))
        idx)))

(defun build-footnotes-html ()
  (if (= (length *md-footnotes-used*) 0)
      ""
      (let ((r *md-footnotes-used*)
            (out "<section class=\"footnotes\">\n<ol>"))
        (while (not (null r))
          (let ((id (first (first r)))
                (txt (second (first r))))
            (setq out (string-append out
                                     "\n<li id=\"fn:"
                                     (attr-escape id)
                                     "\">"
                                     (render-inline-nodes (parse-inline txt (md-pos 1 1 0)))
                                     " <a href=\"#fnref:"
                                     (attr-escape id)
                                     "\">â†©</a></li>")))
          (setq r (cdr r)))
        (string-append out "\n</ol>\n</section>"))))

(defun build-metadata-html ()
  (if (= (length *md-metadata*) 0)
      ""
      (let ((r *md-metadata*)
            (out "<section class=\"metadata\">\n<ul>"))
        (while (not (null r))
          (let ((k (first (first r)))
                (v (second (first r))))
            (setq out
                  (string-append out
                                 "\n<li><strong>"
                                 (html-escape k)
                                 "</strong>: "
                                 (html-escape v)
                                 "</li>")))
          (setq r (cdr r)))
        (string-append out "\n</ul>\n</section>"))))

(defun add-citation-key (key)
  (let ((k (trim-line key)))
    (if (or (= (length k) 0) (not (null (assoc-lookup k *md-citations-used*))))
        nil
        (setq *md-citations-used* (append *md-citations-used* (list (list k "1")))))))

(defun parse-citation-inline-or-nil (text i pos)
  (if (or (not (starts-with-at text i "[@"))
          (null (find-substring-from text "]" (+ i 2))))
      '()
      (let* ((j (find-substring-from text "]" (+ i 2)))
             (body (substring text (+ i 1) j))
             (parts (split-by-char body ";"))
             (keys '())
             (labels '()))
        (dolist (p parts)
          (let ((v (trim-line p)))
            (if (starts-with v "@")
                (progn
                  (setq keys (append keys (list (substring v 1 (length v)))))
                  (setq labels (append labels (list v))))
                (if (starts-with v "-@")
                    (progn
                      (setq keys (append keys (list (substring v 2 (length v)))))
                      (setq labels (append labels (list v)))
                      nil)
                    nil))))
        (if (= (length keys) 0)
            '()
            (progn
              (dolist (k keys) (add-citation-key k))
              (list (+ j 1)
                    (make-inline-raw
                     pos
                     'html
                     (string-append "<span class=\"citation\" data-cites=\""
                                    (attr-escape (join-lines-space keys))
                                    "\">["
                                    (html-escape (join-lines-space labels))
                                    "]</span>"))))))))

(defun parse-footnote-ref-inline-or-nil (text i pos)
  (if (or (not (starts-with-at text i "[^"))
          (null (find-substring-from text "]" (+ i 2))))
      '()
      (let* ((j (find-substring-from text "]" (+ i 2)))
             (id (substring text (+ i 2) j))
             (note-text (assoc-lookup id *md-footnote-defs*)))
        (if (= (length id) 0)
            '()
            (let ((idx (ensure-footnote-used id (if (null note-text) "" note-text))))
              (list (+ j 1)
                    (make-inline-raw
                     pos
                     'html
                     (string-append "<sup id=\"fnref:"
                                    (attr-escape id)
                                    "\"><a href=\"#fn:"
                                    (attr-escape id)
                                    "\">"
                                    (format nil "~A" idx)
                                    "</a></sup>"))))))))

(defun parse-inline-note-or-nil (text i pos)
  (if (or (not (starts-with-at text i "^["))
          (null (find-substring-from text "]" (+ i 2))))
      '()
      (let* ((j (find-substring-from text "]" (+ i 2)))
             (body (substring text (+ i 2) j)))
        (setq *md-inline-note-counter* (+ *md-inline-note-counter* 1))
        (let* ((id (string-append "inline-" (format nil "~A" *md-inline-note-counter*)))
               (idx (ensure-footnote-used id body)))
          (list (+ j 1)
                (make-inline-raw
                 pos
                 'html
                 (string-append "<sup id=\"fnref:"
                                (attr-escape id)
                                "\"><a href=\"#fn:"
                                (attr-escape id)
                                "\">"
                                (format nil "~A" idx)
                                "</a></sup>")))))))

(defun preprocess-markdown (text)
  (let ((lines (gutenberg-process-lines (split-lines text)))
        (kept '())
        (refs '())
        (abbrs '())
        (macros '())
        (foots '()))
    (let* ((y (consume-yaml-metadata lines))
           (m1 (first y))
           (r1 (second y))
           (p (consume-pandoc-title-block r1))
           (m2 (first p))
           (r2 (second p))
           (m (consume-mmd-title-block r2))
           (m3 (first m))
           (r3 (second m)))
      (setq *md-metadata* (merge-metadata (merge-metadata m1 m2) m3))
      (let ((r r3))
        (while (not (null r))
          (let ((ln (first r))
                (q (cdr r)))
            (let ((ref (parse-ref-def-line-or-nil ln))
                  (ab (parse-abbrev-def-line-or-nil ln))
                  (mc (parse-latex-macro-def-line-or-nil ln))
                  (fn (parse-footnote-def-line-or-nil ln)))
              (if (not (null fn))
                  (let ((id (first fn))
                        (body (second fn))
                        (done nil))
                    (while (and (not done) (not (null q)))
                      (let ((next-line (first q)))
                        (if (= (length (trim-line next-line)) 0)
                            (progn
                              (setq body (string-append body "\n"))
                              (setq q (cdr q)))
                            (if (>= (count-leading-ws next-line) 2)
                                (progn
                                  (setq body (string-append body "\n" (trim-line next-line)))
                                  (setq q (cdr q)))
                                (setq done t)))))
                    (setq foots (append foots (list (list id body)))))
                  (if (not (null ref))
                      (setq refs (append refs (list ref)))
                      (if (not (null ab))
                      (setq abbrs (append abbrs (list ab)))
                      (if (not (null mc))
                          (setq macros (append macros (list mc)))
                          (setq kept (append kept (list ln))))))))
            (setq r q)))))
    (setq *md-link-refs* refs)
    (setq *md-abbrevs* abbrs)
    (setq *md-latex-macros* macros)
    (setq *md-footnote-defs* foots)
    (setq *md-footnotes-used* '())
    (setq *md-inline-note-counter* 0)
    (setq *md-citations-used* '())
    (join-lines-newline kept)))

(defun lookup-ref-link (label)
  (assoc-lookup (normalize-ref-key label) *md-link-refs*))

(defun split-ws (s)
  (let ((i 0)
        (n (length s))
        (cur "")
        (out '()))
    (while (< i n)
      (let ((ch (substring s i (+ i 1))))
        (if (null (string-index ch " \t\r"))
            (setq cur (string-append cur ch))
            (if (> (length cur) 0)
                (progn
                  (setq out (append out (list cur)))
                  (setq cur ""))
                nil)))
      (setq i (+ i 1)))
    (if (> (length cur) 0) (setq out (append out (list cur))) nil)
    out))

(defun last-index-of-char (s ch)
  (let ((i (- (length s) 1))
        (found '()))
    (while (and (null found) (>= i 0))
      (if (string= (substring s i (+ i 1)) ch)
          (setq found i)
          nil)
      (setq i (- i 1)))
    found))

(defun parse-attrs-body (body)
  (let ((tokens (split-ws body))
        (id '())
        (classes '())
        (attrs '()))
    (dolist (tk tokens)
      (if (and (> (length tk) 1) (string= (substring tk 0 1) "#"))
          (setq id (substring tk 1 (length tk)))
          (if (and (> (length tk) 1) (string= (substring tk 0 1) "."))
              (setq classes (append classes (list (substring tk 1 (length tk)))))
              (let ((eqp (string-index "=" tk)))
                (if (not (null eqp))
                    (setq attrs
                          (append attrs
                                  (list (list (substring tk 0 eqp)
                                              (substring tk (+ eqp 1) (length tk))))))
                    nil)))))
    (list id classes attrs)))

(defun parse-fence-info (info)
  (let* ((trimmed (trim-line info))
         (id '())
         (classes '())
         (attrs '())
         (lang ""))
    (if (> (length trimmed) 0)
        (let ((lbrace (string-index "{" trimmed))
              (rbrace (last-index-of-char trimmed "}")))
          (if (and (not (null lbrace))
                   (not (null rbrace))
                   (< lbrace rbrace)
                   (= rbrace (- (length trimmed) 1)))
              (let* ((before (trim-line (substring trimmed 0 lbrace)))
                     (body (substring trimmed (+ lbrace 1) rbrace))
                     (parsed (parse-attrs-body body)))
                (setq id (first parsed))
                (setq classes (second parsed))
                (setq attrs (third parsed))
                (if (> (length before) 0)
                    (setq lang (first (split-ws before)))
                    nil))
              (setq lang (first (split-ws trimmed)))))
        nil)
    (if (> (length lang) 0)
        (setq classes (append (list (string-append "language-" lang)) classes))
        nil)
    (list id classes attrs)))

(defun parse-fence-start (line)
  (let* ((indent (skip-leading-ws line))
         (n (length line)))
    (if (>= indent n)
        '()
        (let* ((rest (substring line indent n))
               (m (length rest))
               (ch (substring rest 0 1)))
          (if (or (string= ch "`") (string= ch "~"))
              (let ((i 0))
                (while (and (< i m) (string= (substring rest i (+ i 1)) ch))
                  (setq i (+ i 1)))
                (if (>= i 3)
                    (let* ((info (trim-line (substring rest i m)))
                           (parsed (parse-fence-info info)))
                      (list indent ch i
                            (first parsed)
                            (second parsed)
                            (third parsed)))
                    '()))
              '())))))

(defun fence-end-p (line fence-info)
  (let* ((indent (skip-leading-ws line))
         (n (length line))
         (ch (second fence-info))
         (need (third fence-info)))
    (if (>= indent n)
        nil
        (let* ((rest (substring line indent n))
               (m (length rest))
               (i 0))
          (while (and (< i m) (string= (substring rest i (+ i 1)) ch))
            (setq i (+ i 1)))
          (and (>= i need)
               (all-space-tab-p (substring rest i m)))))))

(defun line-block-content-or-nil (line)
  (let* ((n (length line))
         (i (skip-leading-ws line)))
    (if (and (< i n) (string= (substring line i (+ i 1)) "|"))
        (let ((j (+ i 1)))
          (if (and (< j n) (string= (substring line j (+ j 1)) " "))
              (setq j (+ j 1))
              nil)
          (substring line j n))
        '())))

(defun split-by-char (s sep)
  (let ((i 0)
        (n (length s))
        (start 0)
        (out '()))
    (while (< i n)
      (if (string= (substring s i (+ i 1)) sep)
          (progn
            (setq out (append out (list (substring s start i))))
            (setq start (+ i 1)))
          nil)
      (setq i (+ i 1)))
    (setq out (append out (list (substring s start n))))
    out))

(defun take-first-n (xs n)
  (let ((r xs)
        (i 0)
        (out '()))
    (while (and (< i n) (not (null r)))
      (setq out (append out (list (first r))))
      (setq r (cdr r))
      (setq i (+ i 1)))
    out))

(defun normalize-row-cells (cells width)
  (let ((n (length cells)))
    (if (= n width)
        cells
        (if (> n width)
            (take-first-n cells width)
            (let ((out cells))
              (while (< (length out) width)
                (setq out (append out (list ""))))
              out)))))

(defun append-last-cell-in-row (cells text)
  (if (null cells)
      cells
      (if (null (cdr cells))
          (list (string-append (first cells) "\n" text))
          (cons (first cells)
                (append-last-cell-in-row (cdr cells) text)))))

(defun append-last-cell-in-rows (rows text)
  (if (null rows)
      rows
      (if (null (cdr rows))
          (list (append-last-cell-in-row (first rows) text))
          (cons (first rows)
                (append-last-cell-in-rows (cdr rows) text)))))

(defun parse-pipe-cells (line)
  (let* ((tline (trim-line line))
         (n (length tline))
         (body (if (and (> n 0) (string= (substring tline 0 1) "|"))
                   (substring tline 1 n)
                   tline))
         (m (length body))
         (body2 (if (and (> m 0) (string= (substring body (- m 1) m) "|"))
                    (substring body 0 (- m 1))
                    body))
         (cells (split-by-char body2 "|"))
         (out '()))
    (dolist (c cells)
      (setq out (append out (list (trim-line c)))))
    out))

(defun pipe-sep-cell-align (cell)
  (let* ((t (trim-line cell))
         (n (length t)))
    (if (= n 0)
        '()
        (let ((i 0)
              (ok t)
              (left (string= (substring t 0 1) ":"))
              (right (string= (substring t (- n 1) n) ":")))
          (while (and ok (< i n))
            (let ((ch (substring t i (+ i 1))))
              (if (or (string= ch "-") (string= ch ":"))
                  nil
                  (setq ok nil)))
            (setq i (+ i 1)))
          (if (or (not ok) (< n 3))
              '()
              (if (and left right)
                  "center"
                  (if left
                      "left"
                      (if right "right" '()))))))))

(defun parse-pipe-aligns-or-nil (line)
  (let ((cells (parse-pipe-cells line))
        (out '())
        (ok t))
    (if (= (length cells) 0)
        '()
        (progn
          (dolist (c cells)
            (let ((a (pipe-sep-cell-align c)))
              (if (and (null a)
                       (< (length (trim-line c)) 3))
                  (setq ok nil)
                  nil)
              (if (and ok (null a))
                  (let ((i 0)
                        (t (trim-line c))
                        (only-dash t))
                    (while (and only-dash (< i (length t)))
                      (if (string= (substring t i (+ i 1)) "-")
                          nil
                          (setq only-dash nil))
                      (setq i (+ i 1)))
                    (if only-dash
                        (setq out (append out (list '())))
                        (setq ok nil)))
                  (if ok (setq out (append out (list a))) nil))))
          (if ok out '())))))

(defun table-caption-or-nil (line)
  (let ((t (trim-line line)))
    (if (and (>= (length t) 6) (string= (substring t 0 6) "Table:"))
        (trim-line (substring t 6 (length t)))
        '())))

(defun table-attrs-line-or-nil (line)
  (let* ((t (trim-line line))
         (n (length t)))
    (if (and (>= n 2)
             (string= (substring t 0 1) "{")
             (string= (substring t (- n 1) n) "}"))
        (parse-attrs-body (substring t 1 (- n 1)))
        '())))

(defun split-by-double-space (s)
  (let ((i 0)
        (n (length s))
        (start 0)
        (gap 0)
        (out '()))
    (while (< i n)
      (if (string= (substring s i (+ i 1)) " ")
          (setq gap (+ gap 1))
          (setq gap 0))
      (if (and (>= gap 2)
               (> i start)
               (not (string= (substring s (- i 1) i) " ")))
          nil
          nil)
      (if (and (>= gap 2)
               (> (- (+ i 1) gap) start))
          (progn
            (setq out (append out (list (trim-line (substring s start (- (+ i 1) gap))))))
            (setq start (+ i 1))
            (setq gap 0))
          nil)
      (setq i (+ i 1)))
    (setq out (append out (list (trim-line (substring s start n)))))
    out))

(defun simple-sep-line-aligns-or-nil (line)
  (let ((cells (split-by-double-space (trim-line line)))
        (out '())
        (ok t))
    (if (= (length cells) 0)
        '()
        (progn
          (dolist (c cells)
            (let ((a (pipe-sep-cell-align c)))
              (if (null a)
                  (let ((t (trim-line c)))
                    (if (>= (length t) 3)
                        (let ((i 0)
                              (good t))
                          (while (and good (< i (length t)))
                            (if (string= (substring t i (+ i 1)) "-")
                                nil
                                (setq good nil))
                            (setq i (+ i 1)))
                          (if good
                              (setq a '())
                              (setq ok nil)))
                        (setq ok nil)))
                  nil)
              (if ok (setq out (append out (list a))) nil)))
          (if ok out '())))))

(defun grid-border-info-or-nil (line)
  (let ((t (trim-line line))
        (widths '())
        (kind "-"))
    (if (or (< (length t) 3)
            (not (string= (substring t 0 1) "+"))
            (not (string= (substring t (- (length t) 1) (length t)) "+")))
        '()
        (let ((parts (split-by-char (substring t 1 (- (length t) 1)) "+"))
              (ok t))
          (dolist (p parts)
            (let ((tp (trim-line p)))
              (if (= (length tp) 0)
                  (setq ok nil)
                  (let ((i 0)
                        (k (substring tp 0 1)))
                    (if (or (string= k "-") (string= k "="))
                        (progn
                          (while (and ok (< i (length tp)))
                            (if (string= (substring tp i (+ i 1)) k)
                                nil
                                (setq ok nil))
                            (setq i (+ i 1)))
                          (setq widths (append widths (list (length tp))))
                          (if (string= k "=") (setq kind "=") nil))
                        (setq ok nil))))))
          (if ok (list widths kind) '())))))

(defun grid-row-cells-or-nil (line widths)
  (let ((t line)
        (cells '())
        (ok t)
        (ws widths)
        (p 0))
    (if (or (< (length t) 2)
            (not (string= (substring t 0 1) "|")))
        '()
        (progn
          (setq p 1)
          (while (and ok (not (null ws)))
            (let ((w (first ws)))
              (if (> (+ p w) (length t))
                  (setq ok nil)
                  (progn
                    (setq cells (append cells (list (trim-line (substring t p (+ p w))))))
                    (setq p (+ p w))
                    (if (or (>= p (length t)) (not (string= (substring t p (+ p 1)) "|")))
                        (setq ok nil)
                        (setq p (+ p 1))))))
            (setq ws (cdr ws)))
          (if ok cells '())))))

(defun parse-link-tail (tail-after-label)
  (if (and (not (null tail-after-label))
           (eq (inline-token-kind (first tail-after-label)) 'rbrack)
           (not (null (cdr tail-after-label))))
      (let* ((t2 (second tail-after-label))
             (t3 (if (or (null (cdr (cdr tail-after-label)))) '() (third tail-after-label)))
             (space-bridge (and (eq (inline-token-kind t2) 'text)
                                (all-space-tab-p (inline-token-lexeme t2))
                                (not (null t3))
                                (eq (inline-token-kind t3) 'lparen)))
             (direct (eq (inline-token-kind t2) 'lparen))
             (p (if direct
                    (cdr (cdr tail-after-label))
                    (if space-bridge
                        (cdr (cdr (cdr tail-after-label)))
                        '())))
             )
        (if (or direct space-bridge)
            (let ((url-tokens '())
                  (closed nil))
              (while (and (not (null p)) (not closed))
                (if (eq (inline-token-kind (first p)) 'rparen)
                    (setq closed t)
                    (setq url-tokens (append url-tokens (list (first p)))))
                (if closed nil (setq p (cdr p))))
              (if closed
                  (list t (join-inline-token-lexemes url-tokens) (cdr p))
                  (list nil "" tail-after-label)))
            (list nil "" tail-after-label)))
      (list nil "" tail-after-label)))

(defun parse-leading-braced-attrs (s)
  (let ((t (trim-line s)))
    (if (or (= (length t) 0)
            (not (string= (substring t 0 1) "{")))
        '()
        (let ((rb (last-index-of-char t "}")))
          (if (or (null rb) (< rb 1))
              '()
              (let* ((body (substring t 1 rb))
                     (rest (trim-line (substring t (+ rb 1) (length t))))
                     (parsed (parse-attrs-body (maybe-strip-leading-colon body))))
                (list (first parsed) (second parsed) (third parsed) rest)))))))

(defun consume-inline-attrs (rest)
  (if (or (null rest)
          (not (eq (inline-token-kind (first rest)) 'text)))
      (list '() '() '() rest)
      (let* ((lex (inline-token-lexeme (first rest)))
             (parsed (parse-leading-braced-attrs lex)))
        (if (null parsed)
            (list '() '() '() rest)
            (let ((rid (first parsed))
                  (rclasses (second parsed))
                  (rattrs (third parsed))
                  (remaining (fourth parsed))
                  (tail (cdr rest)))
              (if (> (length remaining) 0)
                  (list rid rclasses rattrs
                        (cons (make-inline-token 'text remaining (inline-token-pos (first rest))) tail))
                  (list rid rclasses rattrs tail)))))))

(defun capture-bracket-lexeme (tokens)
  (let ((probe tokens)
        (captured '())
        (closed nil))
    (while (and (not (null probe)) (not closed))
      (if (eq (inline-token-kind (first probe)) 'rbrack)
          (setq closed t)
          (setq captured (append captured (list (first probe)))))
      (if closed nil (setq probe (cdr probe))))
    (if closed
        (list (join-inline-token-lexemes captured) (cdr probe))
        '())))

(defun make-footnote-ref-node (id pos)
  (let ((note-text (assoc-lookup id *md-footnote-defs*)))
    (let ((idx (ensure-footnote-used id (if (null note-text) "" note-text))))
      (make-inline-raw pos
                       'html
                       (string-append "<sup id=\"fnref:"
                                      (attr-escape id)
                                      "\"><a href=\"#fn:"
                                      (attr-escape id)
                                      "\">"
                                      (format nil "~A" idx)
                                      "</a></sup>")))))

(defun parse-citation-label-node-or-nil (label pos)
  (let* ((parts (split-by-char label ";"))
         (keys '())
         (labels '()))
    (dolist (p parts)
      (let ((v (trim-line p)))
        (if (starts-with v "@")
            (progn
              (setq keys (append keys (list (substring v 1 (length v)))))
              (setq labels (append labels (list v))))
            (if (starts-with v "-@")
                (progn
                  (setq keys (append keys (list (substring v 2 (length v)))))
                  (setq labels (append labels (list v)))
                  nil)
                nil))))
    (if (= (length keys) 0)
        '()
        (progn
          (dolist (k keys) (add-citation-key k))
          (make-inline-raw pos
                           'html
                           (string-append "<span class=\"citation\" data-cites=\""
                                          (attr-escape (join-lines-space keys))
                                          "\">["
                                          (html-escape (join-lines-space labels))
                                          "]</span>"))))))

(defun make-inline-note-node (body pos)
  (setq *md-inline-note-counter* (+ *md-inline-note-counter* 1))
  (let* ((id (string-append "inline-" (format nil "~A" *md-inline-note-counter*)))
         (idx (ensure-footnote-used id body)))
    (make-inline-raw pos
                     'html
                     (string-append "<sup id=\"fnref:"
                                    (attr-escape id)
                                    "\"><a href=\"#fn:"
                                    (attr-escape id)
                                    "\">"
                                    (format nil "~A" idx)
                                    "</a></sup>"))))

(defun strip-trailing-caret-from-nodes (nodes)
  (if (null nodes)
      (list nodes nil)
      (if (null (cdr nodes))
          (let ((n (first nodes)))
            (if (eq (inline-kind n) 'inline-text)
                (let* ((v (inline-text-value n))
                       (len (length v)))
                  (if (and (> len 0) (string= (substring v (- len 1) len) "^"))
                      (if (= len 1)
                          (list '() t)
                          (list (list (make-inline-text (inline-pos n) (substring v 0 (- len 1)))) t))
                      (list nodes nil)))
                (list nodes nil)))
          (let ((tail (strip-trailing-caret-from-nodes (cdr nodes))))
            (list (cons (first nodes) (first tail)) (second tail))))))

(defun parse-lbrack-token (tok rest nodes)
  (if (and (not (null (cdr rest))) (eq (inline-token-kind (second rest)) 'lbrack))
      (let ((wcap (capture-double-bracket-lexeme (cdr (cdr rest)))))
        (if (null wcap)
            (list (append nodes (list (make-inline-text (inline-token-pos tok) "[")))
                  (cdr rest))
            (let ((wnode (wikilink-node-or-nil (first wcap) (inline-token-pos tok))))
              (if (null wnode)
                  (list (append nodes (list (make-inline-text (inline-token-pos tok) "[")))
                        (cdr rest))
                  (list (append nodes (list wnode))
                        (second wcap))))))
      (let ((cap (capture-bracket-lexeme (cdr rest))))
        (if (null cap)
            (list (append nodes (list (make-inline-text (inline-token-pos tok) "[")))
                  (cdr rest))
            (let ((label-raw (first cap))
                  (after-rbrack (second cap)))
              (if (starts-with label-raw "^")
                  (list (append nodes
                                (list (make-footnote-ref-node
                                       (substring label-raw 1 (length label-raw))
                                       (inline-token-pos tok))))
                        after-rbrack)
                  (let ((caret-res (strip-trailing-caret-from-nodes nodes))
                        (citation-node (if (starts-with label-raw "@")
                                           (parse-citation-label-node-or-nil label-raw (inline-token-pos tok))
                                           '())))
                    (if (second caret-res)
                        (list (append (first caret-res)
                                      (list (make-inline-note-node label-raw (inline-token-pos tok))))
                              after-rbrack)
                        (if (not (null citation-node))
                            (list (append nodes (list citation-node))
                                  after-rbrack)
                            (let* ((parsed-label (parse-inline-until (cdr rest) '(rbrack)))
                                   (label-nodes (first parsed-label))
                                   (tail-after-label (second parsed-label))
                                   (tail-res (parse-link-tail tail-after-label)))
                              (if (first tail-res)
                                  (let* ((attrs-res (consume-inline-attrs (third tail-res)))
                                         (lid (first attrs-res))
                                         (lclasses (second attrs-res))
                                         (lattrs (third attrs-res))
                                         (tail (fourth attrs-res)))
                                    (list (append nodes
                                                  (list (make-inline-link (inline-token-pos tok)
                                                                          label-nodes
                                                                          (second tail-res)
                                                                          lid
                                                                          lclasses
                                                                          lattrs)))
                                          tail))
                                  (if (and (not (null tail-after-label))
                                           (eq (inline-token-kind (first tail-after-label)) 'rbrack))
                                      (let* ((attrs-res (consume-inline-attrs (cdr tail-after-label)))
                                             (sid (first attrs-res))
                                             (sclasses (second attrs-res))
                                             (sattrs (third attrs-res))
                                             (tail (fourth attrs-res)))
                                        (if (or (not (null sid)) (not (null sclasses)) (not (null sattrs)))
                                            (list (append nodes
                                                          (list (make-inline-span (inline-token-pos tok)
                                                                                  label-nodes
                                                                                  sid
                                                                                  sclasses
                                                                                  sattrs)))
                                                  tail)
                                            (let ((label (inline-nodes-plain-text label-nodes))
                                                  (ref-url (lookup-ref-link (inline-nodes-plain-text label-nodes))))
                                              (list (append nodes
                                                            (list (make-inline-link (inline-token-pos tok)
                                                                                    label-nodes
                                                                                    (if (null ref-url)
                                                                                        (string-append "#" (slugify-identifier label))
                                                                                        ref-url)
                                                                                    '()
                                                                                    '()
                                                                                    '())))
                                                    (cdr tail-after-label)))))
                                      (list (append nodes (list (make-inline-text (inline-token-pos tok) "[")))
                                            (cdr rest))))))))))))))

(defun inline-nodes-plain-text (nodes)
  (let ((rest nodes)
        (out ""))
    (while (not (null rest))
      (let ((n (first rest)))
        (setq out
              (string-append out
                             (cond
                              ((eq (inline-kind n) 'inline-text) (inline-text-value n))
                              ((eq (inline-kind n) 'inline-code) (inline-text-value n))
                              ((eq (inline-kind n) 'inline-emph) (inline-nodes-plain-text (inline-children n)))
                              ((eq (inline-kind n) 'inline-strong) (inline-nodes-plain-text (inline-children n)))
                              ((eq (inline-kind n) 'inline-link) (inline-nodes-plain-text (inline-children n)))
                              ((eq (inline-kind n) 'inline-image) (inline-nodes-plain-text (inline-children n)))
                              ((eq (inline-kind n) 'inline-span) (inline-nodes-plain-text (inline-children n)))
                              (t "")))))
      (setq rest (cdr rest)))
    out))

(defun parse-native-span-lexeme-or-nil (lex pos)
  (let* ((t (trim-line lex))
         (open-ok (and (>= (length t) 6) (string= (substring t 0 5) "<span")))
         (gt (if open-ok (string-index ">" t) '()))
         (close (if (null gt) '() (string-index "</span>" t))))
    (if (or (not open-ok) (null gt) (null close) (<= close gt))
        '()
        (let* ((attr-part (trim-line (substring t 5 gt)))
               (inner (substring t (+ gt 1) close))
               (attrs-parsed (if (= (length attr-part) 0)
                                 (list '() '() '())
                                 (let ((ts (split-ws attr-part))
                                       (id '())
                                       (classes '())
                                       (attrs '()))
                                   (dolist (tk ts)
                                     (let ((eqp (string-index "=" tk)))
                                       (if (not (null eqp))
                                           (let ((k (substring tk 0 eqp))
                                                 (v (substring tk (+ eqp 1) (length tk))))
                                             (if (and (>= (length v) 2)
                                                      (or (and (string= (substring v 0 1) "\"")
                                                               (string= (substring v (- (length v) 1) (length v)) "\""))
                                                          (and (string= (substring v 0 1) "'")
                                                               (string= (substring v (- (length v) 1) (length v)) "'"))))
                                                 (setq v (substring v 1 (- (length v) 1)))
                                                 nil)
                                             (if (string= k "id")
                                                 (setq id v)
                                                 (if (string= k "class")
                                                     (setq classes (split-ws v))
                                                     (setq attrs (append attrs (list (list k v)))))))
                                           nil)))
                                   (list id classes attrs))))
               (children (parse-inline inner pos)))
          (make-inline-span pos children (first attrs-parsed) (second attrs-parsed) (third attrs-parsed))))))

(defun char-in-set-p (ch set)
  (not (null (string-index ch set))))

(defun escapable-symbol-p (ch)
  (char-in-set-p ch "\\`*_{}[]()#+-.!~^=<>:"))

(defun boundary-char-p (ch)
  (or (null ch)
      (char-in-set-p ch " \t\r\n.,;:!?()[]{}<>\"'")))

(defun find-substring-from (s pat start)
  (let ((n (length s))
        (m (length pat))
        (i start)
        (found '()))
    (while (and (null found) (<= (+ i m) n))
      (if (string= (substring s i (+ i m)) pat)
          (setq found i)
          (setq i (+ i 1))))
    found))

(defun count-char-in-string (s ch)
  (let ((i 0)
        (n (length s))
        (cnt 0))
    (while (< i n)
      (if (string= (substring s i (+ i 1)) ch)
          (setq cnt (+ cnt 1))
          nil)
      (setq i (+ i 1)))
    cnt))

(defun wikilink-node-or-nil (body pos)
  (let* ((text (trim-line body))
         (bar (string-index "|" text)))
    (if (= (length text) 0)
        '()
        (let ((target "")
              (title ""))
          (if (null bar)
              (progn
                (setq target text)
                (setq title text))
              (let ((left (trim-line (substring text 0 bar)))
                    (right (trim-line (substring text (+ bar 1) (length text))))
                    (mode (wikilink-order)))
                (if (string= mode "after")
                    (progn
                      (setq target left)
                      (setq title right))
                    (if (string= mode "before")
                        (progn
                          (setq title left)
                          (setq target right))
                        (if (or (and (not (null (string-index " " left))) (null (string-index " " right)))
                                (> (count-char-in-string left " ") (count-char-in-string right " ")))
                            (progn
                              (setq title left)
                              (setq target right))
                            (progn
                              (setq target left)
                              (setq title right)))))))
          (if (= (length (trim-line target)) 0)
              '()
              (make-inline-link pos
                                (list (make-inline-text pos title))
                                (string-append "#" (slugify-identifier target))
                                '()
                                '()
                                '()))))))

(defun parse-wikilink-at (text i pos)
  (if (or (not (starts-with-at text i "[["))
          (null (find-substring-from text "]]" (+ i 2))))
      '()
      (let* ((j (find-substring-from text "]]" (+ i 2)))
             (node (wikilink-node-or-nil (substring text (+ i 2) j) pos)))
        (if (null node)
            '()
            (list (+ j 2) node)))))

(defun capture-double-bracket-lexeme (tokens)
  (let ((probe tokens)
        (captured '())
        (done nil))
    (while (and (not done) (not (null probe)))
      (if (and (not (null (cdr probe)))
               (eq (inline-token-kind (first probe)) 'rbrack)
               (eq (inline-token-kind (second probe)) 'rbrack))
          (setq done t)
          (setq captured (append captured (list (first probe)))))
      (if done nil (setq probe (cdr probe))))
    (if done
        (list (join-inline-token-lexemes captured) (cdr (cdr probe)))
        '())))

(defun starts-with-at (s i pat)
  (and (<= (+ i (length pat)) (length s))
       (string= (substring s i (+ i (length pat))) pat)))

(defun find-autolink-end (s start)
  (let ((i start)
        (n (length s))
        (done nil))
    (while (and (not done) (< i n))
      (if (char-in-set-p (substring s i (+ i 1)) " \t\r\n<>\"'")
          (setq done t)
          (setq i (+ i 1))))
    i))

(defun find-math-delim-end (s open close from)
  (let ((i from)
        (n (length s))
        (m (length close))
        (found '()))
    (while (and (null found) (<= (+ i m) n))
      (if (string= (substring s i (+ i m)) close)
          (setq found i)
          (setq i (+ i 1))))
    found))

(defun parse-inline-math-at (text i pos)
  (cond
   ((starts-with-at text i "$$")
    (let ((j (find-math-delim-end text "$$" "$$" (+ i 2))))
      (if (null j)
          '()
          (list (+ j 2) (make-inline-math pos (apply-latex-macros (substring text (+ i 2) j)) t)))))
   ((starts-with-at text i "$")
    (let ((j (find-math-delim-end text "$" "$" (+ i 1))))
      (if (null j)
          '()
          (list (+ j 1) (make-inline-math pos (apply-latex-macros (substring text (+ i 1) j)) nil)))))
   ((starts-with-at text i "\\(")
    (let ((j (find-math-delim-end text "\\(" "\\)" (+ i 2))))
      (if (null j)
          '()
          (list (+ j 2) (make-inline-math pos (apply-latex-macros (substring text (+ i 2) j)) nil)))))
   ((starts-with-at text i "\\[")
    (let ((j (find-math-delim-end text "\\[" "\\]" (+ i 2))))
      (if (null j)
          '()
          (list (+ j 2) (make-inline-math pos (apply-latex-macros (substring text (+ i 2) j)) t)))))
   ((starts-with-at text i "\\\\(")
    (let ((j (find-math-delim-end text "\\\\(" "\\\\)" (+ i 3))))
      (if (null j)
          '()
          (list (+ j 3) (make-inline-math pos (apply-latex-macros (substring text (+ i 3) j)) nil)))))
   ((starts-with-at text i "\\\\[")
    (let ((j (find-math-delim-end text "\\\\[" "\\\\]" (+ i 3))))
      (if (null j)
          '()
          (list (+ j 3) (make-inline-math pos (apply-latex-macros (substring text (+ i 3) j)) t)))))
   (t '())))

(defun parse-inline-raw-html-at (text i pos)
  (if (not (string= (substring text i (+ i 1)) "<"))
      '()
      (let ((j (find-substring-from text ">" (+ i 1))))
        (if (or (null j) (<= j i))
            '()
            (let ((raw (substring text i (+ j 1))))
              (if (or (starts-with raw "</")
                      (starts-with raw "<!")
                      (and (> (length raw) 2)
                           (char-in-set-p (substring raw 1 2) "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")))
                  (list (+ j 1) (make-inline-raw pos 'html raw))
                  '()))))))

(defun parse-inline-raw-tex-at (text i pos)
  (if (or (not (string= (substring text i (+ i 1)) "\\"))
          (>= (+ i 1) (length text)))
      '()
      (let ((j (+ i 1)))
        (if (not (char-in-set-p (substring text j (+ j 1)) "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))
            '()
            (progn
              (while (and (< j (length text))
                          (char-in-set-p (substring text j (+ j 1)) "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))
                (setq j (+ j 1)))
              (if (and (< j (length text)) (string= (substring text j (+ j 1)) "{"))
                  (let ((k (find-substring-from text "}" (+ j 1))))
                    (if (null k)
                        (list j (make-inline-raw pos 'tex (substring text i j)))
                        (list (+ k 1) (make-inline-raw pos 'tex (substring text i (+ k 1)))))
                    )
                  (list j (make-inline-raw pos 'tex (substring text i j)))))))))

(defun emoji-char-or-nil (name)
  (cond
   ((string= name "smile") "ðŸ˜„")
   ((string= name "thumbsup") "ðŸ‘")
   ((string= name "heart") "â¤ï¸")
   ((string= name "tada") "ðŸŽ‰")
   ((string= name "fire") "ðŸ”¥")
   ((string= name "rocket") "ðŸš€")
   ((string= name "warning") "âš ï¸")
   (t '())))

(defun find-abbrev-at (text i)
  (let ((r *md-abbrevs*)
        (hit '()))
    (while (and (null hit) (not (null r)))
      (let* ((k (first (first r)))
             (title (second (first r)))
             (m (length k))
             (j (+ i m))
             (prev (if (= i 0) '() (substring text (- i 1) i)))
             (next (if (< j (length text)) (substring text j (+ j 1)) '())))
        (if (and (<= j (length text))
                 (string= (substring text i j) k)
                 (boundary-char-p prev)
                 (boundary-char-p next))
            (setq hit (list k title j))
            nil))
      (setq r (cdr r)))
    hit))

(defun emit-buffer-with-abbrev (buf pos)
  (let ((j 0)
        (m (length buf))
        (seg "")
        (out '()))
    (while (< j m)
      (let ((ab (find-abbrev-at buf j)))
        (if (null ab)
            (progn
              (setq seg (string-append seg (substring buf j (+ j 1))))
              (setq j (+ j 1)))
            (progn
              (if (> (length seg) 0)
                  (setq out (append out (list (make-inline-text pos seg))))
                  nil)
              (setq seg "")
              (setq out (append out (list (make-inline-abbr pos (first ab) (second ab)))))
              (setq j (third ab))))))
    (if (> (length seg) 0)
        (setq out (append out (list (make-inline-text pos seg))))
        nil)
    out))

(defun parse-text-extensions (text pos)
  (let ((i 0)
        (n (length text))
        (buf "")
        (nodes '()))
    (while (< i n)
       (cond
        ((and (< (+ i 1) n)
              (string= (substring text i (+ i 1)) "\\")
              (escapable-symbol-p (substring text (+ i 1) (+ i 2))))
         (setq buf (string-append buf (substring text (+ i 1) (+ i 2))))
         (setq i (+ i 2)))
        ((not (null (parse-inline-math-at text i pos)))
         (let ((m (parse-inline-math-at text i pos)))
           (if (> (length buf) 0)
               (progn
                 (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
                 (setq buf ""))
               nil)
           (setq nodes (append nodes (list (second m))))
           (setq i (first m))))
        ((not (null (parse-inline-raw-html-at text i pos)))
         (let ((rh (parse-inline-raw-html-at text i pos)))
           (if (> (length buf) 0)
               (progn
                 (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
                 (setq buf ""))
               nil)
           (setq nodes (append nodes (list (second rh))))
           (setq i (first rh))))
        ((not (null (parse-inline-raw-tex-at text i pos)))
         (let ((rt (parse-inline-raw-tex-at text i pos)))
           (if (> (length buf) 0)
               (progn
                 (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
                 (setq buf ""))
               nil)
           (setq nodes (append nodes (list (second rt))))
           (setq i (first rt))))
        ((not (null (parse-wikilink-at text i pos)))
         (let ((wk (parse-wikilink-at text i pos)))
           (if (> (length buf) 0)
               (progn
                 (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
                 (setq buf ""))
               nil)
           (setq nodes (append nodes (list (second wk))))
           (setq i (first wk))))
        ((not (null (parse-inline-note-or-nil text i pos)))
         (let ((nt (parse-inline-note-or-nil text i pos)))
           (if (> (length buf) 0)
               (progn
                 (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
                 (setq buf ""))
               nil)
           (setq nodes (append nodes (list (second nt))))
           (setq i (first nt))))
        ((not (null (parse-footnote-ref-inline-or-nil text i pos)))
         (let ((fn (parse-footnote-ref-inline-or-nil text i pos)))
           (if (> (length buf) 0)
               (progn
                 (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
                 (setq buf ""))
               nil)
           (setq nodes (append nodes (list (second fn))))
           (setq i (first fn))))
        ((not (null (parse-citation-inline-or-nil text i pos)))
         (let ((ct (parse-citation-inline-or-nil text i pos)))
           (if (> (length buf) 0)
               (progn
                 (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
                 (setq buf ""))
               nil)
           (setq nodes (append nodes (list (second ct))))
           (setq i (first ct))))
        ((or (starts-with-at text i "http://")
             (starts-with-at text i "https://"))
         (if (> (length buf) 0)
             (progn
               (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
               (setq buf ""))
             nil)
         (let ((end (find-autolink-end text i)))
           (let ((url (substring text i end)))
             (setq nodes (append nodes (list (make-inline-link pos
                                                               (list (make-inline-text pos url))
                                                               url
                                                               '()
                                                               '()
                                                               '()))))
             (setq i end))))
        ((and (starts-with-at text i "~~")
              (not (null (find-substring-from text "~~" (+ i 2)))))
         (if (> (length buf) 0)
             (progn
               (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
               (setq buf ""))
             nil)
         (let ((j (find-substring-from text "~~" (+ i 2))))
           (setq nodes (append nodes (list (make-inline-del pos
                                                            (parse-inline (substring text (+ i 2) j) pos)))))
           (setq i (+ j 2))))
        ((and (starts-with-at text i "==")
              (not (null (find-substring-from text "==" (+ i 2)))))
         (if (> (length buf) 0)
             (progn
               (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
               (setq buf ""))
             nil)
         (let ((j (find-substring-from text "==" (+ i 2))))
           (setq nodes (append nodes (list (make-inline-mark pos
                                                             (parse-inline (substring text (+ i 2) j) pos)))))
           (setq i (+ j 2))))
        ((and (string= (substring text i (+ i 1)) "^")
              (not (null (find-substring-from text "^" (+ i 1)))))
         (if (> (length buf) 0)
             (progn
               (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
               (setq buf ""))
             nil)
         (let ((j (find-substring-from text "^" (+ i 1))))
           (if (> j (+ i 1))
               (progn
                 (setq nodes (append nodes (list (make-inline-sup pos
                                                                  (parse-inline (substring text (+ i 1) j) pos)))))
                 (setq i (+ j 1)))
               (progn
                 (setq buf (string-append buf "^"))
                 (setq i (+ i 1))))))
        ((and (string= (substring text i (+ i 1)) "~")
              (not (null (find-substring-from text "~" (+ i 1)))))
         (if (> (length buf) 0)
             (progn
               (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
               (setq buf ""))
             nil)
         (let ((j (find-substring-from text "~" (+ i 1))))
           (if (> j (+ i 1))
               (progn
                 (setq nodes (append nodes (list (make-inline-sub pos
                                                                  (parse-inline (substring text (+ i 1) j) pos)))))
                 (setq i (+ j 1)))
               (progn
                 (setq buf (string-append buf "~"))
                 (setq i (+ i 1))))))
        ((and (string= (substring text i (+ i 1)) "^")
              (< (+ i 1) n)
              (char-in-set-p (substring text (+ i 1) (+ i 2)) "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"))
         (if (> (length buf) 0)
             (progn
               (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
               (setq buf ""))
             nil)
         (setq nodes (append nodes (list (make-inline-sup pos
                                                          (list (make-inline-text pos (substring text (+ i 1) (+ i 2))))))))
         (setq i (+ i 2)))
        ((and (string= (substring text i (+ i 1)) "~")
              (< (+ i 1) n)
              (char-in-set-p (substring text (+ i 1) (+ i 2)) "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"))
         (if (> (length buf) 0)
             (progn
               (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
               (setq buf ""))
             nil)
         (setq nodes (append nodes (list (make-inline-sub pos
                                                          (list (make-inline-text pos (substring text (+ i 1) (+ i 2))))))))
         (setq i (+ i 2)))
        ((string= (substring text i (+ i 1)) ":")
         (let ((j (find-substring-from text ":" (+ i 1))))
           (if (and (not (null j)) (> j (+ i 1)))
               (let* ((name (substring text (+ i 1) j))
                      (emoji (emoji-char-or-nil name)))
                 (if (null emoji)
                     (progn
                       (setq buf (string-append buf ":"))
                       (setq i (+ i 1)))
                     (progn
                       (if (> (length buf) 0)
                           (progn
                             (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
                             (setq buf ""))
                           nil)
                       (setq nodes (append nodes (list (make-inline-text pos emoji))))
                       (setq i (+ j 1)))))
               (progn
                 (setq buf (string-append buf ":"))
                 (setq i (+ i 1))))))
        (t
         (setq buf (string-append buf (substring text i (+ i 1))))
         (setq i (+ i 1)))))
    (if (> (length buf) 0)
        (setq nodes (append nodes (emit-buffer-with-abbrev buf pos)))
        nil)
    nodes))

(defun parse-inline-until (tokens stop-kinds)
  (let ((rest tokens)
        (nodes '()))
    (while (and (not (null rest))
                (not (token-kind-in-p (first rest) stop-kinds)))
      (let ((tok (first rest)))
        (cond
         ((eq (inline-token-kind tok) 'text)
          (if (and (string= (inline-token-lexeme tok) "^")
                   (not (null (cdr rest)))
                   (eq (inline-token-kind (second rest)) 'lbrack))
              (let ((cap (capture-bracket-lexeme (cdr (cdr rest)))))
                (if (null cap)
                    (progn
                      (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
                      (setq rest (cdr rest)))
                    (progn
                      (setq nodes (append nodes (list (make-inline-note-node (first cap) (inline-token-pos tok)))))
                      (setq rest (second cap)))))
              (progn
                (let ((native-span (parse-native-span-lexeme-or-nil (inline-token-lexeme tok) (inline-token-pos tok))))
                  (if (null native-span)
                      (setq nodes (append nodes (parse-text-extensions (inline-token-lexeme tok) (inline-token-pos tok))))
                      (setq nodes (append nodes (list native-span)))))
                (setq rest (cdr rest)))))
         ((eq (inline-token-kind tok) 'backtick)
          (let ((probe (cdr rest))
                (captured '())
                (closed nil))
            (while (and (not (null probe)) (not closed))
              (if (eq (inline-token-kind (first probe)) 'backtick)
                  (setq closed t)
                  (setq captured (append captured (list (first probe)))))
              (if closed nil (setq probe (cdr probe))))
            (if closed
                (progn
                  (let* ((attrs-res (consume-inline-attrs (cdr probe)))
                         (cid (first attrs-res))
                         (cclasses (second attrs-res))
                         (cattrs (third attrs-res))
                         (tail (fourth attrs-res)))
                    (setq nodes (append nodes (list (make-inline-code (inline-token-pos tok)
                                                                       (join-inline-token-lexemes captured)
                                                                       cid
                                                                       cclasses
                                                                       cattrs))))
                    (setq rest tail)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'star)
          (let* ((parsed (parse-inline-until (cdr rest) '(star)))
                 (children (first parsed))
                 (tail (second parsed)))
            (if (and (not (null tail)) (eq (inline-token-kind (first tail)) 'star))
                (progn
                  (setq nodes (append nodes (list (make-inline-emph (inline-token-pos tok) children))))
                  (setq rest (cdr tail)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "*"))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'dstar)
          (let* ((parsed (parse-inline-until (cdr rest) '(dstar)))
                 (children (first parsed))
                 (tail (second parsed)))
            (if (and (not (null tail)) (eq (inline-token-kind (first tail)) 'dstar))
                (progn
                  (setq nodes (append nodes (list (make-inline-strong (inline-token-pos tok) children))))
                  (setq rest (cdr tail)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "**"))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'bang)
          (if (and (not (null (cdr rest))) (eq (inline-token-kind (second rest)) 'lbrack))
              (let* ((parsed-alt (parse-inline-until (cdr (cdr rest)) '(rbrack)))
                     (alt-nodes (first parsed-alt))
                     (tail-after-label (second parsed-alt))
                     (tail-res (parse-link-tail tail-after-label)))
                (if (first tail-res)
                    (progn
                      (setq nodes (append nodes (list (make-inline-image (inline-token-pos tok) alt-nodes (second tail-res)))))
                      (setq rest (third tail-res)))
                    (progn
                      (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "!"))))
                      (setq rest (cdr rest)))))
              (progn
                (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "!"))))
                (setq rest (cdr rest)))))
         ((eq (inline-token-kind tok) 'lbrack)
          (let ((res (parse-lbrack-token tok rest nodes)))
            (setq nodes (first res))
            (setq rest (second res))))
         (t
          (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
          (setq rest (cdr rest))))))
    (list nodes rest)))

(defun parse-inline (text pos)
  (let* ((tokens (lex-inline text pos))
         (parsed (parse-inline-until tokens '())))
    (first parsed)))

(defun flush-para-state (blocks para-lines para-pos)
  (if (null para-lines)
      (list blocks para-lines para-pos)
      (list (append blocks (list (make-block-paragraph para-pos (parse-inline (join-lines-newline para-lines) para-pos))))
            '()
            '())))

(defun parse-list-block (rest first-info)
  (let ((indent (first first-info))
        (kind (second first-info))
        (ltype (third first-info))
        (start (fourth first-info))
        (items '())
        (r rest)
        (pos (line-token-pos (first rest)))
        (done nil))
    (while (and (not done)
                (not (null r))
                (eq (line-token-kind (first r)) 'paragraph))
      (let* ((line (line-token-text (first r)))
             (info (parse-list-marker-line line)))
        (if (and (not (null info)) (list-compatible-p info kind ltype indent))
            (let ((item-lines (list (fifth info)))
                  (task-state 'none)
                  (q (cdr r))
                  (item-pos (line-token-pos (first r)))
                  (item-done nil))
              (while (and (not item-done) (not (null q)))
                (let ((t (first q)))
                  (cond
                   ((eq (line-token-kind t) 'blank)
                    (setq item-lines (append item-lines (list "")))
                    (setq q (cdr q)))
                   ((eq (line-token-kind t) 'quote)
                    (setq item-lines (append item-lines (list (string-append "> " (line-token-text t)))))
                    (setq q (cdr q)))
                   ((eq (line-token-kind t) 'paragraph)
                    (let* ((l2 (line-token-text t))
                           (i2 (parse-list-marker-line l2))
                           (lead2 (count-leading-ws l2)))
                      (if (and (not (null i2)) (= (first i2) indent) (list-compatible-p i2 kind ltype indent))
                          (setq item-done t)
                          (if (< lead2 (+ indent 2))
                              (setq item-done t)
                              (progn
                                (setq item-lines (append item-lines (list (strip-item-indent l2 indent))))
                                (setq q (cdr q)))))))
                   (t
                    (setq item-done t)))))
              (let* ((task (parse-task-prefix (first item-lines)))
                     (state (first task))
                     (head (second task))
                     (rest-lines (cdr item-lines))
                     (normalized (cons head rest-lines))
                     (blocks (parse-markdown (join-lines-newline normalized))))
                (setq task-state state)
                (setq items (append items (list (make-list-item item-pos blocks task-state)))))
              (setq r q))
            (setq done t))))
    (list (make-block-list pos kind ltype start items)
          r)))

(defun parse-definition-block (rest term-lines term-pos)
  (let ((defs '())
        (r rest)
        (done nil))
    (while (and (not done)
                (not (null r))
                (eq (line-token-kind (first r)) 'paragraph)
                (not (null (definition-line-content (line-token-text (first r))))))
      (let ((def-lines (list (definition-line-content (line-token-text (first r)))))
            (q (cdr r))
            (def-done nil))
        (while (and (not def-done) (not (null q)))
          (let ((t (first q)))
            (cond
             ((eq (line-token-kind t) 'blank)
              (setq def-lines (append def-lines (list "")))
              (setq q (cdr q)))
             ((eq (line-token-kind t) 'paragraph)
              (if (not (null (definition-line-content (line-token-text t))))
                  (setq def-done t)
                  (progn
                    (setq def-lines (append def-lines (list (strip-item-indent (line-token-text t) 0))))
                    (setq q (cdr q)))))
             ((eq (line-token-kind t) 'quote)
              (setq def-lines (append def-lines (list (string-append "> " (line-token-text t)))))
              (setq q (cdr q)))
             (t
              (setq def-done t)))))
        (setq defs (append defs (list (parse-markdown (join-lines-newline def-lines)))))
        (setq r q)))
    (list (make-block-deflist term-pos
                              (list (make-def-item term-pos
                                                   (parse-inline (join-lines-space term-lines) term-pos)
                                                   defs)))
          r)))

(defun parse-fenced-code-block (rest fence-info)
  (let ((lines '())
        (q (cdr rest))
        (done nil)
        (pos (line-token-pos (first rest))))
    (while (and (not done) (not (null q)))
      (let ((tok (first q)))
        (if (and (eq (line-token-kind tok) 'paragraph)
                 (fence-end-p (line-token-text tok) fence-info))
            (progn
              (setq done t)
              (setq q (cdr q)))
            (progn
              (setq lines (append lines (list (line-token-text tok))))
              (setq q (cdr q))))))
    (list (make-block-code pos
                           (join-lines-newline lines)
                           (fourth fence-info)
                           (fifth fence-info)
                           (sixth fence-info))
          q)))

(defun parse-indented-code-block (rest)
  (let ((lines '())
        (q rest)
        (done nil)
        (pos (line-token-pos (first rest))))
    (while (and (not done) (not (null q)))
      (let ((tok (first q)))
        (cond
         ((eq (line-token-kind tok) 'blank)
          (setq lines (append lines (list "")))
          (setq q (cdr q)))
         ((and (eq (line-token-kind tok) 'paragraph)
               (>= (count-leading-ws (line-token-text tok)) 4))
          (setq lines (append lines (list (strip-prefix-count (line-token-text tok) 4))))
          (setq q (cdr q)))
         (t
          (setq done t)))))
    (list (make-block-code pos (join-lines-newline lines) '() '() '()) q)))

(defun parse-line-block (rest)
  (let ((lines '())
        (q rest)
        (pos (line-token-pos (first rest)))
        (done nil))
    (while (and (not done) (not (null q)))
      (let ((tok (first q)))
        (if (eq (line-token-kind tok) 'paragraph)
            (let ((content (line-block-content-or-nil (line-token-text tok))))
              (if (null content)
                  (setq done t)
                  (progn
                    (setq lines (append lines (list content)))
                    (setq q (cdr q)))))
            (setq done t))))
    (list (make-block-line-block pos lines) q)))

(defun parse-fenced-div-start-or-nil (line)
  (let* ((t (trim-line line))
         (n (length t)))
    (if (and (>= n 3) (string= (substring t 0 3) ":::"))
        (let* ((tail (trim-line (substring t 3 n)))
               (parsed (if (> (length tail) 0)
                           (parse-leading-braced-attrs tail)
                           (list '() '() '() ""))))
          (if (null parsed)
              (list '() '() '())
              (list (first parsed) (second parsed) (third parsed))))
        '())))

(defun fenced-div-end-p (line)
  (let ((t (trim-line line)))
    (and (>= (length t) 3)
         (string= (substring t 0 3) ":::"))))

(defun parse-fenced-div-block (rest div-meta)
  (let ((q (cdr rest))
        (lines '())
        (done nil)
        (pos (line-token-pos (first rest))))
    (while (and (not done) (not (null q)))
      (let ((tok (first q)))
        (if (and (eq (line-token-kind tok) 'paragraph)
                 (fenced-div-end-p (line-token-text tok)))
            (progn
              (setq done t)
              (setq q (cdr q)))
            (progn
              (setq lines (append lines (list (line-token-text tok))))
              (setq q (cdr q))))))
    (list (make-block-div pos
                          (parse-markdown (join-lines-newline lines))
                          (first div-meta)
                          (second div-meta)
                          (third div-meta))
          q)))

(defun parse-native-div-start-or-nil (line)
  (let* ((t (trim-line line))
         (n (length t)))
    (if (and (>= n 5)
             (string= (substring t 0 4) "<div")
             (not (null (string-index ">" t))))
        (let* ((gt (string-index ">" t))
               (inside (trim-line (substring t 4 gt)))
               (tokens (split-ws inside))
               (id '())
               (classes '())
               (attrs '()))
          (dolist (tk tokens)
            (let ((eqp (string-index "=" tk)))
              (if (not (null eqp))
                  (let ((k (substring tk 0 eqp))
                        (v (substring tk (+ eqp 1) (length tk))))
                    (if (and (>= (length v) 2)
                             (or (and (string= (substring v 0 1) "\"")
                                      (string= (substring v (- (length v) 1) (length v)) "\""))
                                 (and (string= (substring v 0 1) "'")
                                      (string= (substring v (- (length v) 1) (length v)) "'"))))
                        (setq v (substring v 1 (- (length v) 1)))
                        nil)
                    (if (string= k "id")
                        (setq id v)
                        (if (string= k "class")
                            (setq classes (split-ws v))
                            (setq attrs (append attrs (list (list k v)))))))
                  nil)))
          (list id classes attrs))
        '())))

(defun native-div-end-p (line)
  (not (null (string-index "</div>" (trim-line line)))))

(defun parse-native-div-block (rest div-meta)
  (let ((q (cdr rest))
        (lines '())
        (done nil)
        (pos (line-token-pos (first rest))))
    (while (and (not done) (not (null q)))
      (let ((tok (first q)))
        (if (and (eq (line-token-kind tok) 'paragraph)
                 (native-div-end-p (line-token-text tok)))
            (progn
              (setq done t)
              (setq q (cdr q)))
            (progn
              (setq lines (append lines (list (line-token-text tok))))
              (setq q (cdr q))))))
    (list (make-block-div pos
                          (parse-markdown (join-lines-newline lines))
                          (first div-meta)
                          (second div-meta)
                          (third div-meta))
          q)))

(defun line-trim-starts-with (line prefix)
  (starts-with (trim-line line) prefix))

(defun line-trim-ends-with (line suffix)
  (let* ((t (trim-line line))
         (n (length t))
         (m (length suffix)))
    (and (>= n m)
         (string= (substring t (- n m) n) suffix))))

(defun parse-block-math-dollar (rest)
  (if (or (null rest)
          (not (eq (line-token-kind (first rest)) 'paragraph))
          (not (line-trim-starts-with (line-token-text (first rest)) "$$")))
      '()
      (let ((q rest)
            (lines '())
            (pos (line-token-pos (first rest)))
            (done nil))
        (while (and (not done) (not (null q)))
          (let ((line (line-token-text (first q))))
            (if (and (line-trim-ends-with line "$$")
                     (not (null lines)))
                (progn
                  (setq lines (append lines (list line)))
                  (setq q (cdr q))
                  (setq done t))
                (progn
                  (setq lines (append lines (list line)))
                  (setq q (cdr q))))))
        (let ((body (join-lines-newline lines)))
          (setq body (replace-all-local body "$$" ""))
          (list (make-block-math pos (apply-latex-macros (trim-line body))) q)))))

(defun parse-block-math-bracket (rest open close)
  (if (or (null rest)
          (not (eq (line-token-kind (first rest)) 'paragraph))
          (not (line-trim-starts-with (line-token-text (first rest)) open)))
      '()
      (let ((q rest)
            (lines '())
            (pos (line-token-pos (first rest)))
            (done nil))
        (while (and (not done) (not (null q)))
          (let ((line (line-token-text (first q))))
            (setq lines (append lines (list line)))
            (setq q (cdr q))
            (if (line-trim-ends-with line close)
                (setq done t)
                nil)))
        (let ((body (join-lines-newline lines)))
          (setq body (replace-all-local body open ""))
          (setq body (replace-all-local body close ""))
          (list (make-block-math pos (apply-latex-macros (trim-line body))) q)))))

(defun parse-block-raw-html (rest)
  (if (or (null rest)
          (not (eq (line-token-kind (first rest)) 'paragraph)))
      '()
      (let ((first-line (trim-line (line-token-text (first rest)))))
        (if (or (starts-with first-line "<")
                (starts-with first-line "</"))
            (if (or (starts-with first-line "<span")
                    (starts-with first-line "</span"))
                '()
                (let ((q rest)
                      (lines '()))
                  (while (and (not (null q)) (eq (line-token-kind (first q)) 'paragraph))
                    (setq lines (append lines (list (line-token-text (first q)))))
                    (setq q (cdr q)))
                  (list (make-block-raw (line-token-pos (first rest)) 'html (join-lines-newline lines)) q)))
            '()))))

(defun parse-block-raw-tex (rest)
  (if (or (null rest)
          (not (eq (line-token-kind (first rest)) 'paragraph)))
      '()
      (let ((first-line (trim-line (line-token-text (first rest)))))
        (if (or (starts-with first-line "\\begin{")
                (starts-with first-line "\\"))
            (let ((q rest)
                  (lines '())
                  (done nil))
              (while (and (not done) (not (null q)))
                (let ((line (line-token-text (first q))))
                  (setq lines (append lines (list line)))
                  (setq q (cdr q))
                  (if (starts-with (trim-line line) "\\end{")
                      (setq done t)
                      (if (not (starts-with first-line "\\begin{"))
                          (setq done t)
                          nil))))
              (list (make-block-raw (line-token-pos (first rest)) 'tex (join-lines-newline lines)) q))
            '()))))

(defun parse-table-tail (rest caption id classes attrs)
  (let ((q rest)
        (cap caption)
        (tid id)
        (tclasses classes)
        (tattrs attrs)
        (done nil))
    (while (and (not done) (not (null q)) (eq (line-token-kind (first q)) 'paragraph))
      (let* ((line (line-token-text (first q)))
             (cap2 (table-caption-or-nil line))
             (a2 (table-attrs-line-or-nil line)))
        (if (and (not (null cap2)) (null cap))
            (progn
              (setq cap cap2)
              (setq q (cdr q)))
            (if (not (null a2))
                (progn
                  (setq tid (first a2))
                  (setq tclasses (second a2))
                  (setq tattrs (third a2))
                  (setq q (cdr q)))
                (setq done t)))))
    (list cap tid tclasses tattrs q)))

(defun parse-pipe-table-block (rest)
  (if (or (null rest)
          (null (cdr rest))
          (not (eq (line-token-kind (first rest)) 'paragraph))
          (not (eq (line-token-kind (second rest)) 'paragraph)))
      '()
      (let* ((hline (line-token-text (first rest)))
             (aline (line-token-text (second rest)))
             (headers (parse-pipe-cells hline))
             (aligns0 (parse-pipe-aligns-or-nil aline)))
        (if (or (= (length headers) 0)
                (null aligns0)
                (not (= (length headers) (length aligns0))))
            '()
            (let ((q (cdr (cdr rest)))
                  (rows '())
                  (ncols (length headers))
                  (done nil))
              (while (and (not done) (not (null q)) (eq (line-token-kind (first q)) 'paragraph))
                (let* ((line (line-token-text (first q)))
                       (cells (parse-pipe-cells line)))
                  (if (or (= (length cells) 0)
                          (not (null (parse-pipe-aligns-or-nil line)))
                          (not (null (table-caption-or-nil line)))
                          (not (null (table-attrs-line-or-nil line))))
                      (if (and (> (length rows) 0)
                               (>= (count-leading-ws line) 2)
                               (= (length cells) 1))
                          (progn
                            (setq rows (append-last-cell-in-rows rows (trim-line line)))
                            (setq q (cdr q)))
                          (setq done t))
                      (progn
                        (setq rows (append rows (list (normalize-row-cells cells ncols))))
                        (setq q (cdr q))))))
              (let* ((tail (parse-table-tail q '() '() '() '()))
                     (cap (first tail))
                     (tid (second tail))
                     (tclasses (third tail))
                     (tattrs (fourth tail))
                     (q2 (fifth tail)))
                (list (make-block-table (line-token-pos (first rest))
                                        headers aligns0 rows cap tid tclasses tattrs)
                      q2)))))))

(defun parse-simple-table-block (rest)
  (if (or (null rest)
          (null (cdr rest))
          (not (eq (line-token-kind (first rest)) 'paragraph))
          (not (eq (line-token-kind (second rest)) 'paragraph)))
      '()
      (let* ((hline (trim-line (line-token-text (first rest))))
             (aline (trim-line (line-token-text (second rest))))
             (headers (split-by-double-space hline))
             (aligns0 (simple-sep-line-aligns-or-nil aline)))
        (if (or (= (length headers) 0)
                (null aligns0)
                (not (= (length headers) (length aligns0))))
            '()
            (let ((q (cdr (cdr rest)))
                  (rows '())
                  (ncols (length headers))
                  (done nil))
              (while (and (not done) (not (null q)))
                (let ((tok (first q)))
                  (cond
                   ((eq (line-token-kind tok) 'blank)
                    (setq done t))
                   ((eq (line-token-kind tok) 'paragraph)
                    (let* ((line (line-token-text tok))
                           (cap2 (table-caption-or-nil line))
                           (a2 (table-attrs-line-or-nil line))
                           (cells (split-by-double-space (trim-line line))))
                      (if (or (not (null cap2))
                              (not (null a2))
                              (not (= (length cells) ncols)))
                          (if (and (> (length rows) 0)
                                   (>= (count-leading-ws line) 2)
                                   (= (length cells) 1))
                              (progn
                                (setq rows (append-last-cell-in-rows rows (trim-line line)))
                                (setq q (cdr q)))
                              (setq done t))
                          (progn
                            (setq rows (append rows (list cells)))
                            (setq q (cdr q))))))
                   (t
                    (setq done t)))))
              (let* ((tail (parse-table-tail q '() '() '() '()))
                     (cap (first tail))
                     (tid (second tail))
                     (tclasses (third tail))
                     (tattrs (fourth tail))
                     (q2 (fifth tail)))
                (list (make-block-table (line-token-pos (first rest))
                                        headers aligns0 rows cap tid tclasses tattrs)
                      q2)))))))

(defun parse-grid-table-block (rest)
  (if (or (null rest)
          (not (eq (line-token-kind (first rest)) 'paragraph)))
      '()
      (let ((b0 (grid-border-info-or-nil (line-token-text (first rest)))))
        (if (null b0)
            '()
            (let ((widths (first b0))
                  (q (cdr rest))
                  (rows '())
                  (headers '())
                  (aligns '())
                  (header-mode t)
                  (done nil))
              (while (and (not done) (not (null q)))
                (let ((tok (first q)))
                  (if (not (eq (line-token-kind tok) 'paragraph))
                      (setq done t)
                      (let* ((line (line-token-text tok))
                             (b (grid-border-info-or-nil line))
                             (cells (grid-row-cells-or-nil line widths)))
                        (if (not (null b))
                            (progn
                              (if (string= (second b) "=")
                                  (progn
                                    (if (> (length rows) 0)
                                        (progn
                                          (setq headers (first rows))
                                          (setq rows (cdr rows)))
                                        nil)
                                    (setq header-mode nil))
                                  nil)
                              (setq q (cdr q)))
                            (if (null cells)
                                (setq done t)
                                (progn
                                  (setq rows (append rows (list cells)))
                                  (setq q (cdr q)))))))))
              (if (= (length headers) 0)
                  (if (> (length rows) 0)
                      (progn
                        (setq headers (first rows))
                        (setq rows (cdr rows)))
                      nil)
                  nil)
              (while (< (length aligns) (length headers))
                (setq aligns (append aligns (list '()))))
              (if (= (length headers) 0)
                  '()
                  (let* ((tail (parse-table-tail q '() '() '() '()))
                         (cap (first tail))
                         (tid (second tail))
                         (tclasses (third tail))
                         (tattrs (fourth tail))
                         (q2 (fifth tail)))
                    (list (make-block-table (line-token-pos (first rest))
                                            headers aligns rows cap tid tclasses tattrs)
                          q2))))))))

(defun parse-any-table-block (rest)
  (let ((g (parse-grid-table-block rest)))
    (if (null g)
        (let ((p (parse-pipe-table-block rest)))
          (if (null p)
              (parse-simple-table-block rest)
              p))
        g)))

(defun parse-blocks (line-tokens)
  (let ((rest line-tokens)
        (blocks '())
        (para-lines '())
        (para-pos '())
        (prev-blank t)
        (at-start t))
    (while (not (null rest))
      (let ((tok (first rest)))
        (cond
         ((eq (line-token-kind tok) 'blank)
          (let ((state (flush-para-state blocks para-lines para-pos)))
            (setq blocks (first state))
            (setq para-lines (second state))
            (setq para-pos (third state)))
          (setq rest (cdr rest))
          (setq prev-blank t))
         ((eq (line-token-kind tok) 'heading)
          (if (or prev-blank at-start)
              (progn
                (let ((state (flush-para-state blocks para-lines para-pos)))
                  (setq blocks (first state))
                  (setq para-lines (second state))
                  (setq para-pos (third state)))
                (let* ((meta (heading-meta (line-token-text tok)))
                       (htext (first meta))
                       (hid (second meta))
                       (hclasses (third meta))
                       (hattrs (fourth meta)))
                  (setq blocks (append blocks (list (make-block-heading
                                                     (line-token-pos tok)
                                                     (line-token-detail tok)
                                                     (parse-inline htext (line-token-pos tok))
                                                     hid
                                                     hclasses
                                                     hattrs)))))
                (setq rest (cdr rest)))
              (progn
                (if (null para-pos) (setq para-pos (line-token-pos tok)) nil)
                (setq para-lines (append para-lines
                                         (list (string-append (repeat-string "#" (line-token-detail tok))
                                                              " "
                                                              (line-token-text tok)))))
                (setq rest (cdr rest))))
          (setq prev-blank nil)
          (setq at-start nil))
         ((eq (line-token-kind tok) 'quote)
          (if (and (literate-haskell-enabled-p) (or prev-blank at-start))
              (let ((state (flush-para-state blocks para-lines para-pos))
                    (qrest rest)
                    (clines '())
                    (cpos (line-token-pos tok)))
                (setq blocks (first state))
                (setq para-lines (second state))
                (setq para-pos (third state))
                (while (and (not (null qrest)) (eq (line-token-kind (first qrest)) 'quote))
                  (setq clines (append clines (list (line-token-text (first qrest)))))
                  (setq qrest (cdr qrest)))
                (setq blocks (append blocks (list (make-block-code cpos (join-lines-newline clines) '() '() '()))))
                (setq rest qrest))
              (if (or prev-blank at-start)
                  (let ((state (flush-para-state blocks para-lines para-pos))
                        (qrest rest)
                        (qlines '())
                        (qpos (line-token-pos tok)))
                    (setq blocks (first state))
                    (setq para-lines (second state))
                    (setq para-pos (third state))
                    (while (and (not (null qrest)) (eq (line-token-kind (first qrest)) 'quote))
                      (setq qlines (append qlines (list (line-token-text (first qrest)))))
                      (setq qrest (cdr qrest)))
                    (setq blocks (append blocks (list (make-block-blockquote qpos (parse-markdown (join-lines-newline qlines))))))
                    (setq rest qrest))
                  (progn
                    (if (null para-pos) (setq para-pos (line-token-pos tok)) nil)
                    (setq para-lines (append para-lines (list (string-append "> " (line-token-text tok)))))
                    (setq rest (cdr rest)))))
          (setq prev-blank nil)
          (setq at-start nil))
         (t
          (let* ((line (line-token-text tok))
                 (list-info (parse-list-marker-line line))
                 (def-content (definition-line-content line))
                 (lvl (setext-level line))
                 (fence-info (if (eq (line-token-kind tok) 'paragraph)
                                 (parse-fence-start line)
                                 '()))
                 (fenced-div-meta (if (eq (line-token-kind tok) 'paragraph)
                                      (parse-fenced-div-start-or-nil line)
                                      '()))
                 (native-div-meta (if (eq (line-token-kind tok) 'paragraph)
                                      (parse-native-div-start-or-nil line)
                                      '()))
                 (math-dollar (if (eq (line-token-kind tok) 'paragraph)
                                  (parse-block-math-dollar rest)
                                  '()))
                 (math-bracket1 (if (eq (line-token-kind tok) 'paragraph)
                                    (parse-block-math-bracket rest "\\[" "\\]")
                                    '()))
                 (math-bracket2 (if (eq (line-token-kind tok) 'paragraph)
                                    (parse-block-math-bracket rest "\\\\[" "\\\\]")
                                    '()))
                 (raw-html (if (eq (line-token-kind tok) 'paragraph)
                               (parse-block-raw-html rest)
                               '()))
                 (raw-tex (if (eq (line-token-kind tok) 'paragraph)
                              (parse-block-raw-tex rest)
                              '()))
                 (line-block-content (if (eq (line-token-kind tok) 'paragraph)
                                         (line-block-content-or-nil line)
                                         '()))
                 (handled nil))
            (if (and (not handled) (not (null lvl)) (not (null para-lines)))
                (progn
                  (let* ((meta (heading-meta (join-lines-space para-lines)))
                         (htext (first meta))
                         (hid (second meta))
                         (hclasses (third meta))
                         (hattrs (fourth meta)))
                    (setq blocks (append blocks (list (make-block-heading para-pos
                                                                           lvl
                                                                           (parse-inline htext para-pos)
                                                                           hid
                                                                           hclasses
                                                                           hattrs)))))
                  (setq para-lines '())
                  (setq para-pos '())
                  (setq rest (cdr rest))
                  (setq handled t))
                nil)
            (if (and (not handled) (not (null def-content)) (not (null para-lines)))
                (let ((parsed-def (parse-definition-block rest para-lines para-pos)))
                  (setq blocks (append blocks (list (first parsed-def))))
                  (setq rest (second parsed-def))
                  (setq para-lines '())
                  (setq para-pos '())
                  (setq handled t))
                nil)
            (if (and (not handled) (null para-lines) (not (null fence-info)))
                (let ((parsed-fence (parse-fenced-code-block rest fence-info)))
                  (setq blocks (append blocks (list (first parsed-fence))))
                  (setq rest (second parsed-fence))
                  (setq handled t))
                nil)
            (if (and (not handled) (null para-lines) (not (null fenced-div-meta)))
                (let ((parsed-div (parse-fenced-div-block rest fenced-div-meta)))
                  (setq blocks (append blocks (list (first parsed-div))))
                  (setq rest (second parsed-div))
                  (setq handled t))
                nil)
            (if (and (not handled) (null para-lines) (not (null native-div-meta)))
                (let ((parsed-div (parse-native-div-block rest native-div-meta)))
                  (setq blocks (append blocks (list (first parsed-div))))
                  (setq rest (second parsed-div))
                  (setq handled t))
                nil)
            (if (and (not handled) (null para-lines) (not (null math-dollar)))
                (progn
                  (setq blocks (append blocks (list (first math-dollar))))
                  (setq rest (second math-dollar))
                  (setq handled t))
                nil)
            (if (and (not handled) (null para-lines) (not (null math-bracket1)))
                (progn
                  (setq blocks (append blocks (list (first math-bracket1))))
                  (setq rest (second math-bracket1))
                  (setq handled t))
                nil)
            (if (and (not handled) (null para-lines) (not (null math-bracket2)))
                (progn
                  (setq blocks (append blocks (list (first math-bracket2))))
                  (setq rest (second math-bracket2))
                  (setq handled t))
                nil)
            (if (and (not handled) (null para-lines) (not (null raw-html)))
                (progn
                  (setq blocks (append blocks (list (first raw-html))))
                  (setq rest (second raw-html))
                  (setq handled t))
                nil)
            (if (and (not handled) (null para-lines) (not (null raw-tex)))
                (progn
                  (setq blocks (append blocks (list (first raw-tex))))
                  (setq rest (second raw-tex))
                  (setq handled t))
                nil)
            (if (and (not handled)
                     (null para-lines)
                     (eq (line-token-kind tok) 'paragraph)
                     (>= (count-leading-ws line) 4))
                (let ((parsed-indent (parse-indented-code-block rest)))
                  (setq blocks (append blocks (list (first parsed-indent))))
                  (setq rest (second parsed-indent))
                  (setq handled t))
                nil)
            (if (and (not handled) (null para-lines))
                (let ((parsed-table (parse-any-table-block rest)))
                  (if (null parsed-table)
                      nil
                      (progn
                        (setq blocks (append blocks (list (first parsed-table))))
                        (setq rest (second parsed-table))
                        (setq handled t))))
                nil)
            (if (and (not handled) (null para-lines) (not (null line-block-content)))
                (let ((parsed-line-block (parse-line-block rest)))
                  (setq blocks (append blocks (list (first parsed-line-block))))
                  (setq rest (second parsed-line-block))
                  (setq handled t))
                nil)
            (if (and (not handled) (not (null list-info)))
                (let ((state (flush-para-state blocks para-lines para-pos)))
                  (setq blocks (first state))
                  (setq para-lines (second state))
                  (setq para-pos (third state))
                  (let ((parsed-list (parse-list-block rest list-info)))
                    (setq blocks (append blocks (list (first parsed-list))))
                    (setq rest (second parsed-list)))
                  (setq handled t))
                nil)
            (if (and (not handled) (thematic-break-p line) (null para-lines))
                (progn
                  (setq blocks (append blocks (list (make-block-hr (line-token-pos tok)))))
                  (setq rest (cdr rest))
                  (setq handled t))
                nil)
            (if (not handled)
                (progn
                  (if (null para-pos) (setq para-pos (line-token-pos tok)) nil)
                  (setq para-lines (append para-lines (list line)))
                  (setq rest (cdr rest)))
                nil)
            (setq prev-blank nil)
            (setq at-start nil))))))
    (let ((state (flush-para-state blocks para-lines para-pos)))
      (setq blocks (first state))
      (setq para-lines (second state))
      (setq para-pos (third state)))
    blocks))

(defun parse-markdown (text)
  (let ((old-refs *md-link-refs*)
        (old-abbrs *md-abbrevs*)
        (old-macros *md-latex-macros*)
        (old-meta *md-metadata*)
        (old-foot-defs *md-footnote-defs*)
        (old-foot-used *md-footnotes-used*)
        (old-inline-note-counter *md-inline-note-counter*)
        (old-citations *md-citations-used*)
        (old-depth *md-parse-depth*)
        (pre ""))
    (setq *md-parse-depth* (+ *md-parse-depth* 1))
    (setq pre (preprocess-markdown text))
    (setq *md-link-refs* (append *md-link-refs* old-refs))
    (setq *md-abbrevs* (append *md-abbrevs* old-abbrs))
    (setq *md-latex-macros* (append *md-latex-macros* old-macros))
    (setq *md-footnote-defs* (append *md-footnote-defs* old-foot-defs))
    (let ((out (parse-blocks (lex-lines pre))))
      (if (= *md-parse-depth* 1)
          (progn
            (let ((meta-html (build-metadata-html))
                  (foot-html (build-footnotes-html)))
              (if (> (length meta-html) 0)
                  (setq out (append (list (make-block-raw (md-pos 1 1 0) 'html meta-html)) out))
                  nil)
              (if (> (length foot-html) 0)
                  (setq out (append out (list (make-block-raw (md-pos 1 1 0) 'html foot-html))))
                  nil)))
          nil)
      (setq *md-link-refs* old-refs)
      (setq *md-abbrevs* old-abbrs)
      (setq *md-latex-macros* old-macros)
      (setq *md-metadata* old-meta)
      (setq *md-footnote-defs* old-foot-defs)
      (setq *md-footnotes-used* old-foot-used)
      (setq *md-inline-note-counter* old-inline-note-counter)
      (setq *md-citations-used* old-citations)
      (setq *md-parse-depth* old-depth)
      out)))
