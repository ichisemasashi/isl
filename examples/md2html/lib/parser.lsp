(defun token-kind-in-p (token kinds)
  (let ((k (inline-token-kind token))
        (rest kinds)
        (ok nil))
    (while (and (not ok) (not (null rest)))
      (if (eq k (first rest))
          (setq ok t)
          nil)
      (setq rest (cdr rest)))
    ok))

(defun join-inline-token-lexemes (tokens)
  (let ((rest tokens)
        (out ""))
    (while (not (null rest))
      (setq out (string-append out (inline-token-lexeme (first rest))))
      (setq rest (cdr rest)))
    out))

(defun join-lines-space (lines)
  (let ((rest lines)
        (out ""))
    (while (not (null rest))
      (setq out (if (= (length out) 0)
                    (first rest)
                    (string-append out " " (first rest))))
      (setq rest (cdr rest)))
    out))

(defun join-lines-newline (lines)
  (let ((rest lines)
        (out ""))
    (while (not (null rest))
      (setq out (if (= (length out) 0)
                    (first rest)
                    (string-append out "\n" (first rest))))
      (setq rest (cdr rest)))
    out))

(defun trim-line (line)
  (let ((n (length line))
        (s 0)
        (e (- (length line) 1)))
    (while (and (< s n) (not (null (string-index (substring line s (+ s 1)) " \t\r"))))
      (setq s (+ s 1)))
    (while (and (>= e s) (not (null (string-index (substring line e (+ e 1)) " \t\r"))))
      (setq e (- e 1)))
    (if (> s e) "" (substring line s (+ e 1)))))

(defun count-char-and-check-others (line mark)
  (let ((i 0)
        (n (length line))
        (cnt 0)
        (ok t))
    (while (and ok (< i n))
      (let ((ch (substring line i (+ i 1))))
        (if (or (string= ch " ") (string= ch "\t"))
            nil
            (if (string= ch mark)
                (setq cnt (+ cnt 1))
                (setq ok nil))))
      (setq i (+ i 1)))
    (if ok cnt -1)))

(defun thematic-break-p (line)
  (let ((trimmed (trim-line line)))
    (if (= (length trimmed) 0)
        nil
        (or (>= (count-char-and-check-others line "*") 3)
            (>= (count-char-and-check-others line "_") 3)
            (>= (count-char-and-check-others line "-") 3)))))

(defun setext-level (line)
  (let ((trimmed (trim-line line)))
    (if (= (length trimmed) 0)
        '()
        (if (>= (count-char-and-check-others line "=") 1)
            1
            (if (>= (count-char-and-check-others line "-") 1)
                2
                '())))))

(defun skip-leading-ws (line)
  (let ((i 0)
        (n (length line)))
    (while (and (< i n) (not (null (string-index (substring line i (+ i 1)) " \t"))))
      (setq i (+ i 1)))
    i))

(defun all-digit-p (s)
  (let ((i 0)
        (n (length s))
        (ok (> (length s) 0)))
    (while (and ok (< i n))
      (if (null (string-index (substring s i (+ i 1)) "0123456789"))
          (setq ok nil)
          nil)
      (setq i (+ i 1)))
    ok))

(defun decimal-string->int (s)
  (let ((i 0)
        (n (length s))
        (v 0))
    (while (< i n)
      (let ((d (string-index (substring s i (+ i 1)) "0123456789")))
        (if (null d)
            (md-fail "E_PARSE" "invalid decimal integer" (md-pos 1 1 0) s)
            (setq v (+ (* v 10) d))))
      (setq i (+ i 1)))
    v))

(defun all-alpha-p (s)
  (let ((i 0)
        (n (length s))
        (ok (> (length s) 0)))
    (while (and ok (< i n))
      (if (null (string-index (substring s i (+ i 1)) "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))
          (setq ok nil)
          nil)
      (setq i (+ i 1)))
    ok))

(defun all-roman-p (s)
  (let ((i 0)
        (n (length s))
        (ok (> (length s) 0)))
    (while (and ok (< i n))
      (if (null (string-index (substring s i (+ i 1)) "ivxlcdmIVXLCDM"))
          (setq ok nil)
          nil)
      (setq i (+ i 1)))
    ok))

(defun roman-char-value (ch)
  (cond
   ((or (string= ch "i") (string= ch "I")) 1)
   ((or (string= ch "v") (string= ch "V")) 5)
   ((or (string= ch "x") (string= ch "X")) 10)
   ((or (string= ch "l") (string= ch "L")) 50)
   ((or (string= ch "c") (string= ch "C")) 100)
   ((or (string= ch "d") (string= ch "D")) 500)
   ((or (string= ch "m") (string= ch "M")) 1000)
   (t 0)))

(defun roman->int (s)
  (let ((i 0)
        (n (length s))
        (total 0))
    (while (< i n)
      (let ((v1 (roman-char-value (substring s i (+ i 1)))))
        (if (< (+ i 1) n)
            (let ((v2 (roman-char-value (substring s (+ i 1) (+ i 2)))))
              (if (< v1 v2)
                  (progn
                    (setq total (+ total (- v2 v1)))
                    (setq i (+ i 2)))
                  (progn
                    (setq total (+ total v1))
                    (setq i (+ i 1)))))
            (progn
              (setq total (+ total v1))
              (setq i (+ i 1))))))
    total))

(defun alpha-start-number (ch)
  (+ 1 (string-index ch "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")))

;; return:
;;   (kind list-type start content)
;; kind: 'ul | 'ol | 'example
;; list-type: "1" | "a" | "A" | "i" | "I"
(defun parse-list-marker-line (line)
  (let* ((n (length line))
         (i (skip-leading-ws line)))
    (if (>= i n)
        '()
        (let ((ch (substring line i (+ i 1))))
          (if (or (string= ch "-") (string= ch "+") (string= ch "*"))
              (if (and (< (+ i 1) n) (string= (substring line (+ i 1) (+ i 2)) " "))
                  (list 'ul "" 1 (substring line (+ i 2) n))
                  '())
              (if (and (string= ch "(") (< (+ i 2) n) (string= (substring line (+ i 1) (+ i 2)) "@"))
                  (let ((j (+ i 2)))
                    (while (and (< j n) (not (string= (substring line j (+ j 1)) ")")))
                      (setq j (+ j 1)))
                    (if (and (< j n) (< (+ j 1) n) (string= (substring line (+ j 1) (+ j 2)) " "))
                        (list 'example "1" 1 (substring line (+ j 2) n))
                        '()))
                  (let ((j i))
                    (while (and (< j n)
                                (null (string-index (substring line j (+ j 1)) ".) \t")))
                      (setq j (+ j 1)))
                    (if (or (= j i) (>= j n))
                        '()
                        (let ((token (substring line i j))
                              (delim (substring line j (+ j 1))))
                          (if (or (not (or (string= delim ".") (string= delim ")")))
                                  (>= (+ j 1) n)
                                  (not (string= (substring line (+ j 1) (+ j 2)) " ")))
                              '()
                              (if (all-digit-p token)
                                  (list 'ol "1" (decimal-string->int token) (substring line (+ j 2) n))
                                  (if (all-roman-p token)
                                      (if (null (string-index (substring token 0 1) "ivxlcdm"))
                                          (list 'ol "I" (roman->int token) (substring line (+ j 2) n))
                                          (list 'ol "i" (roman->int token) (substring line (+ j 2) n)))
                                      (if (and (= (length token) 1) (all-alpha-p token))
                                          (if (null (string-index token "abcdefghijklmnopqrstuvwxyz"))
                                              (list 'ol "A" (alpha-start-number token) (substring line (+ j 2) n))
                                              (list 'ol "a" (+ 1 (string-index token "abcdefghijklmnopqrstuvwxyz")) (substring line (+ j 2) n)))
                                          '())))))))))))))

(defun list-compatible-p (info kind list-type)
  (and (eq (first info) kind)
       (if (eq kind 'ol)
           (string= (second info) list-type)
           t)))

(defun parse-task-prefix (text)
  (if (and (>= (length text) 4)
           (string= (substring text 0 1) "[")
           (string= (substring text 2 3) "]")
           (string= (substring text 3 4) " "))
      (let ((mark (substring text 1 2)))
        (if (string= mark " ")
            (list 'unchecked (substring text 4))
            (if (or (string= mark "x") (string= mark "X"))
                (list 'checked (substring text 4))
                (list 'none text))))
      (list 'none text)))

(defun definition-line-content (line)
  (let* ((n (length line))
         (i (skip-leading-ws line)))
    (if (or (>= i n) (not (string= (substring line i (+ i 1)) ":")))
        '()
        (let ((j (+ i 1)))
          (if (and (< j n) (string= (substring line j (+ j 1)) " "))
              (setq j (+ j 1))
              nil)
          (substring line j n)))))

(defun parse-link-tail (tail-after-label)
  (if (and (not (null tail-after-label))
           (eq (inline-token-kind (first tail-after-label)) 'rbrack)
           (not (null (cdr tail-after-label)))
           (eq (inline-token-kind (second tail-after-label)) 'lparen))
      (let ((p (cdr (cdr tail-after-label)))
            (url-tokens '())
            (closed nil))
        (while (and (not (null p)) (not closed))
          (if (eq (inline-token-kind (first p)) 'rparen)
              (setq closed t)
              (setq url-tokens (append url-tokens (list (first p)))))
          (if closed nil (setq p (cdr p))))
        (if closed
            (list t (join-inline-token-lexemes url-tokens) (cdr p))
            (list nil "" tail-after-label)))
      (list nil "" tail-after-label)))

(defun parse-inline-until (tokens stop-kinds)
  (let ((rest tokens)
        (nodes '()))
    (while (and (not (null rest))
                (not (token-kind-in-p (first rest) stop-kinds)))
      (let ((tok (first rest)))
        (cond
         ((eq (inline-token-kind tok) 'text)
          (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
          (setq rest (cdr rest)))
         ((eq (inline-token-kind tok) 'backtick)
          (let ((probe (cdr rest))
                (captured '())
                (closed nil))
            (while (and (not (null probe)) (not closed))
              (if (eq (inline-token-kind (first probe)) 'backtick)
                  (setq closed t)
                  (setq captured (append captured (list (first probe)))))
              (if closed nil (setq probe (cdr probe))))
            (if closed
                (progn
                  (setq nodes (append nodes (list (make-inline-code (inline-token-pos tok) (join-inline-token-lexemes captured)))))
                  (setq rest (cdr probe)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'star)
          (let* ((parsed (parse-inline-until (cdr rest) '(star)))
                 (children (first parsed))
                 (tail (second parsed)))
            (if (and (not (null tail)) (eq (inline-token-kind (first tail)) 'star))
                (progn
                  (setq nodes (append nodes (list (make-inline-emph (inline-token-pos tok) children))))
                  (setq rest (cdr tail)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "*"))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'dstar)
          (let* ((parsed (parse-inline-until (cdr rest) '(dstar)))
                 (children (first parsed))
                 (tail (second parsed)))
            (if (and (not (null tail)) (eq (inline-token-kind (first tail)) 'dstar))
                (progn
                  (setq nodes (append nodes (list (make-inline-strong (inline-token-pos tok) children))))
                  (setq rest (cdr tail)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "**"))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'bang)
          (if (and (not (null (cdr rest))) (eq (inline-token-kind (second rest)) 'lbrack))
              (let* ((parsed-alt (parse-inline-until (cdr (cdr rest)) '(rbrack)))
                     (alt-nodes (first parsed-alt))
                     (tail-after-label (second parsed-alt))
                     (tail-res (parse-link-tail tail-after-label)))
                (if (first tail-res)
                    (progn
                      (setq nodes (append nodes (list (make-inline-image (inline-token-pos tok) alt-nodes (second tail-res)))))
                      (setq rest (third tail-res)))
                    (progn
                      (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "!"))))
                      (setq rest (cdr rest)))))
              (progn
                (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "!"))))
                (setq rest (cdr rest)))))
         ((eq (inline-token-kind tok) 'lbrack)
          (let* ((parsed-label (parse-inline-until (cdr rest) '(rbrack)))
                 (label-nodes (first parsed-label))
                 (tail-after-label (second parsed-label))
                 (tail-res (parse-link-tail tail-after-label)))
            (if (first tail-res)
                (progn
                  (setq nodes (append nodes (list (make-inline-link (inline-token-pos tok) label-nodes (second tail-res)))))
                  (setq rest (third tail-res)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "["))))
                  (setq rest (cdr rest))))))
         (t
          (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
          (setq rest (cdr rest))))))
    (list nodes rest)))

(defun parse-inline (text pos)
  (let* ((tokens (lex-inline text pos))
         (parsed (parse-inline-until tokens '())))
    (first parsed)))

(defun flush-para-state (blocks para-lines para-pos)
  (if (null para-lines)
      (list blocks para-lines para-pos)
      (list (append blocks (list (make-block-paragraph para-pos (parse-inline (join-lines-space para-lines) para-pos))))
            '()
            '())))

(defun parse-list-block (rest first-info)
  (let ((kind (first first-info))
        (ltype (second first-info))
        (start (third first-info))
        (items '())
        (r rest)
        (pos (line-token-pos (first rest)))
        (done nil))
    (while (and (not done)
                (not (null r))
                (eq (line-token-kind (first r)) 'paragraph))
      (let* ((line (line-token-text (first r)))
             (info (parse-list-marker-line line)))
        (if (and (not (null info)) (list-compatible-p info kind ltype))
            (let* ((content (fourth info))
                   (task (parse-task-prefix content))
                   (task-state (first task))
                   (item-text (second task)))
              (setq items (append items (list (make-list-item (line-token-pos (first r))
                                                              (parse-inline item-text (line-token-pos (first r)))
                                                              task-state))))
              (setq r (cdr r)))
            (setq done t))))
    (list (make-block-list pos kind ltype start items)
          r)))

(defun parse-definition-block (rest term-lines term-pos)
  (let ((defs '())
        (r rest))
    (while (and (not (null r))
                (eq (line-token-kind (first r)) 'paragraph)
                (not (null (definition-line-content (line-token-text (first r))))))
      (setq defs (append defs (list (parse-inline (definition-line-content (line-token-text (first r)))
                                                  (line-token-pos (first r))))))
      (setq r (cdr r)))
    (list (make-block-deflist term-pos
                              (list (make-def-item term-pos
                                                   (parse-inline (join-lines-space term-lines) term-pos)
                                                   defs)))
          r)))

(defun parse-blocks (line-tokens)
  (let ((rest line-tokens)
        (blocks '())
        (para-lines '())
        (para-pos '()))
    (while (not (null rest))
      (let ((tok (first rest)))
        (cond
         ((eq (line-token-kind tok) 'blank)
          (let ((state (flush-para-state blocks para-lines para-pos)))
            (setq blocks (first state))
            (setq para-lines (second state))
            (setq para-pos (third state)))
          (setq rest (cdr rest)))
         ((eq (line-token-kind tok) 'heading)
          (let ((state (flush-para-state blocks para-lines para-pos)))
            (setq blocks (first state))
            (setq para-lines (second state))
            (setq para-pos (third state)))
          (setq blocks (append blocks (list (make-block-heading
                                             (line-token-pos tok)
                                             (line-token-detail tok)
                                             (parse-inline (line-token-text tok) (line-token-pos tok))))))
          (setq rest (cdr rest)))
         ((eq (line-token-kind tok) 'quote)
          (let ((state (flush-para-state blocks para-lines para-pos))
                (qrest rest)
                (qlines '())
                (qpos (line-token-pos tok)))
            (setq blocks (first state))
            (setq para-lines (second state))
            (setq para-pos (third state))
            (while (and (not (null qrest)) (eq (line-token-kind (first qrest)) 'quote))
              (setq qlines (append qlines (list (line-token-text (first qrest)))))
              (setq qrest (cdr qrest)))
            (setq blocks (append blocks (list (make-block-blockquote qpos (parse-markdown (join-lines-newline qlines))))))
            (setq rest qrest)))
         (t
          (let* ((line (line-token-text tok))
                 (list-info (parse-list-marker-line line))
                 (def-content (definition-line-content line))
                 (lvl (setext-level line)))
            (if (not (null list-info))
                (let ((state (flush-para-state blocks para-lines para-pos)))
                  (setq blocks (first state))
                  (setq para-lines (second state))
                  (setq para-pos (third state))
                  (let ((parsed-list (parse-list-block rest list-info)))
                    (setq blocks (append blocks (list (first parsed-list))))
                    (setq rest (second parsed-list))))
                (if (and (not (null def-content)) (not (null para-lines)))
                    (let ((parsed-def (parse-definition-block rest para-lines para-pos)))
                      (setq blocks (append blocks (list (first parsed-def))))
                      (setq rest (second parsed-def))
                      (setq para-lines '())
                      (setq para-pos '()))
                    (if (and (not (null lvl)) (not (null para-lines)))
                        (progn
                          (setq blocks (append blocks (list (make-block-heading para-pos lvl (parse-inline (join-lines-space para-lines) para-pos)))))
                          (setq para-lines '())
                          (setq para-pos '())
                          (setq rest (cdr rest)))
                        (if (and (thematic-break-p line) (null para-lines))
                            (progn
                              (setq blocks (append blocks (list (make-block-hr (line-token-pos tok)))))
                              (setq rest (cdr rest)))
                            (progn
                              (if (null para-pos) (setq para-pos (line-token-pos tok)) nil)
                              (setq para-lines (append para-lines (list line)))
                              (setq rest (cdr rest))))))))))))
    (let ((state (flush-para-state blocks para-lines para-pos)))
      (setq blocks (first state))
      (setq para-lines (second state))
      (setq para-pos (third state)))
    blocks))

(defun parse-markdown (text)
  (parse-blocks (lex-lines text)))
