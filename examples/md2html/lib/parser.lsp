(defun token-kind-in-p (token kinds)
  (let ((k (inline-token-kind token))
        (rest kinds)
        (ok nil))
    (while (and (not ok) (not (null rest)))
      (if (eq k (first rest))
          (setq ok t)
          nil)
      (setq rest (cdr rest)))
    ok))

(defun join-inline-token-lexemes (tokens)
  (let ((rest tokens)
        (out ""))
    (while (not (null rest))
      (setq out (string-append out (inline-token-lexeme (first rest))))
      (setq rest (cdr rest)))
    out))

(defun join-lines-space (lines)
  (let ((rest lines)
        (out ""))
    (while (not (null rest))
      (setq out (if (= (length out) 0)
                    (first rest)
                    (string-append out " " (first rest))))
      (setq rest (cdr rest)))
    out))

(defun join-lines-newline (lines)
  (let ((rest lines)
        (out ""))
    (while (not (null rest))
      (setq out (if (= (length out) 0)
                    (first rest)
                    (string-append out "\n" (first rest))))
      (setq rest (cdr rest)))
    out))

(defun trim-line (line)
  (let ((n (length line))
        (s 0)
        (e (- (length line) 1)))
    (while (and (< s n) (not (null (string-index (substring line s (+ s 1)) " \t\r"))))
      (setq s (+ s 1)))
    (while (and (>= e s) (not (null (string-index (substring line e (+ e 1)) " \t\r"))))
      (setq e (- e 1)))
    (if (> s e) "" (substring line s (+ e 1)))))

(defun count-char-and-check-others (line mark)
  (let ((i 0)
        (n (length line))
        (cnt 0)
        (ok t))
    (while (and ok (< i n))
      (let ((ch (substring line i (+ i 1))))
        (if (or (string= ch " ") (string= ch "\t"))
            nil
            (if (string= ch mark)
                (setq cnt (+ cnt 1))
                (setq ok nil))))
      (setq i (+ i 1)))
    (if ok cnt -1)))

(defun thematic-break-p (line)
  (let ((trimmed (trim-line line)))
    (if (= (length trimmed) 0)
        nil
        (or (>= (count-char-and-check-others line "*") 3)
            (>= (count-char-and-check-others line "_") 3)
            (>= (count-char-and-check-others line "-") 3)))))

(defun setext-level (line)
  (let ((trimmed (trim-line line)))
    (if (= (length trimmed) 0)
        '()
        (if (>= (count-char-and-check-others line "=") 1)
            1
            (if (>= (count-char-and-check-others line "-") 1)
                2
                '())))))

(defun parse-link-tail (tail-after-label)
  (if (and (not (null tail-after-label))
           (eq (inline-token-kind (first tail-after-label)) 'rbrack)
           (not (null (cdr tail-after-label)))
           (eq (inline-token-kind (second tail-after-label)) 'lparen))
      (let ((p (cdr (cdr tail-after-label)))
            (url-tokens '())
            (closed nil))
        (while (and (not (null p)) (not closed))
          (if (eq (inline-token-kind (first p)) 'rparen)
              (setq closed t)
              (setq url-tokens (append url-tokens (list (first p)))))
          (if closed nil (setq p (cdr p))))
        (if closed
            (list t (join-inline-token-lexemes url-tokens) (cdr p))
            (list nil "" tail-after-label)))
      (list nil "" tail-after-label)))

(defun parse-inline-until (tokens stop-kinds)
  (let ((rest tokens)
        (nodes '()))
    (while (and (not (null rest))
                (not (token-kind-in-p (first rest) stop-kinds)))
      (let ((tok (first rest)))
        (cond
         ((eq (inline-token-kind tok) 'text)
          (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
          (setq rest (cdr rest)))
         ((eq (inline-token-kind tok) 'backtick)
          (let ((probe (cdr rest))
                (captured '())
                (closed nil))
            (while (and (not (null probe)) (not closed))
              (if (eq (inline-token-kind (first probe)) 'backtick)
                  (setq closed t)
                  (setq captured (append captured (list (first probe)))))
              (if closed nil (setq probe (cdr probe))))
            (if closed
                (progn
                  (setq nodes (append nodes (list (make-inline-code (inline-token-pos tok) (join-inline-token-lexemes captured)))))
                  (setq rest (cdr probe)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'star)
          (let* ((parsed (parse-inline-until (cdr rest) '(star)))
                 (children (first parsed))
                 (tail (second parsed)))
            (if (and (not (null tail)) (eq (inline-token-kind (first tail)) 'star))
                (progn
                  (setq nodes (append nodes (list (make-inline-emph (inline-token-pos tok) children))))
                  (setq rest (cdr tail)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "*"))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'dstar)
          (let* ((parsed (parse-inline-until (cdr rest) '(dstar)))
                 (children (first parsed))
                 (tail (second parsed)))
            (if (and (not (null tail)) (eq (inline-token-kind (first tail)) 'dstar))
                (progn
                  (setq nodes (append nodes (list (make-inline-strong (inline-token-pos tok) children))))
                  (setq rest (cdr tail)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "**"))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'bang)
          (if (and (not (null (cdr rest))) (eq (inline-token-kind (second rest)) 'lbrack))
              (let* ((parsed-alt (parse-inline-until (cdr (cdr rest)) '(rbrack)))
                     (alt-nodes (first parsed-alt))
                     (tail-after-label (second parsed-alt))
                     (tail-res (parse-link-tail tail-after-label)))
                (if (first tail-res)
                    (progn
                      (setq nodes (append nodes (list (make-inline-image (inline-token-pos tok) alt-nodes (second tail-res)))))
                      (setq rest (third tail-res)))
                    (progn
                      (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "!"))))
                      (setq rest (cdr rest)))))
              (progn
                (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "!"))))
                (setq rest (cdr rest)))))
         ((eq (inline-token-kind tok) 'lbrack)
          (let* ((parsed-label (parse-inline-until (cdr rest) '(rbrack)))
                 (label-nodes (first parsed-label))
                 (tail-after-label (second parsed-label))
                 (tail-res (parse-link-tail tail-after-label)))
            (if (first tail-res)
                (progn
                  (setq nodes (append nodes (list (make-inline-link (inline-token-pos tok) label-nodes (second tail-res)))))
                  (setq rest (third tail-res)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "["))))
                  (setq rest (cdr rest))))))
         (t
          (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
          (setq rest (cdr rest))))))
    (list nodes rest)))

(defun parse-inline (text pos)
  (let* ((tokens (lex-inline text pos))
         (parsed (parse-inline-until tokens '())))
    (first parsed)))

(defun flush-para-state (blocks para-lines para-pos)
  (if (null para-lines)
      (list blocks para-lines para-pos)
      (list (append blocks (list (make-block-paragraph para-pos (parse-inline (join-lines-space para-lines) para-pos))))
            '()
            '())))

(defun parse-blocks (line-tokens)
  (let ((rest line-tokens)
        (blocks '())
        (para-lines '())
        (para-pos '()))
    (while (not (null rest))
      (let ((tok (first rest)))
        (cond
         ((eq (line-token-kind tok) 'blank)
          (let ((state (flush-para-state blocks para-lines para-pos)))
            (setq blocks (first state))
            (setq para-lines (second state))
            (setq para-pos (third state)))
          (setq rest (cdr rest)))
         ((eq (line-token-kind tok) 'heading)
          (let ((state (flush-para-state blocks para-lines para-pos)))
            (setq blocks (first state))
            (setq para-lines (second state))
            (setq para-pos (third state)))
          (setq blocks (append blocks (list (make-block-heading
                                             (line-token-pos tok)
                                             (line-token-detail tok)
                                             (parse-inline (line-token-text tok) (line-token-pos tok))))))
          (setq rest (cdr rest)))
         ((eq (line-token-kind tok) 'quote)
          (let ((state (flush-para-state blocks para-lines para-pos))
                (qrest rest)
                (qlines '())
                (qpos (line-token-pos tok)))
            (setq blocks (first state))
            (setq para-lines (second state))
            (setq para-pos (third state))
            (while (and (not (null qrest)) (eq (line-token-kind (first qrest)) 'quote))
              (setq qlines (append qlines (list (line-token-text (first qrest)))))
              (setq qrest (cdr qrest)))
            (setq blocks (append blocks (list (make-block-blockquote qpos (parse-markdown (join-lines-newline qlines))))))
            (setq rest qrest)))
         (t
          (let ((lvl (setext-level (line-token-text tok))))
            (if (and (not (null lvl)) (not (null para-lines)))
                (progn
                  (setq blocks (append blocks (list (make-block-heading para-pos lvl (parse-inline (join-lines-space para-lines) para-pos)))))
                  (setq para-lines '())
                  (setq para-pos '())
                  (setq rest (cdr rest)))
                (if (and (thematic-break-p (line-token-text tok)) (null para-lines))
                    (progn
                      (setq blocks (append blocks (list (make-block-hr (line-token-pos tok)))))
                      (setq rest (cdr rest)))
                    (progn
                      (if (null para-pos) (setq para-pos (line-token-pos tok)) nil)
                      (setq para-lines (append para-lines (list (line-token-text tok))))
                      (setq rest (cdr rest))))))))))
    (let ((state (flush-para-state blocks para-lines para-pos)))
      (setq blocks (first state))
      (setq para-lines (second state))
      (setq para-pos (third state)))
    blocks))

(defun parse-markdown (text)
  (parse-blocks (lex-lines text)))
