(defun token-kind-in-p (token kinds)
  (let ((k (inline-token-kind token))
        (rest kinds)
        (ok nil))
    (while (and (not ok) (not (null rest)))
      (if (eq k (first rest))
          (setq ok t)
          nil)
      (setq rest (cdr rest)))
    ok))

(defun join-inline-token-lexemes (tokens)
  (let ((rest tokens)
        (out ""))
    (while (not (null rest))
      (setq out (string-append out (inline-token-lexeme (first rest))))
      (setq rest (cdr rest)))
    out))

(defun join-lines-space (lines)
  (let ((rest lines)
        (out ""))
    (while (not (null rest))
      (setq out (if (= (length out) 0)
                    (first rest)
                    (string-append out " " (first rest))))
      (setq rest (cdr rest)))
    out))

(defun join-lines-newline (lines)
  (let ((rest lines)
        (out ""))
    (while (not (null rest))
      (setq out (if (= (length out) 0)
                    (first rest)
                    (string-append out "\n" (first rest))))
      (setq rest (cdr rest)))
    out))

(defun trim-line (line)
  (let ((n (length line))
        (s 0)
        (e (- (length line) 1)))
    (while (and (< s n) (not (null (string-index (substring line s (+ s 1)) " \t\r"))))
      (setq s (+ s 1)))
    (while (and (>= e s) (not (null (string-index (substring line e (+ e 1)) " \t\r"))))
      (setq e (- e 1)))
    (if (> s e) "" (substring line s (+ e 1)))))

(defun count-char-and-check-others (line mark)
  (let ((i 0)
        (n (length line))
        (cnt 0)
        (ok t))
    (while (and ok (< i n))
      (let ((ch (substring line i (+ i 1))))
        (if (or (string= ch " ") (string= ch "\t"))
            nil
            (if (string= ch mark)
                (setq cnt (+ cnt 1))
                (setq ok nil))))
      (setq i (+ i 1)))
    (if ok cnt -1)))

(defun thematic-break-p (line)
  (let ((trimmed (trim-line line)))
    (if (= (length trimmed) 0)
        nil
        (or (>= (count-char-and-check-others line "*") 3)
            (>= (count-char-and-check-others line "_") 3)
            (>= (count-char-and-check-others line "-") 3)))))

(defun setext-level (line)
  (let ((trimmed (trim-line line)))
    (if (= (length trimmed) 0)
        '()
        (if (>= (count-char-and-check-others line "=") 1)
            1
            (if (>= (count-char-and-check-others line "-") 1)
                2
                '())))))

(defun skip-leading-ws (line)
  (let ((i 0)
        (n (length line)))
    (while (and (< i n) (not (null (string-index (substring line i (+ i 1)) " \t"))))
      (setq i (+ i 1)))
    i))

(defun count-leading-ws (line)
  (skip-leading-ws line))

(defun strip-prefix-count (line count)
  (if (<= count 0)
      line
      (if (>= count (length line))
          ""
          (substring line count (length line)))))

(defun strip-item-indent (line base-indent)
  (let ((lead (count-leading-ws line)))
    (if (>= lead (+ base-indent 2))
        (strip-prefix-count line (+ base-indent 2))
        (if (>= lead base-indent)
            (strip-prefix-count line base-indent)
            line))))

(defun all-digit-p (s)
  (let* ((i 0)
         (n (length s))
         (ok (> n 0)))
    (while (and ok (< i n))
      (if (null (string-index (substring s i (+ i 1)) "0123456789"))
          (setq ok nil)
          nil)
      (setq i (+ i 1)))
    ok))

(defun decimal-string->int (s)
  (let ((i 0)
        (n (length s))
        (v 0))
    (while (< i n)
      (let ((d (string-index (substring s i (+ i 1)) "0123456789")))
        (if (null d)
            (md-fail "E_PARSE" "invalid decimal integer" (md-pos 1 1 0) s)
            (setq v (+ (* v 10) d))))
      (setq i (+ i 1)))
    v))

(defun all-alpha-p (s)
  (let* ((i 0)
         (n (length s))
         (ok (> n 0)))
    (while (and ok (< i n))
      (if (null (string-index (substring s i (+ i 1)) "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"))
          (setq ok nil)
          nil)
      (setq i (+ i 1)))
    ok))

(defun all-roman-p (s)
  (let* ((i 0)
         (n (length s))
         (ok (> n 0)))
    (while (and ok (< i n))
      (if (null (string-index (substring s i (+ i 1)) "ivxlcdmIVXLCDM"))
          (setq ok nil)
          nil)
      (setq i (+ i 1)))
    ok))

(defun roman-char-value (ch)
  (cond
   ((or (string= ch "i") (string= ch "I")) 1)
   ((or (string= ch "v") (string= ch "V")) 5)
   ((or (string= ch "x") (string= ch "X")) 10)
   ((or (string= ch "l") (string= ch "L")) 50)
   ((or (string= ch "c") (string= ch "C")) 100)
   ((or (string= ch "d") (string= ch "D")) 500)
   ((or (string= ch "m") (string= ch "M")) 1000)
   (t 0)))

(defun roman->int (s)
  (let ((i 0)
        (n (length s))
        (total 0))
    (while (< i n)
      (let ((v1 (roman-char-value (substring s i (+ i 1)))))
        (if (< (+ i 1) n)
            (let ((v2 (roman-char-value (substring s (+ i 1) (+ i 2)))))
              (if (< v1 v2)
                  (progn
                    (setq total (+ total (- v2 v1)))
                    (setq i (+ i 2)))
                  (progn
                    (setq total (+ total v1))
                    (setq i (+ i 1)))))
            (progn
              (setq total (+ total v1))
              (setq i (+ i 1))))))
    total))

(defun alpha-start-number (ch)
  (+ 1 (string-index ch "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ")))

;; return:
;;   (indent kind list-type start content)
;; kind: 'ul | 'ol | 'example
;; list-type: "1" | "a" | "A" | "i" | "I"
(defun parse-ordered-marker (token content indent)
  (if (all-digit-p token)
      (list indent 'ol "1" (decimal-string->int token) content)
      (if (all-roman-p token)
          (if (null (string-index (substring token 0 1) "ivxlcdm"))
              (list indent 'ol "I" (roman->int token) content)
              (list indent 'ol "i" (roman->int token) content))
          (if (and (= (length token) 1) (all-alpha-p token))
              (if (null (string-index token "abcdefghijklmnopqrstuvwxyz"))
                  (list indent 'ol "A" (alpha-start-number token) content)
                  (list indent 'ol "a" (+ 1 (string-index token "abcdefghijklmnopqrstuvwxyz")) content))
              '()))))

(defun parse-list-marker-line (line)
  (let* ((indent (skip-leading-ws line))
         (line-len (length line)))
    (if (>= indent line-len)
        '()
        (let* ((rest (substring line indent line-len))
               (m (length rest)))
          (if (and (>= m 2)
                   (or (string= (substring rest 0 1) "-")
                       (string= (substring rest 0 1) "+")
                       (string= (substring rest 0 1) "*"))
                   (string= (substring rest 1 2) " "))
              (list indent 'ul "" 1 (substring rest 2 m))
              (if (and (>= m 4)
                       (string= (substring rest 0 1) "(")
                       (string= (substring rest 1 2) "@"))
                  (let ((j 2))
                    (while (and (< j m) (not (string= (substring rest j (+ j 1)) ")")))
                      (setq j (+ j 1)))
                    (if (and (< j m)
                             (< (+ j 1) m)
                             (string= (substring rest (+ j 1) (+ j 2)) " "))
                        (list indent 'example "1" 1 (substring rest (+ j 2) m))
                        '()))
                  (let ((sp (string-index " " rest)))
                    (if (null sp)
                        '()
                        (let* ((marker (substring rest 0 sp))
                               (k (length marker)))
                          (if (< k 2)
                              '()
                              (let* ((delim (substring marker (- k 1) k))
                                     (token (substring marker 0 (- k 1)))
                                     (content (substring rest (+ sp 1) m)))
                                (if (or (string= delim ".")
                                        (string= delim ")"))
                                    (parse-ordered-marker token content indent)
                                    '()))))))))))))

(defun list-compatible-p (info kind list-type indent)
  (and (= (first info) indent)
       (eq (second info) kind)
       (if (eq kind 'ol)
           (string= (third info) list-type)
           t)))

(defun parse-task-prefix (text)
  (if (and (>= (length text) 4)
           (string= (substring text 0 1) "[")
           (string= (substring text 2 3) "]")
           (string= (substring text 3 4) " "))
      (let ((mark (substring text 1 2)))
        (if (string= mark " ")
            (list 'unchecked (substring text 4))
            (if (or (string= mark "x") (string= mark "X"))
                (list 'checked (substring text 4))
                (list 'none text))))
      (list 'none text)))

(defun definition-line-content (line)
  (let* ((n (length line))
         (i (skip-leading-ws line)))
    (if (or (>= i n) (not (string= (substring line i (+ i 1)) ":")))
        '()
        (let ((j (+ i 1)))
          (if (and (< j n) (string= (substring line j (+ j 1)) " "))
              (setq j (+ j 1))
              nil)
          (substring line j n)))))

(defun all-space-tab-p (s)
  (let ((i 0)
        (n (length s))
        (ok t))
    (while (and ok (< i n))
      (if (null (string-index (substring s i (+ i 1)) " \t\r"))
          (setq ok nil)
          nil)
      (setq i (+ i 1)))
    ok))

(defun repeat-string (piece count)
  (let ((i 0)
        (out ""))
    (while (< i count)
      (setq out (string-append out piece))
      (setq i (+ i 1)))
    out))

(defun split-ws (s)
  (let ((i 0)
        (n (length s))
        (cur "")
        (out '()))
    (while (< i n)
      (let ((ch (substring s i (+ i 1))))
        (if (null (string-index ch " \t\r"))
            (setq cur (string-append cur ch))
            (if (> (length cur) 0)
                (progn
                  (setq out (append out (list cur)))
                  (setq cur ""))
                nil)))
      (setq i (+ i 1)))
    (if (> (length cur) 0) (setq out (append out (list cur))) nil)
    out))

(defun last-index-of-char (s ch)
  (let ((i (- (length s) 1))
        (found '()))
    (while (and (null found) (>= i 0))
      (if (string= (substring s i (+ i 1)) ch)
          (setq found i)
          nil)
      (setq i (- i 1)))
    found))

(defun parse-attrs-body (body)
  (let ((tokens (split-ws body))
        (id '())
        (classes '())
        (attrs '()))
    (dolist (tk tokens)
      (if (and (> (length tk) 1) (string= (substring tk 0 1) "#"))
          (setq id (substring tk 1 (length tk)))
          (if (and (> (length tk) 1) (string= (substring tk 0 1) "."))
              (setq classes (append classes (list (substring tk 1 (length tk)))))
              (let ((eqp (string-index "=" tk)))
                (if (not (null eqp))
                    (setq attrs
                          (append attrs
                                  (list (list (substring tk 0 eqp)
                                              (substring tk (+ eqp 1) (length tk))))))
                    nil)))))
    (list id classes attrs)))

(defun parse-fence-info (info)
  (let* ((trimmed (trim-line info))
         (id '())
         (classes '())
         (attrs '())
         (lang ""))
    (if (> (length trimmed) 0)
        (let ((lbrace (string-index "{" trimmed))
              (rbrace (last-index-of-char trimmed "}")))
          (if (and (not (null lbrace))
                   (not (null rbrace))
                   (< lbrace rbrace)
                   (= rbrace (- (length trimmed) 1)))
              (let* ((before (trim-line (substring trimmed 0 lbrace)))
                     (body (substring trimmed (+ lbrace 1) rbrace))
                     (parsed (parse-attrs-body body)))
                (setq id (first parsed))
                (setq classes (second parsed))
                (setq attrs (third parsed))
                (if (> (length before) 0)
                    (setq lang (first (split-ws before)))
                    nil))
              (setq lang (first (split-ws trimmed)))))
        nil)
    (if (> (length lang) 0)
        (setq classes (append (list (string-append "language-" lang)) classes))
        nil)
    (list id classes attrs)))

(defun parse-fence-start (line)
  (let* ((indent (skip-leading-ws line))
         (n (length line)))
    (if (>= indent n)
        '()
        (let* ((rest (substring line indent n))
               (m (length rest))
               (ch (substring rest 0 1)))
          (if (or (string= ch "`") (string= ch "~"))
              (let ((i 0))
                (while (and (< i m) (string= (substring rest i (+ i 1)) ch))
                  (setq i (+ i 1)))
                (if (>= i 3)
                    (let* ((info (trim-line (substring rest i m)))
                           (parsed (parse-fence-info info)))
                      (list indent ch i
                            (first parsed)
                            (second parsed)
                            (third parsed)))
                    '()))
              '())))))

(defun fence-end-p (line fence-info)
  (let* ((indent (skip-leading-ws line))
         (n (length line))
         (ch (second fence-info))
         (need (third fence-info)))
    (if (>= indent n)
        nil
        (let* ((rest (substring line indent n))
               (m (length rest))
               (i 0))
          (while (and (< i m) (string= (substring rest i (+ i 1)) ch))
            (setq i (+ i 1)))
          (and (>= i need)
               (all-space-tab-p (substring rest i m)))))))

(defun line-block-content-or-nil (line)
  (let* ((n (length line))
         (i (skip-leading-ws line)))
    (if (and (< i n) (string= (substring line i (+ i 1)) "|"))
        (let ((j (+ i 1)))
          (if (and (< j n) (string= (substring line j (+ j 1)) " "))
              (setq j (+ j 1))
              nil)
          (substring line j n))
        '())))

(defun split-by-char (s sep)
  (let ((i 0)
        (n (length s))
        (start 0)
        (out '()))
    (while (< i n)
      (if (string= (substring s i (+ i 1)) sep)
          (progn
            (setq out (append out (list (substring s start i))))
            (setq start (+ i 1)))
          nil)
      (setq i (+ i 1)))
    (setq out (append out (list (substring s start n))))
    out))

(defun take-first-n (xs n)
  (let ((r xs)
        (i 0)
        (out '()))
    (while (and (< i n) (not (null r)))
      (setq out (append out (list (first r))))
      (setq r (cdr r))
      (setq i (+ i 1)))
    out))

(defun normalize-row-cells (cells width)
  (let ((n (length cells)))
    (if (= n width)
        cells
        (if (> n width)
            (take-first-n cells width)
            (let ((out cells))
              (while (< (length out) width)
                (setq out (append out (list ""))))
              out)))))

(defun append-last-cell-in-row (cells text)
  (if (null cells)
      cells
      (if (null (cdr cells))
          (list (string-append (first cells) "\n" text))
          (cons (first cells)
                (append-last-cell-in-row (cdr cells) text)))))

(defun append-last-cell-in-rows (rows text)
  (if (null rows)
      rows
      (if (null (cdr rows))
          (list (append-last-cell-in-row (first rows) text))
          (cons (first rows)
                (append-last-cell-in-rows (cdr rows) text)))))

(defun parse-pipe-cells (line)
  (let* ((tline (trim-line line))
         (n (length tline))
         (body (if (and (> n 0) (string= (substring tline 0 1) "|"))
                   (substring tline 1 n)
                   tline))
         (m (length body))
         (body2 (if (and (> m 0) (string= (substring body (- m 1) m) "|"))
                    (substring body 0 (- m 1))
                    body))
         (cells (split-by-char body2 "|"))
         (out '()))
    (dolist (c cells)
      (setq out (append out (list (trim-line c)))))
    out))

(defun pipe-sep-cell-align (cell)
  (let* ((t (trim-line cell))
         (n (length t)))
    (if (= n 0)
        '()
        (let ((i 0)
              (ok t)
              (left (string= (substring t 0 1) ":"))
              (right (string= (substring t (- n 1) n) ":")))
          (while (and ok (< i n))
            (let ((ch (substring t i (+ i 1))))
              (if (or (string= ch "-") (string= ch ":"))
                  nil
                  (setq ok nil)))
            (setq i (+ i 1)))
          (if (or (not ok) (< n 3))
              '()
              (if (and left right)
                  "center"
                  (if left
                      "left"
                      (if right "right" '()))))))))

(defun parse-pipe-aligns-or-nil (line)
  (let ((cells (parse-pipe-cells line))
        (out '())
        (ok t))
    (if (= (length cells) 0)
        '()
        (progn
          (dolist (c cells)
            (let ((a (pipe-sep-cell-align c)))
              (if (and (null a)
                       (< (length (trim-line c)) 3))
                  (setq ok nil)
                  nil)
              (if (and ok (null a))
                  (let ((i 0)
                        (t (trim-line c))
                        (only-dash t))
                    (while (and only-dash (< i (length t)))
                      (if (string= (substring t i (+ i 1)) "-")
                          nil
                          (setq only-dash nil))
                      (setq i (+ i 1)))
                    (if only-dash
                        (setq out (append out (list '())))
                        (setq ok nil)))
                  (if ok (setq out (append out (list a))) nil))))
          (if ok out '())))))

(defun table-caption-or-nil (line)
  (let ((t (trim-line line)))
    (if (and (>= (length t) 6) (string= (substring t 0 6) "Table:"))
        (trim-line (substring t 6 (length t)))
        '())))

(defun table-attrs-line-or-nil (line)
  (let* ((t (trim-line line))
         (n (length t)))
    (if (and (>= n 2)
             (string= (substring t 0 1) "{")
             (string= (substring t (- n 1) n) "}"))
        (parse-attrs-body (substring t 1 (- n 1)))
        '())))

(defun split-by-double-space (s)
  (let ((i 0)
        (n (length s))
        (start 0)
        (gap 0)
        (out '()))
    (while (< i n)
      (if (string= (substring s i (+ i 1)) " ")
          (setq gap (+ gap 1))
          (setq gap 0))
      (if (and (>= gap 2)
               (> i start)
               (not (string= (substring s (- i 1) i) " ")))
          nil
          nil)
      (if (and (>= gap 2)
               (> (- (+ i 1) gap) start))
          (progn
            (setq out (append out (list (trim-line (substring s start (- (+ i 1) gap))))))
            (setq start (+ i 1))
            (setq gap 0))
          nil)
      (setq i (+ i 1)))
    (setq out (append out (list (trim-line (substring s start n)))))
    out))

(defun simple-sep-line-aligns-or-nil (line)
  (let ((cells (split-by-double-space (trim-line line)))
        (out '())
        (ok t))
    (if (= (length cells) 0)
        '()
        (progn
          (dolist (c cells)
            (let ((a (pipe-sep-cell-align c)))
              (if (null a)
                  (let ((t (trim-line c)))
                    (if (>= (length t) 3)
                        (let ((i 0)
                              (good t))
                          (while (and good (< i (length t)))
                            (if (string= (substring t i (+ i 1)) "-")
                                nil
                                (setq good nil))
                            (setq i (+ i 1)))
                          (if good
                              (setq a '())
                              (setq ok nil)))
                        (setq ok nil)))
                  nil)
              (if ok (setq out (append out (list a))) nil)))
          (if ok out '())))))

(defun grid-border-info-or-nil (line)
  (let ((t (trim-line line))
        (widths '())
        (kind "-"))
    (if (or (< (length t) 3)
            (not (string= (substring t 0 1) "+"))
            (not (string= (substring t (- (length t) 1) (length t)) "+")))
        '()
        (let ((parts (split-by-char (substring t 1 (- (length t) 1)) "+"))
              (ok t))
          (dolist (p parts)
            (let ((tp (trim-line p)))
              (if (= (length tp) 0)
                  (setq ok nil)
                  (let ((i 0)
                        (k (substring tp 0 1)))
                    (if (or (string= k "-") (string= k "="))
                        (progn
                          (while (and ok (< i (length tp)))
                            (if (string= (substring tp i (+ i 1)) k)
                                nil
                                (setq ok nil))
                            (setq i (+ i 1)))
                          (setq widths (append widths (list (length tp))))
                          (if (string= k "=") (setq kind "=") nil))
                        (setq ok nil))))))
          (if ok (list widths kind) '())))))

(defun grid-row-cells-or-nil (line widths)
  (let ((t line)
        (cells '())
        (ok t)
        (ws widths)
        (p 0))
    (if (or (< (length t) 2)
            (not (string= (substring t 0 1) "|")))
        '()
        (progn
          (setq p 1)
          (while (and ok (not (null ws)))
            (let ((w (first ws)))
              (if (> (+ p w) (length t))
                  (setq ok nil)
                  (progn
                    (setq cells (append cells (list (trim-line (substring t p (+ p w))))))
                    (setq p (+ p w))
                    (if (or (>= p (length t)) (not (string= (substring t p (+ p 1)) "|")))
                        (setq ok nil)
                        (setq p (+ p 1))))))
            (setq ws (cdr ws)))
          (if ok cells '())))))

(defun parse-link-tail (tail-after-label)
  (if (and (not (null tail-after-label))
           (eq (inline-token-kind (first tail-after-label)) 'rbrack)
           (not (null (cdr tail-after-label)))
           (eq (inline-token-kind (second tail-after-label)) 'lparen))
      (let ((p (cdr (cdr tail-after-label)))
            (url-tokens '())
            (closed nil))
        (while (and (not (null p)) (not closed))
          (if (eq (inline-token-kind (first p)) 'rparen)
              (setq closed t)
              (setq url-tokens (append url-tokens (list (first p)))))
          (if closed nil (setq p (cdr p))))
        (if closed
            (list t (join-inline-token-lexemes url-tokens) (cdr p))
            (list nil "" tail-after-label)))
      (list nil "" tail-after-label)))

(defun parse-inline-until (tokens stop-kinds)
  (let ((rest tokens)
        (nodes '()))
    (while (and (not (null rest))
                (not (token-kind-in-p (first rest) stop-kinds)))
      (let ((tok (first rest)))
        (cond
         ((eq (inline-token-kind tok) 'text)
          (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
          (setq rest (cdr rest)))
         ((eq (inline-token-kind tok) 'backtick)
          (let ((probe (cdr rest))
                (captured '())
                (closed nil))
            (while (and (not (null probe)) (not closed))
              (if (eq (inline-token-kind (first probe)) 'backtick)
                  (setq closed t)
                  (setq captured (append captured (list (first probe)))))
              (if closed nil (setq probe (cdr probe))))
            (if closed
                (progn
                  (setq nodes (append nodes (list (make-inline-code (inline-token-pos tok) (join-inline-token-lexemes captured)))))
                  (setq rest (cdr probe)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'star)
          (let* ((parsed (parse-inline-until (cdr rest) '(star)))
                 (children (first parsed))
                 (tail (second parsed)))
            (if (and (not (null tail)) (eq (inline-token-kind (first tail)) 'star))
                (progn
                  (setq nodes (append nodes (list (make-inline-emph (inline-token-pos tok) children))))
                  (setq rest (cdr tail)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "*"))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'dstar)
          (let* ((parsed (parse-inline-until (cdr rest) '(dstar)))
                 (children (first parsed))
                 (tail (second parsed)))
            (if (and (not (null tail)) (eq (inline-token-kind (first tail)) 'dstar))
                (progn
                  (setq nodes (append nodes (list (make-inline-strong (inline-token-pos tok) children))))
                  (setq rest (cdr tail)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "**"))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'bang)
          (if (and (not (null (cdr rest))) (eq (inline-token-kind (second rest)) 'lbrack))
              (let* ((parsed-alt (parse-inline-until (cdr (cdr rest)) '(rbrack)))
                     (alt-nodes (first parsed-alt))
                     (tail-after-label (second parsed-alt))
                     (tail-res (parse-link-tail tail-after-label)))
                (if (first tail-res)
                    (progn
                      (setq nodes (append nodes (list (make-inline-image (inline-token-pos tok) alt-nodes (second tail-res)))))
                      (setq rest (third tail-res)))
                    (progn
                      (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "!"))))
                      (setq rest (cdr rest)))))
              (progn
                (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "!"))))
                (setq rest (cdr rest)))))
         ((eq (inline-token-kind tok) 'lbrack)
          (let* ((parsed-label (parse-inline-until (cdr rest) '(rbrack)))
                 (label-nodes (first parsed-label))
                 (tail-after-label (second parsed-label))
                 (tail-res (parse-link-tail tail-after-label)))
            (if (first tail-res)
                (progn
                  (setq nodes (append nodes (list (make-inline-link (inline-token-pos tok) label-nodes (second tail-res)))))
                  (setq rest (third tail-res)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "["))))
                  (setq rest (cdr rest))))))
         (t
          (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
          (setq rest (cdr rest))))))
    (list nodes rest)))

(defun parse-inline (text pos)
  (let* ((tokens (lex-inline text pos))
         (parsed (parse-inline-until tokens '())))
    (first parsed)))

(defun flush-para-state (blocks para-lines para-pos)
  (if (null para-lines)
      (list blocks para-lines para-pos)
      (list (append blocks (list (make-block-paragraph para-pos (parse-inline (join-lines-newline para-lines) para-pos))))
            '()
            '())))

(defun parse-list-block (rest first-info)
  (let ((indent (first first-info))
        (kind (second first-info))
        (ltype (third first-info))
        (start (fourth first-info))
        (items '())
        (r rest)
        (pos (line-token-pos (first rest)))
        (done nil))
    (while (and (not done)
                (not (null r))
                (eq (line-token-kind (first r)) 'paragraph))
      (let* ((line (line-token-text (first r)))
             (info (parse-list-marker-line line)))
        (if (and (not (null info)) (list-compatible-p info kind ltype indent))
            (let ((item-lines (list (fifth info)))
                  (task-state 'none)
                  (q (cdr r))
                  (item-pos (line-token-pos (first r)))
                  (item-done nil))
              (while (and (not item-done) (not (null q)))
                (let ((t (first q)))
                  (cond
                   ((eq (line-token-kind t) 'blank)
                    (setq item-lines (append item-lines (list "")))
                    (setq q (cdr q)))
                   ((eq (line-token-kind t) 'quote)
                    (setq item-lines (append item-lines (list (string-append "> " (line-token-text t)))))
                    (setq q (cdr q)))
                   ((eq (line-token-kind t) 'paragraph)
                    (let* ((l2 (line-token-text t))
                           (i2 (parse-list-marker-line l2))
                           (lead2 (count-leading-ws l2)))
                      (if (and (not (null i2)) (= (first i2) indent) (list-compatible-p i2 kind ltype indent))
                          (setq item-done t)
                          (if (< lead2 (+ indent 2))
                              (setq item-done t)
                              (progn
                                (setq item-lines (append item-lines (list (strip-item-indent l2 indent))))
                                (setq q (cdr q)))))))
                   (t
                    (setq item-done t)))))
              (let* ((task (parse-task-prefix (first item-lines)))
                     (state (first task))
                     (head (second task))
                     (rest-lines (cdr item-lines))
                     (normalized (cons head rest-lines))
                     (blocks (parse-markdown (join-lines-newline normalized))))
                (setq task-state state)
                (setq items (append items (list (make-list-item item-pos blocks task-state)))))
              (setq r q))
            (setq done t))))
    (list (make-block-list pos kind ltype start items)
          r)))

(defun parse-definition-block (rest term-lines term-pos)
  (let ((defs '())
        (r rest)
        (done nil))
    (while (and (not done)
                (not (null r))
                (eq (line-token-kind (first r)) 'paragraph)
                (not (null (definition-line-content (line-token-text (first r))))))
      (let ((def-lines (list (definition-line-content (line-token-text (first r)))))
            (q (cdr r))
            (def-done nil))
        (while (and (not def-done) (not (null q)))
          (let ((t (first q)))
            (cond
             ((eq (line-token-kind t) 'blank)
              (setq def-lines (append def-lines (list "")))
              (setq q (cdr q)))
             ((eq (line-token-kind t) 'paragraph)
              (if (not (null (definition-line-content (line-token-text t))))
                  (setq def-done t)
                  (progn
                    (setq def-lines (append def-lines (list (strip-item-indent (line-token-text t) 0))))
                    (setq q (cdr q)))))
             ((eq (line-token-kind t) 'quote)
              (setq def-lines (append def-lines (list (string-append "> " (line-token-text t)))))
              (setq q (cdr q)))
             (t
              (setq def-done t)))))
        (setq defs (append defs (list (parse-markdown (join-lines-newline def-lines)))))
        (setq r q)))
    (list (make-block-deflist term-pos
                              (list (make-def-item term-pos
                                                   (parse-inline (join-lines-space term-lines) term-pos)
                                                   defs)))
          r)))

(defun parse-fenced-code-block (rest fence-info)
  (let ((lines '())
        (q (cdr rest))
        (done nil)
        (pos (line-token-pos (first rest))))
    (while (and (not done) (not (null q)))
      (let ((tok (first q)))
        (if (and (eq (line-token-kind tok) 'paragraph)
                 (fence-end-p (line-token-text tok) fence-info))
            (progn
              (setq done t)
              (setq q (cdr q)))
            (progn
              (setq lines (append lines (list (line-token-text tok))))
              (setq q (cdr q))))))
    (list (make-block-code pos
                           (join-lines-newline lines)
                           (fourth fence-info)
                           (fifth fence-info)
                           (sixth fence-info))
          q)))

(defun parse-indented-code-block (rest)
  (let ((lines '())
        (q rest)
        (done nil)
        (pos (line-token-pos (first rest))))
    (while (and (not done) (not (null q)))
      (let ((tok (first q)))
        (cond
         ((eq (line-token-kind tok) 'blank)
          (setq lines (append lines (list "")))
          (setq q (cdr q)))
         ((and (eq (line-token-kind tok) 'paragraph)
               (>= (count-leading-ws (line-token-text tok)) 4))
          (setq lines (append lines (list (strip-prefix-count (line-token-text tok) 4))))
          (setq q (cdr q)))
         (t
          (setq done t)))))
    (list (make-block-code pos (join-lines-newline lines) '() '() '()) q)))

(defun parse-line-block (rest)
  (let ((lines '())
        (q rest)
        (pos (line-token-pos (first rest)))
        (done nil))
    (while (and (not done) (not (null q)))
      (let ((tok (first q)))
        (if (eq (line-token-kind tok) 'paragraph)
            (let ((content (line-block-content-or-nil (line-token-text tok))))
              (if (null content)
                  (setq done t)
                  (progn
                    (setq lines (append lines (list content)))
                    (setq q (cdr q)))))
            (setq done t))))
    (list (make-block-line-block pos lines) q)))

(defun parse-table-tail (rest caption id classes attrs)
  (let ((q rest)
        (cap caption)
        (tid id)
        (tclasses classes)
        (tattrs attrs)
        (done nil))
    (while (and (not done) (not (null q)) (eq (line-token-kind (first q)) 'paragraph))
      (let* ((line (line-token-text (first q)))
             (cap2 (table-caption-or-nil line))
             (a2 (table-attrs-line-or-nil line)))
        (if (and (not (null cap2)) (null cap))
            (progn
              (setq cap cap2)
              (setq q (cdr q)))
            (if (not (null a2))
                (progn
                  (setq tid (first a2))
                  (setq tclasses (second a2))
                  (setq tattrs (third a2))
                  (setq q (cdr q)))
                (setq done t)))))
    (list cap tid tclasses tattrs q)))

(defun parse-pipe-table-block (rest)
  (if (or (null rest)
          (null (cdr rest))
          (not (eq (line-token-kind (first rest)) 'paragraph))
          (not (eq (line-token-kind (second rest)) 'paragraph)))
      '()
      (let* ((hline (line-token-text (first rest)))
             (aline (line-token-text (second rest)))
             (headers (parse-pipe-cells hline))
             (aligns0 (parse-pipe-aligns-or-nil aline)))
        (if (or (= (length headers) 0)
                (null aligns0)
                (not (= (length headers) (length aligns0))))
            '()
            (let ((q (cdr (cdr rest)))
                  (rows '())
                  (ncols (length headers))
                  (done nil))
              (while (and (not done) (not (null q)) (eq (line-token-kind (first q)) 'paragraph))
                (let* ((line (line-token-text (first q)))
                       (cells (parse-pipe-cells line)))
                  (if (or (= (length cells) 0)
                          (not (null (parse-pipe-aligns-or-nil line)))
                          (not (null (table-caption-or-nil line)))
                          (not (null (table-attrs-line-or-nil line))))
                      (if (and (> (length rows) 0)
                               (>= (count-leading-ws line) 2)
                               (= (length cells) 1))
                          (progn
                            (setq rows (append-last-cell-in-rows rows (trim-line line)))
                            (setq q (cdr q)))
                          (setq done t))
                      (progn
                        (setq rows (append rows (list (normalize-row-cells cells ncols))))
                        (setq q (cdr q))))))
              (let* ((tail (parse-table-tail q '() '() '() '()))
                     (cap (first tail))
                     (tid (second tail))
                     (tclasses (third tail))
                     (tattrs (fourth tail))
                     (q2 (fifth tail)))
                (list (make-block-table (line-token-pos (first rest))
                                        headers aligns0 rows cap tid tclasses tattrs)
                      q2)))))))

(defun parse-simple-table-block (rest)
  (if (or (null rest)
          (null (cdr rest))
          (not (eq (line-token-kind (first rest)) 'paragraph))
          (not (eq (line-token-kind (second rest)) 'paragraph)))
      '()
      (let* ((hline (trim-line (line-token-text (first rest))))
             (aline (trim-line (line-token-text (second rest))))
             (headers (split-by-double-space hline))
             (aligns0 (simple-sep-line-aligns-or-nil aline)))
        (if (or (= (length headers) 0)
                (null aligns0)
                (not (= (length headers) (length aligns0))))
            '()
            (let ((q (cdr (cdr rest)))
                  (rows '())
                  (ncols (length headers))
                  (done nil))
              (while (and (not done) (not (null q)))
                (let ((tok (first q)))
                  (cond
                   ((eq (line-token-kind tok) 'blank)
                    (setq done t))
                   ((eq (line-token-kind tok) 'paragraph)
                    (let* ((line (line-token-text tok))
                           (cap2 (table-caption-or-nil line))
                           (a2 (table-attrs-line-or-nil line))
                           (cells (split-by-double-space (trim-line line))))
                      (if (or (not (null cap2))
                              (not (null a2))
                              (not (= (length cells) ncols)))
                          (if (and (> (length rows) 0)
                                   (>= (count-leading-ws line) 2)
                                   (= (length cells) 1))
                              (progn
                                (setq rows (append-last-cell-in-rows rows (trim-line line)))
                                (setq q (cdr q)))
                              (setq done t))
                          (progn
                            (setq rows (append rows (list cells)))
                            (setq q (cdr q))))))
                   (t
                    (setq done t)))))
              (let* ((tail (parse-table-tail q '() '() '() '()))
                     (cap (first tail))
                     (tid (second tail))
                     (tclasses (third tail))
                     (tattrs (fourth tail))
                     (q2 (fifth tail)))
                (list (make-block-table (line-token-pos (first rest))
                                        headers aligns0 rows cap tid tclasses tattrs)
                      q2)))))))

(defun parse-grid-table-block (rest)
  (if (or (null rest)
          (not (eq (line-token-kind (first rest)) 'paragraph)))
      '()
      (let ((b0 (grid-border-info-or-nil (line-token-text (first rest)))))
        (if (null b0)
            '()
            (let ((widths (first b0))
                  (q (cdr rest))
                  (rows '())
                  (headers '())
                  (aligns '())
                  (header-mode t)
                  (done nil))
              (while (and (not done) (not (null q)))
                (let ((tok (first q)))
                  (if (not (eq (line-token-kind tok) 'paragraph))
                      (setq done t)
                      (let* ((line (line-token-text tok))
                             (b (grid-border-info-or-nil line))
                             (cells (grid-row-cells-or-nil line widths)))
                        (if (not (null b))
                            (progn
                              (if (string= (second b) "=")
                                  (progn
                                    (if (> (length rows) 0)
                                        (progn
                                          (setq headers (first rows))
                                          (setq rows (cdr rows)))
                                        nil)
                                    (setq header-mode nil))
                                  nil)
                              (setq q (cdr q)))
                            (if (null cells)
                                (setq done t)
                                (progn
                                  (setq rows (append rows (list cells)))
                                  (setq q (cdr q)))))))))
              (if (= (length headers) 0)
                  (if (> (length rows) 0)
                      (progn
                        (setq headers (first rows))
                        (setq rows (cdr rows)))
                      nil)
                  nil)
              (while (< (length aligns) (length headers))
                (setq aligns (append aligns (list '()))))
              (if (= (length headers) 0)
                  '()
                  (let* ((tail (parse-table-tail q '() '() '() '()))
                         (cap (first tail))
                         (tid (second tail))
                         (tclasses (third tail))
                         (tattrs (fourth tail))
                         (q2 (fifth tail)))
                    (list (make-block-table (line-token-pos (first rest))
                                            headers aligns rows cap tid tclasses tattrs)
                          q2))))))))

(defun parse-any-table-block (rest)
  (let ((g (parse-grid-table-block rest)))
    (if (null g)
        (let ((p (parse-pipe-table-block rest)))
          (if (null p)
              (parse-simple-table-block rest)
              p))
        g)))

(defun parse-blocks (line-tokens)
  (let ((rest line-tokens)
        (blocks '())
        (para-lines '())
        (para-pos '())
        (prev-blank t)
        (at-start t))
    (while (not (null rest))
      (let ((tok (first rest)))
        (cond
         ((eq (line-token-kind tok) 'blank)
          (let ((state (flush-para-state blocks para-lines para-pos)))
            (setq blocks (first state))
            (setq para-lines (second state))
            (setq para-pos (third state)))
          (setq rest (cdr rest))
          (setq prev-blank t))
         ((eq (line-token-kind tok) 'heading)
          (if (or prev-blank at-start)
              (progn
                (let ((state (flush-para-state blocks para-lines para-pos)))
                  (setq blocks (first state))
                  (setq para-lines (second state))
                  (setq para-pos (third state)))
                (setq blocks (append blocks (list (make-block-heading
                                                   (line-token-pos tok)
                                                   (line-token-detail tok)
                                                   (parse-inline (line-token-text tok) (line-token-pos tok))))))
                (setq rest (cdr rest)))
              (progn
                (if (null para-pos) (setq para-pos (line-token-pos tok)) nil)
                (setq para-lines (append para-lines
                                         (list (string-append (repeat-string "#" (line-token-detail tok))
                                                              " "
                                                              (line-token-text tok)))))
                (setq rest (cdr rest))))
          (setq prev-blank nil)
          (setq at-start nil))
         ((eq (line-token-kind tok) 'quote)
          (if (or prev-blank at-start)
              (let ((state (flush-para-state blocks para-lines para-pos))
                    (qrest rest)
                    (qlines '())
                    (qpos (line-token-pos tok)))
                (setq blocks (first state))
                (setq para-lines (second state))
                (setq para-pos (third state))
                (while (and (not (null qrest)) (eq (line-token-kind (first qrest)) 'quote))
                  (setq qlines (append qlines (list (line-token-text (first qrest)))))
                  (setq qrest (cdr qrest)))
                (setq blocks (append blocks (list (make-block-blockquote qpos (parse-markdown (join-lines-newline qlines))))))
                (setq rest qrest))
              (progn
                (if (null para-pos) (setq para-pos (line-token-pos tok)) nil)
                (setq para-lines (append para-lines (list (string-append "> " (line-token-text tok)))))
                (setq rest (cdr rest))))
          (setq prev-blank nil)
          (setq at-start nil))
         (t
          (let* ((line (line-token-text tok))
                 (list-info (parse-list-marker-line line))
                 (def-content (definition-line-content line))
                 (lvl (setext-level line))
                 (fence-info (if (eq (line-token-kind tok) 'paragraph)
                                 (parse-fence-start line)
                                 '()))
                 (line-block-content (if (eq (line-token-kind tok) 'paragraph)
                                         (line-block-content-or-nil line)
                                         '()))
                 (handled nil))
            (if (and (not handled) (not (null lvl)) (not (null para-lines)))
                (progn
                  (setq blocks (append blocks (list (make-block-heading para-pos lvl (parse-inline (join-lines-space para-lines) para-pos)))))
                  (setq para-lines '())
                  (setq para-pos '())
                  (setq rest (cdr rest))
                  (setq handled t))
                nil)
            (if (and (not handled) (not (null def-content)) (not (null para-lines)))
                (let ((parsed-def (parse-definition-block rest para-lines para-pos)))
                  (setq blocks (append blocks (list (first parsed-def))))
                  (setq rest (second parsed-def))
                  (setq para-lines '())
                  (setq para-pos '())
                  (setq handled t))
                nil)
            (if (and (not handled) (null para-lines) (not (null fence-info)))
                (let ((parsed-fence (parse-fenced-code-block rest fence-info)))
                  (setq blocks (append blocks (list (first parsed-fence))))
                  (setq rest (second parsed-fence))
                  (setq handled t))
                nil)
            (if (and (not handled)
                     (null para-lines)
                     (eq (line-token-kind tok) 'paragraph)
                     (>= (count-leading-ws line) 4))
                (let ((parsed-indent (parse-indented-code-block rest)))
                  (setq blocks (append blocks (list (first parsed-indent))))
                  (setq rest (second parsed-indent))
                  (setq handled t))
                nil)
            (if (and (not handled) (null para-lines))
                (let ((parsed-table (parse-any-table-block rest)))
                  (if (null parsed-table)
                      nil
                      (progn
                        (setq blocks (append blocks (list (first parsed-table))))
                        (setq rest (second parsed-table))
                        (setq handled t))))
                nil)
            (if (and (not handled) (null para-lines) (not (null line-block-content)))
                (let ((parsed-line-block (parse-line-block rest)))
                  (setq blocks (append blocks (list (first parsed-line-block))))
                  (setq rest (second parsed-line-block))
                  (setq handled t))
                nil)
            (if (and (not handled) (not (null list-info)))
                (let ((state (flush-para-state blocks para-lines para-pos)))
                  (setq blocks (first state))
                  (setq para-lines (second state))
                  (setq para-pos (third state))
                  (let ((parsed-list (parse-list-block rest list-info)))
                    (setq blocks (append blocks (list (first parsed-list))))
                    (setq rest (second parsed-list)))
                  (setq handled t))
                nil)
            (if (and (not handled) (thematic-break-p line) (null para-lines))
                (progn
                  (setq blocks (append blocks (list (make-block-hr (line-token-pos tok)))))
                  (setq rest (cdr rest))
                  (setq handled t))
                nil)
            (if (not handled)
                (progn
                  (if (null para-pos) (setq para-pos (line-token-pos tok)) nil)
                  (setq para-lines (append para-lines (list line)))
                  (setq rest (cdr rest)))
                nil)
            (setq prev-blank nil)
            (setq at-start nil))))))
    (let ((state (flush-para-state blocks para-lines para-pos)))
      (setq blocks (first state))
      (setq para-lines (second state))
      (setq para-pos (third state)))
    blocks))

(defun parse-markdown (text)
  (parse-blocks (lex-lines text)))
