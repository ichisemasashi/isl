(defun token-kind-in-p (token kinds)
  (let ((k (inline-token-kind token))
        (rest kinds)
        (ok nil))
    (while (and (not ok) (not (null rest)))
      (if (eq k (first rest))
          (setq ok t)
          nil)
      (setq rest (cdr rest)))
    ok))

(defun join-inline-token-lexemes (tokens)
  (let ((rest tokens)
        (out ""))
    (while (not (null rest))
      (setq out (string-append out (inline-token-lexeme (first rest))))
      (setq rest (cdr rest)))
    out))

(defun parse-inline-until (tokens stop-kinds)
  (let ((rest tokens)
        (nodes '()))
    (while (and (not (null rest))
                (not (token-kind-in-p (first rest) stop-kinds)))
      (let ((tok (first rest)))
        (cond
         ((eq (inline-token-kind tok) 'text)
          (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
          (setq rest (cdr rest)))
         ((eq (inline-token-kind tok) 'backtick)
          (let ((probe (cdr rest))
                (captured '())
                (closed nil))
            (while (and (not (null probe)) (not closed))
              (if (eq (inline-token-kind (first probe)) 'backtick)
                  (setq closed t)
                  (setq captured (append captured (list (first probe)))))
              (if closed nil (setq probe (cdr probe))))
            (if closed
                (progn
                  (setq nodes (append nodes (list (make-inline-code (inline-token-pos tok) (join-inline-token-lexemes captured)))))
                  (setq rest (cdr probe)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'star)
          (let* ((parsed (parse-inline-until (cdr rest) '(star)))
                 (children (first parsed))
                 (tail (second parsed)))
            (if (and (not (null tail)) (eq (inline-token-kind (first tail)) 'star))
                (progn
                  (setq nodes (append nodes (list (make-inline-emph (inline-token-pos tok) children))))
                  (setq rest (cdr tail)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "*"))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'dstar)
          (let* ((parsed (parse-inline-until (cdr rest) '(dstar)))
                 (children (first parsed))
                 (tail (second parsed)))
            (if (and (not (null tail)) (eq (inline-token-kind (first tail)) 'dstar))
                (progn
                  (setq nodes (append nodes (list (make-inline-strong (inline-token-pos tok) children))))
                  (setq rest (cdr tail)))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "**"))))
                  (setq rest (cdr rest))))))
         ((eq (inline-token-kind tok) 'lbrack)
          (let* ((parsed-label (parse-inline-until (cdr rest) '(rbrack)))
                 (label-nodes (first parsed-label))
                 (tail-after-label (second parsed-label)))
            (if (and (not (null tail-after-label))
                     (eq (inline-token-kind (first tail-after-label)) 'rbrack)
                     (not (null (cdr tail-after-label)))
                     (eq (inline-token-kind (second tail-after-label)) 'lparen))
                (let ((p (cdr (cdr tail-after-label)))
                      (url-tokens '())
                      (closed nil))
                  (while (and (not (null p)) (not closed))
                    (if (eq (inline-token-kind (first p)) 'rparen)
                        (setq closed t)
                        (setq url-tokens (append url-tokens (list (first p)))))
                    (if closed nil (setq p (cdr p))))
                  (if closed
                      (progn
                        (setq nodes (append nodes (list (make-inline-link (inline-token-pos tok) label-nodes (join-inline-token-lexemes url-tokens)))))
                        (setq rest (cdr p)))
                      (progn
                        (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "["))))
                        (setq rest (cdr rest)))))
                (progn
                  (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) "["))))
                  (setq rest (cdr rest))))))
         (t
          (setq nodes (append nodes (list (make-inline-text (inline-token-pos tok) (inline-token-lexeme tok)))))
          (setq rest (cdr rest))))))
    (list nodes rest)))

(defun parse-inline (text pos)
  (let* ((tokens (lex-inline text pos))
         (parsed (parse-inline-until tokens '())))
    (first parsed)))

(defun flush-para-state (blocks para-lines para-pos)
  (if (null para-lines)
      (list blocks para-lines para-pos)
      (let ((joined "")
            (xs para-lines))
        (while (not (null xs))
          (setq joined (if (= (length joined) 0)
                           (first xs)
                           (string-append joined " " (first xs))))
          (setq xs (cdr xs)))
        (list (append blocks (list (make-block-paragraph para-pos (parse-inline joined para-pos))))
              '()
              '()))))

(defun parse-blocks (line-tokens)
  (let ((rest line-tokens)
        (blocks '())
        (para-lines '())
        (para-pos '()))
    (while (not (null rest))
      (let ((tok (first rest)))
        (cond
         ((eq (line-token-kind tok) 'blank)
          (let ((state (flush-para-state blocks para-lines para-pos)))
            (setq blocks (first state))
            (setq para-lines (second state))
            (setq para-pos (third state))))
         ((eq (line-token-kind tok) 'heading)
          (let ((state (flush-para-state blocks para-lines para-pos)))
            (setq blocks (first state))
            (setq para-lines (second state))
            (setq para-pos (third state)))
          (setq blocks (append blocks (list (make-block-heading
                                             (line-token-pos tok)
                                             (line-token-detail tok)
                                             (parse-inline (line-token-text tok) (line-token-pos tok)))))))
         (t
          (if (null para-pos)
              (setq para-pos (line-token-pos tok))
              nil)
          (setq para-lines (append para-lines (list (line-token-text tok))))))
        (setq rest (cdr rest))))
    (let ((state (flush-para-state blocks para-lines para-pos)))
      (setq blocks (first state))
      (setq para-lines (second state))
      (setq para-pos (third state)))
    blocks))

(defun parse-markdown (text)
  (parse-blocks (lex-lines text)))
