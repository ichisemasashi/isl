#!/bin/sh
set -eu

usage() {
  cat 1>&2 <<'EOF'
Usage:
  webserver --config <path> [--check-config]
EOF
}

log() {
  echo "webserver: $*"
}

die() {
  echo "webserver: error: $*" 1>&2
  exit 1
}

trim() {
  # Trim leading/trailing spaces and tabs.
  echo "$1" | sed -e 's/^[[:space:]]*//' -e 's/[[:space:]]*$//'
}

normalize_dir() {
  in="$1"
  if [ ! -d "$in" ]; then
    return 1
  fi
  (cd "$in" 2>/dev/null && pwd -P) || return 1
}

normalize_file() {
  in="$1"
  if [ ! -f "$in" ]; then
    return 1
  fi
  base=$(basename "$in")
  dir=$(dirname "$in")
  abs_dir=$(normalize_dir "$dir") || return 1
  echo "$abs_dir/$base"
}

require_nonempty() {
  key="$1"
  val="$2"
  if [ -z "$val" ]; then
    die "missing required key: $key"
  fi
}

config_path=""
check_config="false"

while [ "$#" -gt 0 ]; do
  case "$1" in
    --config)
      shift
      [ "$#" -gt 0 ] || die "missing value for --config"
      config_path="$1"
      ;;
    --check-config)
      check_config="true"
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      die "unknown argument: $1"
      ;;
  esac
  shift
done

[ -n "$config_path" ] || die "--config is required"
[ -f "$config_path" ] || die "config file not found: $config_path"

listen_port=""
document_root=""
tls_cert_file=""
tls_key_file=""
cgi_enabled=""
cgi_bin_dir=""
max_connections=""

line_no=0
while IFS= read -r raw_line || [ -n "$raw_line" ]; do
  line_no=$((line_no + 1))
  # Drop comments and trim.
  line=${raw_line%%#*}
  line=$(trim "$line")
  [ -n "$line" ] || continue

  case "$line" in
    *=*)
      key=$(trim "${line%%=*}")
      val=$(trim "${line#*=}")
      ;;
    *)
      die "invalid config syntax at line $line_no: $raw_line"
      ;;
  esac

  case "$key" in
    listen_port) listen_port="$val" ;;
    document_root) document_root="$val" ;;
    tls_cert_file) tls_cert_file="$val" ;;
    tls_key_file) tls_key_file="$val" ;;
    cgi_enabled) cgi_enabled="$val" ;;
    cgi_bin_dir) cgi_bin_dir="$val" ;;
    max_connections) max_connections="$val" ;;
    *)
      die "unknown config key at line $line_no: $key"
      ;;
  esac
done < "$config_path"

require_nonempty "listen_port" "$listen_port"
require_nonempty "document_root" "$document_root"
require_nonempty "tls_cert_file" "$tls_cert_file"
require_nonempty "tls_key_file" "$tls_key_file"
require_nonempty "cgi_enabled" "$cgi_enabled"
require_nonempty "cgi_bin_dir" "$cgi_bin_dir"
require_nonempty "max_connections" "$max_connections"

case "$listen_port" in
  ''|*[!0-9]*) die "listen_port must be integer: $listen_port" ;;
esac
if [ "$listen_port" -ne 8080 ]; then
  die "listen_port must be 8080 (got: $listen_port)"
fi

case "$max_connections" in
  ''|*[!0-9]*) die "max_connections must be integer: $max_connections" ;;
esac
if [ "$max_connections" -ne 100 ]; then
  die "max_connections must be 100 (got: $max_connections)"
fi

case "$cgi_enabled" in
  true|false) ;;
  *) die "cgi_enabled must be true or false (got: $cgi_enabled)" ;;
esac

document_root_abs=$(normalize_dir "$document_root") || die "document_root must be existing directory: $document_root"
cgi_bin_dir_abs=$(normalize_dir "$cgi_bin_dir") || die "cgi_bin_dir must be existing directory: $cgi_bin_dir"
tls_cert_file_abs=$(normalize_file "$tls_cert_file") || die "tls_cert_file must be existing file: $tls_cert_file"
tls_key_file_abs=$(normalize_file "$tls_key_file") || die "tls_key_file must be existing file: $tls_key_file"

[ -r "$tls_cert_file_abs" ] || die "tls_cert_file is not readable: $tls_cert_file_abs"
[ -r "$tls_key_file_abs" ] || die "tls_key_file is not readable: $tls_key_file_abs"

log "configuration loaded"
log "listen_port=$listen_port"
log "document_root=$document_root_abs"
log "tls_cert_file=$tls_cert_file_abs"
log "tls_key_file=$tls_key_file_abs"
log "cgi_enabled=$cgi_enabled"
log "cgi_bin_dir=$cgi_bin_dir_abs"
log "max_connections=$max_connections"

if [ "$check_config" = "true" ]; then
  log "config check passed"
  exit 0
fi

die "runtime server is not implemented yet (T1 scope covers config spec/validation only). Use --check-config."
