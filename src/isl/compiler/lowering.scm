(define-module isl.compiler.lowering
  (export lower-expr-to-cfg
          lower-top-level-form
          render-ll))

(select-module isl.compiler.lowering)

;; Lower-state
;; #(lower-state next-temp next-label blocks order)
;; blocks: ((label . #(instrs term)) ...)

(define (make-state)
  (vector 'lower-state 0 0 '() '()))

(define (state-next-temp st) (vector-ref st 1))
(define (state-next-label st) (vector-ref st 2))
(define (state-blocks st) (vector-ref st 3))
(define (state-order st) (vector-ref st 4))
(define (set-state-next-temp! st v) (vector-set! st 1 v))
(define (set-state-next-label! st v) (vector-set! st 2 v))
(define (set-state-blocks! st v) (vector-set! st 3 v))
(define (set-state-order! st v) (vector-set! st 4 v))

(define (fresh-temp st)
  (let ((n (state-next-temp st)))
    (set-state-next-temp! st (+ n 1))
    (string->symbol (string-append "t" (number->string n)))))

(define (fresh-label st)
  (let ((n (state-next-label st)))
    (set-state-next-label! st (+ n 1))
    (string->symbol (string-append "bb" (number->string n)))))

(define (block-cell instrs term)
  (vector instrs term))

(define (block-instrs c) (vector-ref c 0))
(define (block-term c) (vector-ref c 1))
(define (set-block-instrs! c v) (vector-set! c 0 v))
(define (set-block-term! c v) (vector-set! c 1 v))

(define (ensure-block! st label)
  (let ((p (assq label (state-blocks st))))
    (if p
        (cdr p)
        (let ((c (block-cell '() #f)))
          (set-state-blocks! st (cons (cons label c) (state-blocks st)))
          (set-state-order! st (append (state-order st) (list label)))
          c))))

(define (emit! st label instr)
  (let* ((c (ensure-block! st label))
         (xs (block-instrs c)))
    (set-block-instrs! c (append xs (list instr)))))

(define (terminate! st label term)
  (let ((c (ensure-block! st label)))
    (set-block-term! c term)))

(define (terminated? st label)
  (let ((c (ensure-block! st label)))
    (if (block-term c) #t #f)))

(define (build-block-list st)
  (map (lambda (label)
         (let ((c (ensure-block! st label)))
           (list 'block label (block-instrs c) (block-term c))))
       (state-order st)))

;; Returns (list end-label result-temp)
(define (lower-expr expr st label)
  (unless (and (pair? expr) (symbol? (car expr)))
    (error "lower-expr expects normalized IR expression" expr))
  (case (car expr)
    ((const)
     (let ((dst (fresh-temp st)))
       (emit! st label (list 'assign dst (list 'const (cadr expr))))
       (list label dst)))
    ((var)
     (let ((dst (fresh-temp st)))
       (emit! st label (list 'assign dst (list 'var (cadr expr))))
       (list label dst)))
    ((lambda)
     (let ((dst (fresh-temp st)))
       ;; Lambda body stays in normalized form for now; codegen can outline later.
       (emit! st label (list 'assign dst (list 'lambda (cadr expr) (caddr expr))))
       (list label dst)))
    ((seq)
     (let loop ((xs (cdr expr)) (cur label) (last #f))
       (if (null? xs)
           (if last
               (list cur last)
               (let ((dst (fresh-temp st)))
                 (emit! st cur (list 'assign dst (list 'const '())))
                 (list cur dst)))
           (let* ((r (lower-expr (car xs) st cur))
                  (next-label (car r))
                  (v (cadr r)))
             (loop (cdr xs) next-label v)))))
    ((call)
     (let* ((callee-r (lower-expr (cadr expr) st label))
            (cur (car callee-r))
            (fvar (cadr callee-r)))
       (let loop ((xs (cddr expr)) (lbl cur) (acc '()))
         (if (null? xs)
             (let ((dst (fresh-temp st)))
               (emit! st lbl (list 'assign dst (list 'call fvar (reverse acc))))
               (list lbl dst))
             (let* ((r (lower-expr (car xs) st lbl))
                    (lbl2 (car r))
                    (v (cadr r)))
               (loop (cdr xs) lbl2 (cons v acc)))))))
    ((effect)
     (if (= (length expr) 2)
         (lower-expr (cadr expr) st label)
         (error "effect node expects one child" expr)))
    ((if)
     (let* ((test-r (lower-expr (cadr expr) st label))
            (after-test (car test-r))
            (test-v (cadr test-r))
            (then-label (fresh-label st))
            (else-label (fresh-label st))
            (merge-label (fresh-label st)))
       (terminate! st after-test (list 'br test-v then-label else-label))
       (let* ((then-r (lower-expr (caddr expr) st then-label))
              (then-end (car then-r))
              (then-v (cadr then-r))
              (else-r (lower-expr (cadddr expr) st else-label))
              (else-end (car else-r))
              (else-v (cadr else-r)))
         (unless (terminated? st then-end)
           (terminate! st then-end (list 'jmp merge-label)))
         (unless (terminated? st else-end)
           (terminate! st else-end (list 'jmp merge-label)))
         (let ((dst (fresh-temp st)))
           (emit! st merge-label
                  (list 'assign dst
                        (list 'phi
                              (list (list then-end then-v)
                                    (list else-end else-v)))))
           (list merge-label dst)))))
    ((special)
     (let ((dst (fresh-temp st)))
       (emit! st label (list 'assign dst (list 'special (cadr expr) (caddr expr))))
       (list label dst)))
    ((invalid-special)
     (let ((dst (fresh-temp st)))
       (emit! st label (list 'assign dst (list 'invalid-special expr)))
       (list label dst)))
    (else
     (error "Unknown normalized node" expr))))

(define (lower-expr-to-cfg expr)
  (let* ((st (make-state))
         (entry (fresh-label st))
         (r (lower-expr expr st entry))
         (end (car r))
         (retv (cadr r)))
    (unless (terminated? st end)
      (terminate! st end (list 'ret retv)))
    (list 'cfg entry (build-block-list st))))

(define (lower-top-level-form top)
  (unless (and (pair? top) (symbol? (car top)))
    (error "lower-top-level-form expects top-level normalized IR" top))
  (case (car top)
    ((define-fun)
     (list 'll-define-fun
           (cadr top)
           (caddr top)
           (lower-expr-to-cfg (cadddr top))))
    ((define-global)
     (list 'll-define-global
           (cadr top)
           (lower-expr-to-cfg (caddr top))))
    ((define-macro)
     (list 'll-define-macro (cadr top) (caddr top) (cadddr top)))
    ((expr)
     (list 'll-expr (lower-expr-to-cfg (cadr top))))
    ((invalid-top)
     (list 'll-invalid top))
    (else
     (list 'll-invalid top))))

(define (render-ll ll)
  (let ((p (open-output-string)))
    (write ll p)
    (get-output-string p)))
