(define-module isl.compiler.runtime
  (use isl.core)
  (use gauche.net)
  (use gauche.threads)
  (use rfc.tls)
  (use srfi-1)
  (export make-runtime-state
          runtime-load-units!
          runtime-eval-top
          runtime-eval-expr
          runtime-value->host
          host->runtime-value
          runtime-error?
          runtime-error-code
          runtime-error-message
          runtime-error-details))

(select-module isl.compiler.runtime)

;; Keep references to Gauche TLS procedures before defining ISL primitives.
(define gauche-make-tls make-tls)
(define gauche-tls-bind tls-bind)
(define gauche-tls-accept tls-accept)
(define gauche-tls-close tls-close)
(define gauche-tls-load-certificate tls-load-certificate)
(define gauche-tls-load-private-key tls-load-private-key)
(define gauche-connection-input-port connection-input-port)
(define gauche-connection-output-port connection-output-port)
(define gauche-connection-close connection-close)
(define gauche-make-thread make-thread)
(define gauche-thread-start! thread-start!)
(define gauche-thread-join! thread-join!)
(define gauche-thread? thread?)
(define gauche-make-mutex make-mutex)
(define gauche-mutex-lock! mutex-lock!)
(define gauche-mutex-unlock! mutex-unlock!)
(define gauche-mutex? mutex?)

;; Runtime error object shared by frontend/backend paths.
(define (make-runtime-error code message details)
  (vector 'runtime-error code message details))

(define (runtime-error? obj)
  (and (vector? obj)
       (= (vector-length obj) 4)
       (eq? (vector-ref obj 0) 'runtime-error)))

(define (runtime-error-code err) (vector-ref err 1))
(define (runtime-error-message err) (vector-ref err 2))
(define (runtime-error-details err) (vector-ref err 3))

(define (runtime-raise code message . details)
  (raise (make-runtime-error code message details)))

(define (make-nonlocal-return name value)
  (vector 'nonlocal-return name value))

(define (nonlocal-return? obj)
  (and (vector? obj)
       (= (vector-length obj) 3)
       (eq? (vector-ref obj 0) 'nonlocal-return)))

(define (nonlocal-return-name s) (vector-ref s 1))
(define (nonlocal-return-value s) (vector-ref s 2))

(define (make-throw-signal tag value)
  (vector 'throw-signal tag value))

(define (throw-signal? obj)
  (and (vector? obj)
       (= (vector-length obj) 3)
       (eq? (vector-ref obj 0) 'throw-signal)))

(define (throw-signal-tag s) (vector-ref s 1))
(define (throw-signal-value s) (vector-ref s 2))

(define (make-go-signal tag)
  (vector 'go-signal tag))

(define (go-signal? obj)
  (and (vector? obj)
       (= (vector-length obj) 2)
       (eq? (vector-ref obj 0) 'go-signal)))

(define (go-signal-tag s) (vector-ref s 1))

;; Dynamic nonlocal target stacks.
(define *runtime-catch-stack* '())

(define (runtime-catch-active? tag)
  (let loop ((xs *runtime-catch-stack*))
    (and (pair? xs)
         (or (eqv? (car xs) tag)
             (loop (cdr xs))))))

;; Tagged value representation used by compiler runtime.
(define (make-rt-value tag payload)
  (vector 'rt-value tag payload))

(define (rt-value? v)
  (and (vector? v)
       (= (vector-length v) 3)
       (eq? (vector-ref v 0) 'rt-value)))

(define (rt-tag v) (vector-ref v 1))
(define (rt-payload v) (vector-ref v 2))

(define (classify-host-value v)
  (cond
   ((number? v) 'number)
   ((string? v) 'string)
   ((char? v) 'char)
   ((boolean? v) 'boolean)
   ((null? v) 'null)
   ((symbol? v) 'symbol)
   ((pair? v) 'pair)
   ((vector? v) 'vector)
   (else 'object)))

(define (host->runtime-value v)
  (if (rt-value? v)
      v
      (make-rt-value (classify-host-value v) v)))

(define (runtime-value->host rv)
  (if (rt-value? rv)
      (rt-payload rv)
      rv))

(define (runtime-truthy? rv)
  (let ((v (runtime-value->host rv)))
    (and (not (eq? v #f))
         (not (null? v)))))

;; Lexical environment.
(define (make-env parent)
  (vector 'env parent '()))

(define (env-parent env) (vector-ref env 1))
(define (env-bindings env) (vector-ref env 2))
(define (set-env-bindings! env bindings) (vector-set! env 2 bindings))

(define (runtime-resolve-symbol sym)
  (if (symbol? sym)
      (with-module isl.core (resolve-symbol-in-package sym))
      sym))

(define (env-define! env sym val)
  (set! sym (runtime-resolve-symbol sym))
  (let ((bindings (env-bindings env)))
    (let loop ((xs bindings) (acc '()))
      (cond
       ((null? xs)
        (set-env-bindings! env (append (reverse acc) (list (cons sym val)))))
       ((eq? (caar xs) sym)
        (set-env-bindings! env (append (reverse acc) (cons (cons sym val) (cdr xs)))))
       (else
        (loop (cdr xs) (cons (car xs) acc)))))))

(define (env-find-pair env sym)
  (set! sym (runtime-resolve-symbol sym))
  (let loop ((e env))
    (if (not e)
        #f
        (let ((p (assoc sym (env-bindings e))))
          (if p p (loop (env-parent e)))))))

(define (env-ref env sym)
  (set! sym (runtime-resolve-symbol sym))
  (let ((p (env-find-pair env sym)))
    (if p
        (cdr p)
        (runtime-raise 'unbound-variable "Unbound variable" sym))))

(define (env-set! env sym val)
  (set! sym (runtime-resolve-symbol sym))
  (let loop ((e env))
    (if (not e)
        (env-define! env sym val)
        (let ((p (assoc sym (env-bindings e))))
          (if p
              (set-cdr! p val)
              (loop (env-parent e)))))))

;; Object system (M7 minimal runtime representation)
(define (make-rt-slot-spec name initform initarg readers writers)
  (vector 'rt-slot-spec name initform initarg readers writers))

(define (rt-slot-spec? x)
  (and (vector? x) (= (vector-length x) 6) (eq? (vector-ref x 0) 'rt-slot-spec)))

(define (rt-slot-name s) (vector-ref s 1))
(define (rt-slot-initform s) (vector-ref s 2))
(define (rt-slot-initarg s) (vector-ref s 3))
(define (rt-slot-readers s) (vector-ref s 4))
(define (rt-slot-writers s) (vector-ref s 5))

(define (make-rt-class name supers own-slots)
  (vector 'rt-class name supers own-slots))

(define (rt-class? x)
  (and (vector? x) (= (vector-length x) 4) (eq? (vector-ref x 0) 'rt-class)))

(define (rt-class-name c) (vector-ref c 1))
(define (rt-class-supers c) (vector-ref c 2))
(define (rt-class-own-slots c) (vector-ref c 3))

(define (make-rt-instance class slots)
  (vector 'rt-instance class slots))

(define (rt-instance? x)
  (and (vector? x) (= (vector-length x) 3) (eq? (vector-ref x 0) 'rt-instance)))

(define (rt-instance-class x) (vector-ref x 1))
(define (rt-instance-slots x) (vector-ref x 2))

(define (make-rt-method specializers params fn-val)
  (vector 'rt-method specializers params fn-val))

(define (rt-method? x)
  (and (vector? x) (= (vector-length x) 4) (eq? (vector-ref x 0) 'rt-method)))

(define (rt-method-specializers m) (vector-ref m 1))
(define (rt-method-params m) (vector-ref m 2))
(define (rt-method-fn m) (vector-ref m 3))

(define (make-rt-generic name params methods)
  (vector 'rt-generic name params methods))

(define (rt-generic? x)
  (and (vector? x) (= (vector-length x) 4) (eq? (vector-ref x 0) 'rt-generic)))

(define (rt-generic-name g) (vector-ref g 1))
(define (rt-generic-params g) (vector-ref g 2))
(define (rt-generic-methods g) (vector-ref g 3))
(define (set-rt-generic-methods! g methods) (vector-set! g 3 methods))

;; Function values.
(define (make-closure name params body env)
  (vector 'closure name params body env 'ir))

(define (make-closure/cfg name params cfg env)
  (vector 'closure name params cfg env 'cfg))

(define (closure? x)
  (and (vector? x) (= (vector-length x) 6) (eq? (vector-ref x 0) 'closure)))

(define (closure-name c) (vector-ref c 1))
(define (closure-params c) (vector-ref c 2))
(define (closure-body c) (vector-ref c 3))
(define (closure-env c) (vector-ref c 4))
(define (closure-kind c) (vector-ref c 5))

(define (make-primitive name proc)
  (vector 'primitive name proc))

(define (primitive? x)
  (and (vector? x) (= (vector-length x) 3) (eq? (vector-ref x 0) 'primitive)))

(define (primitive-name p) (vector-ref p 1))
(define (primitive-proc p) (vector-ref p 2))

(define (make-fn-value f)
  (make-rt-value 'function f))

(define (fn-from-value rv)
  (if (and (rt-value? rv) (eq? (rt-tag rv) 'function))
      (rt-payload rv)
      (runtime-raise 'type-error "Attempt to call non-function" rv)))

(define (parse-params params)
  (cond
   ((symbol? params)
    ;; Variadic shorthand: (defun f args ...)
    (list '() params))
   ((list? params)
    (let loop ((xs params) (required '()))
      (cond
       ((null? xs) (list (reverse required) #f))
       ((eq? (car xs) '&rest)
        (unless (and (pair? (cdr xs)) (symbol? (cadr xs)) (null? (cddr xs)))
          (runtime-raise 'invalid-params "invalid &rest parameter list" params))
        (list (reverse required) (cadr xs)))
       ((symbol? (car xs))
        (loop (cdr xs) (cons (car xs) required)))
       (else
        (runtime-raise 'invalid-params "parameter must be symbol" (car xs))))))
   ((pair? params)
    ;; Dotted variadic form: (a b . rest)
    (let dotted-loop ((xs params) (required '()))
      (cond
       ((pair? xs)
        (let ((x (car xs)))
          (unless (symbol? x)
            (runtime-raise 'invalid-params "parameter must be symbol" x))
          (when (or (eq? x '&optional) (eq? x '&rest) (eq? x '&body))
            (runtime-raise 'invalid-params "lambda-list keywords are not allowed in dotted parameter prefix" params))
          (dotted-loop (cdr xs) (cons x required))))
       ((symbol? xs)
        (list (reverse required) xs))
       (else
        (runtime-raise 'invalid-params "invalid dotted parameter list tail" xs)))))
   (else
    (runtime-raise 'invalid-params "invalid parameter list" params))))

(define (validate-params params)
  (parse-params params)
  #t)

(define (bind-params! call-env params args)
  (let* ((spec (parse-params params))
         (required (car spec))
         (rest-sym (cadr spec)))
    (when (< (length args) (length required))
      (runtime-raise 'arity "too few arguments" params args))
    (when (and (not rest-sym) (> (length args) (length required)))
      (runtime-raise 'arity "too many arguments" params args))
    (let bind-required ((ps required) (as args))
      (unless (null? ps)
        (env-define! call-env (car ps) (car as))
        (bind-required (cdr ps) (cdr as))))
    (when rest-sym
      (env-define! call-env
                   rest-sym
                   (host->runtime-value (map runtime-value->host (list-tail args (length required))))))))

(define (runtime-number rv who)
  (let ((v (runtime-value->host rv)))
    (if (number? v)
        v
        (runtime-raise 'type-error (string-append who " expects number") rv))))

(define (runtime-integer rv who)
  (let ((v (runtime-number rv who)))
    (if (integer? v)
        v
        (runtime-raise 'type-error (string-append who " expects integer") rv))))

(define (runtime-string rv who)
  (let ((v (runtime-value->host rv)))
    (if (string? v)
        v
        (runtime-raise 'type-error (string-append who " expects string") rv))))

(define (runtime-port-number rv who)
  (let ((v (runtime-integer rv who)))
    (if (and (>= v 1) (<= v 65535))
        v
        (runtime-raise 'type-error (string-append who " expects integer in 1..65535") rv))))

(define (runtime-byte rv who)
  (let ((v (runtime-integer rv who)))
    (if (and (>= v 0) (<= v 255))
        v
        (runtime-raise 'type-error (string-append who " expects integer in 0..255") rv))))

(define (runtime-vector rv who)
  (let ((v (runtime-value->host rv)))
    (if (vector? v)
        v
        (runtime-raise 'type-error (string-append who " expects vector") rv))))

(define (runtime-list rv who)
  (let ((v (runtime-value->host rv)))
    (if (list? v)
        v
        (runtime-raise 'type-error (string-append who " expects list") rv))))

(define (runtime-package-designator x who)
  (if (or (symbol? x) (string? x))
      x
      (runtime-raise 'type-error (string-append who " expects package designator") x)))

(define (runtime-object rv who pred)
  (let ((v (runtime-value->host rv)))
    (if (pred v)
        v
        (runtime-raise 'type-error (string-append who " received invalid object") rv))))

(define (make-runtime-tcp-connection socket in out)
  (vector 'tcp-connection socket in out))

(define (runtime-tcp-connection? obj)
  (and (vector? obj)
       (= (vector-length obj) 4)
       (eq? (vector-ref obj 0) 'tcp-connection)))

(define (runtime-tcp-connection-socket conn)
  (vector-ref conn 1))

(define (runtime-tcp-connection-input conn)
  (vector-ref conn 2))

(define (runtime-tcp-connection-output conn)
  (vector-ref conn 3))

(define (make-runtime-tcp-listener socket)
  (vector 'tcp-listener socket))

(define (runtime-tcp-listener? obj)
  (and (vector? obj)
       (= (vector-length obj) 2)
       (eq? (vector-ref obj 0) 'tcp-listener)))

(define (runtime-tcp-listener-socket listener)
  (vector-ref listener 1))

(define (make-runtime-tls-connection tls in out)
  (vector 'tls-connection tls in out))

(define (runtime-tls-connection? obj)
  (and (vector? obj)
       (= (vector-length obj) 4)
       (eq? (vector-ref obj 0) 'tls-connection)))

(define (runtime-tls-connection-raw conn)
  (vector-ref conn 1))

(define (runtime-tls-connection-input conn)
  (vector-ref conn 2))

(define (runtime-tls-connection-output conn)
  (vector-ref conn 3))

(define (make-runtime-tls-listener tls)
  (vector 'tls-listener tls))

(define (runtime-tls-listener? obj)
  (and (vector? obj)
       (= (vector-length obj) 2)
       (eq? (vector-ref obj 0) 'tls-listener)))

(define (runtime-tls-listener-raw listener)
  (vector-ref listener 1))

(define (resolve-class-designator obj env)
  (cond
   ((rt-class? obj) obj)
   ((symbol? obj)
    (let ((v (runtime-value->host (env-ref env obj))))
      (if (rt-class? v)
          v
          (runtime-raise 'type-error "class designator does not resolve to class" obj))))
   (else
    (runtime-raise 'type-error "invalid class designator" obj))))

(define (slot-spec-list-merge specs)
  (let loop ((rest specs) (acc '()))
    (if (null? rest)
        (reverse acc)
        (let* ((s (car rest))
               (name (rt-slot-name s))
               (acc2 (filter (lambda (e) (not (eq? (rt-slot-name e) name))) acc)))
          (loop (cdr rest) (cons s acc2))))))

(define (rt-class-effective-slots class-obj)
  (let collect ((c class-obj) (seen '()))
    (if (memq c seen)
        (runtime-raise 'invalid-ir "Cyclic class precedence list" (rt-class-name c))
        (let ((seen2 (cons c seen)))
          (slot-spec-list-merge
           (append
            (apply append
                   (map (lambda (s) (collect s seen2))
                        (rt-class-supers c)))
            (rt-class-own-slots c)))))))

(define (find-slot-spec-entry specs slot)
  (or (find (lambda (s) (eq? (rt-slot-initarg s) slot)) specs)
      (find (lambda (s) (eq? (rt-slot-name s) slot)) specs)))

(define (find-instance-slot-entry slots slot)
  (assoc slot slots))

(define (rt-instance-slot-ref obj slot)
  (unless (rt-instance? obj)
    (runtime-raise 'type-error "slot-value target must be instance" obj))
  (unless (symbol? slot)
    (runtime-raise 'type-error "slot-value slot must be symbol" slot))
  (let ((entry (find-instance-slot-entry (rt-instance-slots obj) slot)))
    (if entry
        (cdr entry)
        (runtime-raise 'invalid-ir "No such slot in instance" slot))))

(define (rt-instance-slot-set! obj slot value)
  (unless (rt-instance? obj)
    (runtime-raise 'type-error "slot-value target must be instance" obj))
  (unless (symbol? slot)
    (runtime-raise 'type-error "slot-value slot must be symbol" slot))
  (let ((entry (find-instance-slot-entry (rt-instance-slots obj) slot)))
    (if entry
        (begin
          (set-cdr! entry value)
          value)
        (runtime-raise 'invalid-ir "No such slot in instance" slot))))

(define (rt-class-distance sub super)
  (let walk ((current sub) (seen '()))
    (cond
     ((eq? current super) 0)
     ((memq current seen) #f)
     (else
      (let ((seen2 (cons current seen)))
        (let loop ((supers (rt-class-supers current)) (best #f))
          (if (null? supers)
              best
              (let ((d (walk (car supers) seen2)))
                (if d
                    (let ((cand (+ d 1)))
                      (if (or (not best) (< cand best))
                          (loop (cdr supers) cand)
                          (loop (cdr supers) best)))
                    (loop (cdr supers) best))))))))))

(define (score<? a b)
  (let loop ((xs a) (ys b))
    (cond
     ((null? xs) #f)
     ((< (car xs) (car ys)) #t)
     ((> (car xs) (car ys)) #f)
     (else (loop (cdr xs) (cdr ys))))))

(define (score=? a b)
  (equal? a b))

(define (method-applicability-score method args)
  (let ((specializers (rt-method-specializers method)))
    (if (< (length args) (length specializers))
        #f
        (let loop ((ss specializers) (as args) (acc '()))
          (if (null? ss)
              (reverse acc)
              (let ((spec (car ss))
                    (arg (runtime-value->host (car as))))
                (if spec
                    (if (rt-instance? arg)
                        (let ((d (rt-class-distance (rt-instance-class arg) spec)))
                          (if d
                              (loop (cdr ss) (cdr as) (cons d acc))
                              #f))
                        #f)
                    (loop (cdr ss) (cdr as) (cons 1000000 acc)))))))))

(define (select-generic-method generic args)
  (let loop ((methods (rt-generic-methods generic))
             (best-method #f)
             (best-score #f))
    (if (null? methods)
        best-method
        (let* ((m (car methods))
               (score (method-applicability-score m args)))
          (cond
           ((not score)
            (loop (cdr methods) best-method best-score))
           ((or (not best-score) (score<? score best-score))
            (loop (cdr methods) m score))
           ((score=? score best-score)
            (runtime-raise 'invalid-ir
                           "Ambiguous applicable methods in generic function"
                           (rt-generic-name generic)))
           (else
            (loop (cdr methods) best-method best-score)))))))

(define (ensure-generic-function! sym env params)
  (let ((pair (env-find-pair env sym)))
    (cond
     ((and pair
           (rt-value? (cdr pair))
           (eq? (rt-tag (cdr pair)) 'function)
           (rt-generic? (rt-payload (cdr pair))))
      (rt-payload (cdr pair)))
     (pair
      (runtime-raise 'type-error "Binding already exists and is not a generic function" sym))
     (else
      (let ((g (make-rt-generic sym params '())))
        (env-define! env sym (make-fn-value g))
        g)))))

(define (parse-method-params params env)
  (unless (list? params)
    (runtime-raise 'invalid-ir "defmethod parameter list must be list" params))
  (let parse-required ((xs params) (plain-required '()) (specializers '()))
    (if (or (null? xs)
            (eq? (car xs) '&optional)
            (eq? (car xs) '&rest)
            (eq? (car xs) '&body))
        (let* ((plain-params (append (reverse plain-required) xs))
               (spec (parse-params plain-params))
               (required-spec (car spec)))
          (when (null? required-spec)
            (runtime-raise 'invalid-ir "defmethod requires at least one required parameter" params))
          (unless (= (length required-spec) (length specializers))
            (runtime-raise 'invalid-ir "defmethod required parameter parse mismatch" params))
          (list plain-params (reverse specializers)))
        (let ((x (car xs)))
          (cond
           ((symbol? x)
            (parse-required (cdr xs)
                            (cons x plain-required)
                            (cons #f specializers)))
           ((and (list? x) (= (length x) 2) (symbol? (car x)))
            (parse-required (cdr xs)
                            (cons (car x) plain-required)
                            (cons (resolve-class-designator (cadr x) env) specializers)))
           (else
            (runtime-raise 'invalid-ir "invalid defmethod required parameter" x)))))))

(define (runtime-compare-binop who pred args)
  (unless (= (length args) 2)
    (runtime-raise 'arity (string-append who " expects 2 arguments") args))
  (let ((a (runtime-number (car args) who))
        (b (runtime-number (cadr args) who)))
    (host->runtime-value (if (pred a b) #t #f))))

(define (runtime-arith who op identity args)
  (if (null? args)
      (host->runtime-value identity)
      (let loop ((xs args) (acc (runtime-number (car args) who)) (rest (cdr args)))
        (if (null? rest)
            (host->runtime-value acc)
            (loop xs (op acc (runtime-number (car rest) who)) (cdr rest))))))

(define (install-primitives! env)
  (define (def name proc)
    (env-define! env name (make-fn-value (make-primitive name proc))))
  (def '+
    (lambda (args state)
      (runtime-arith "+" + 0 args)))
  (def '*
    (lambda (args state)
      (runtime-arith "*" * 1 args)))
  (def '-
    (lambda (args state)
      (cond
       ((null? args)
        (runtime-raise 'arity "- expects at least 1 argument" args))
       ((null? (cdr args))
        (host->runtime-value (- (runtime-number (car args) "-"))))
       (else
        (let loop ((acc (runtime-number (car args) "-")) (rest (cdr args)))
          (if (null? rest)
              (host->runtime-value acc)
              (loop (- acc (runtime-number (car rest) "-")) (cdr rest))))))))
  (def '/
    (lambda (args state)
      (cond
       ((null? args)
        (runtime-raise 'arity "/ expects at least 1 argument" args))
       ((null? (cdr args))
        (host->runtime-value (/ 1 (runtime-number (car args) "/"))))
       (else
        (let loop ((acc (runtime-number (car args) "/")) (rest (cdr args)))
          (if (null? rest)
              (host->runtime-value acc)
              (loop (/ acc (runtime-number (car rest) "/")) (cdr rest))))))))
  (def '=
    (lambda (args state)
      (runtime-compare-binop "=" = args)))
  (def '<
    (lambda (args state)
      (runtime-compare-binop "<" < args)))
  (def '>
    (lambda (args state)
      (runtime-compare-binop ">" > args)))
  (def '<=
    (lambda (args state)
      (runtime-compare-binop "<=" <= args)))
  (def '>=
    (lambda (args state)
      (runtime-compare-binop ">=" >= args)))
  (def 'mod
    (lambda (args state)
      (unless (= (length args) 2)
        (runtime-raise 'arity "mod expects 2 arguments" args))
      (let ((a (runtime-integer (car args) "mod"))
            (b (runtime-integer (cadr args) "mod")))
        (host->runtime-value (modulo a b)))))
  (def 'floor
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "floor expects 1 argument" args))
      (host->runtime-value (floor (runtime-number (car args) "floor")))))
  (def 'ceiling
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "ceiling expects 1 argument" args))
      (host->runtime-value (ceiling (runtime-number (car args) "ceiling")))))
  (def 'truncate
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "truncate expects 1 argument" args))
      (host->runtime-value (truncate (runtime-number (car args) "truncate")))))
  (def 'round
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "round expects 1 argument" args))
      (host->runtime-value (round (runtime-number (car args) "round")))))
  (def 'numberp
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "numberp expects 1 argument" args))
      (host->runtime-value (if (number? (runtime-value->host (car args))) #t #f))))
  (def 'zerop
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "zerop expects 1 argument" args))
      (host->runtime-value (if (zero? (runtime-number (car args) "zerop")) #t #f))))
  (def 'plusp
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "plusp expects 1 argument" args))
      (host->runtime-value (if (> (runtime-number (car args) "plusp") 0) #t #f))))
  (def 'minusp
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "minusp expects 1 argument" args))
      (host->runtime-value (if (< (runtime-number (car args) "minusp") 0) #t #f))))
  (def 'evenp
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "evenp expects 1 argument" args))
      (host->runtime-value
       (if (zero? (modulo (runtime-integer (car args) "evenp") 2)) #t #f))))
  (def 'oddp
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "oddp expects 1 argument" args))
      (host->runtime-value
       (if (zero? (modulo (runtime-integer (car args) "oddp") 2)) #f #t))))
  (def 'list
    (lambda (args state)
      (host->runtime-value (map runtime-value->host args))))
  (def 'append
    (lambda (args state)
      (host->runtime-value (apply append (map (lambda (x) (runtime-list x "append")) args)))))
  (def 'vector
    (lambda (args state)
      (host->runtime-value (list->vector (map runtime-value->host args)))))
  (def 'vector-ref
    (lambda (args state)
      (unless (= (length args) 2)
        (runtime-raise 'arity "vector-ref expects 2 arguments" args))
      (let* ((v (runtime-vector (car args) "vector-ref"))
             (i (runtime-number (cadr args) "vector-ref")))
        (host->runtime-value (vector-ref v i)))))
  (def 'funcall
    (lambda (args state)
      (unless (>= (length args) 1)
        (runtime-raise 'arity "funcall expects at least 1 argument" args))
      (runtime-apply (car args) (cdr args) state)))
  (def 'not
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "not expects 1 argument" args))
      (host->runtime-value (if (runtime-truthy? (car args)) #f #t))))
  (def 'print
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "print expects 1 argument" args))
      (write (runtime-value->host (car args)))
      (newline)
      (car args)))
  (def 'current-package
    (lambda (args state)
      (unless (= (length args) 0)
        (runtime-raise 'arity "current-package expects 0 arguments" args))
      (host->runtime-value
       (with-module isl.core
         (string->symbol (package-name *current-package*))))))
  (def 'find-package
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "find-package expects 1 argument" args))
      (let* ((name (runtime-package-designator (runtime-value->host (car args)) "find-package"))
             (p (with-module isl.core (find-package name))))
        (host->runtime-value
         (if p
             (with-module isl.core (string->symbol (package-name p)))
             '())))))
  (def 'use-package
    (lambda (args state)
      (unless (or (= (length args) 1) (= (length args) 2))
        (runtime-raise 'arity "use-package expects 1 or 2 arguments" args))
      (let* ((used-name (runtime-package-designator (runtime-value->host (car args)) "use-package"))
             (target-name (and (= (length args) 2)
                               (runtime-package-designator (runtime-value->host (cadr args)) "use-package"))))
        (with-module isl.core
          (let ((used (ensure-package! used-name))
                (target (if target-name (ensure-package! target-name) *current-package*)))
            (package-use! target used)))
        (host->runtime-value #t))))
  (def 'export
    (lambda (args state)
      (unless (or (= (length args) 1) (= (length args) 2))
        (runtime-raise 'arity "export expects 1 or 2 arguments" args))
      (let* ((vals (runtime-value->host (car args)))
             (pkg-name (and (= (length args) 2)
                            (runtime-package-designator (runtime-value->host (cadr args)) "export"))))
        (with-module isl.core
          (let ((pkg (if pkg-name (ensure-package! pkg-name) *current-package*)))
            (cond
             ((symbol? vals) (package-export! pkg vals))
             ((list? vals)
              (for-each (lambda (s)
                          (unless (symbol? s)
                            (error "export list must contain symbols" s))
                          (package-export! pkg s))
                        vals))
             (else
              (error "export expects symbol or list of symbols" vals)))))
        (host->runtime-value #t))))
  (def 'intern
    (lambda (args state)
      (unless (or (= (length args) 1) (= (length args) 2))
        (runtime-raise 'arity "intern expects 1 or 2 arguments" args))
      (let* ((name-arg (runtime-value->host (car args)))
             (name (cond
                    ((symbol? name-arg) (with-module isl.core (symbol-base-name name-arg)))
                    ((string? name-arg) name-arg)
                    (else
                     (runtime-raise 'type-error "intern name must be symbol or string" name-arg))))
             (pkg-name (and (= (length args) 2)
                            (runtime-package-designator (runtime-value->host (cadr args)) "intern"))))
        (host->runtime-value
         (with-module isl.core
           (let ((pkg (if pkg-name (ensure-package! pkg-name) *current-package*)))
             (package-intern! pkg name)))))))
  (def 'import
    (lambda (args state)
      (unless (or (= (length args) 1) (= (length args) 2))
        (runtime-raise 'arity "import expects 1 or 2 arguments" args))
      (let* ((vals (runtime-value->host (car args)))
             (pkg-name (and (= (length args) 2)
                            (runtime-package-designator (runtime-value->host (cadr args)) "import"))))
        (with-module isl.core
          (let ((pkg (if pkg-name (ensure-package! pkg-name) *current-package*)))
            (cond
             ((symbol? vals) (package-import-symbol! pkg vals))
             ((list? vals)
              (for-each (lambda (s)
                          (unless (symbol? s)
                            (error "import list must contain symbols" s))
                          (package-import-symbol! pkg s))
                        vals))
             (else
              (error "import expects symbol or list of symbols" vals)))))
        (host->runtime-value #t))))
  (def 'make-instance
    (lambda (args state)
      (unless (>= (length args) 1)
        (runtime-raise 'arity "make-instance needs class designator" args))
      (let* ((class-obj (resolve-class-designator (runtime-value->host (car args))
                                                  (state-global-env state)))
             (raw-initargs (cdr args)))
        (unless (even? (length raw-initargs))
          (runtime-raise 'arity "make-instance initargs must be key/value pairs" raw-initargs))
        (let* ((slot-specs (rt-class-effective-slots class-obj))
               (slots
                (map (lambda (s)
                       (cons (rt-slot-name s)
                             (runtime-value->host
                              (runtime-eval-expr (rt-slot-initform s)
                                                 (state-global-env state)
                                                 state))))
                     slot-specs))
               (obj (make-rt-instance class-obj slots)))
          (let apply-initargs ((rest raw-initargs))
            (unless (null? rest)
              (let* ((k (runtime-value->host (car rest)))
                     (v (runtime-value->host (cadr rest))))
                (unless (symbol? k)
                  (runtime-raise 'type-error "make-instance initarg key must be symbol" k))
                (let ((spec (find-slot-spec-entry slot-specs k)))
                  (unless spec
                    (runtime-raise 'invalid-ir "Unknown initarg for make-instance" k))
                  (rt-instance-slot-set! obj (rt-slot-name spec) v))
                (apply-initargs (cddr rest)))))
          (host->runtime-value obj)))))
  (def 'class-of
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "class-of expects 1 argument" args))
      (let ((obj (runtime-value->host (car args))))
        (cond
         ((rt-instance? obj) (host->runtime-value (rt-instance-class obj)))
         ((rt-class? obj) (car args))
         (else
          (runtime-raise 'type-error "class-of target must be instance or class" obj))))))
  (def 'instancep
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "instancep expects 1 argument" args))
      (host->runtime-value (if (rt-instance? (runtime-value->host (car args))) #t #f))))
  (def 'slot-value
    (lambda (args state)
      (unless (= (length args) 2)
        (runtime-raise 'arity "slot-value expects 2 arguments" args))
      (let ((obj (runtime-value->host (car args)))
            (slot (runtime-value->host (cadr args))))
        (host->runtime-value (rt-instance-slot-ref obj slot)))))
  (def 'tcp-connect
    (lambda (args state)
      (unless (= (length args) 2)
        (runtime-raise 'arity "tcp-connect expects host and port" args))
      (let ((host (runtime-string (car args) "tcp-connect"))
            (port (runtime-port-number (cadr args) "tcp-connect")))
        (let ((sock (make-client-socket 'inet host port)))
          (host->runtime-value
           (make-runtime-tcp-connection sock
                                        (socket-input-port sock)
                                        (socket-output-port sock)))))))
  (def 'tcp-listen
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tcp-listen expects port" args))
      (let ((port (runtime-port-number (car args) "tcp-listen")))
        (host->runtime-value
         (make-runtime-tcp-listener
          (make-server-socket 'inet port :reuse-addr? #t))))))
  (def 'tcp-listener-p
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tcp-listener-p expects 1 argument" args))
      (host->runtime-value
       (if (runtime-tcp-listener? (runtime-value->host (car args))) #t #f))))
  (def 'tcp-accept
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tcp-accept expects listener" args))
      (let ((listener (runtime-value->host (car args))))
        (unless (runtime-tcp-listener? listener)
          (runtime-raise 'type-error "tcp-accept expects tcp listener" (car args)))
        (receive (sock addr) (socket-accept (runtime-tcp-listener-socket listener))
          (host->runtime-value
           (make-runtime-tcp-connection sock
                                        (socket-input-port sock)
                                        (socket-output-port sock)))))))
  (def 'tcp-listener-close
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tcp-listener-close expects listener" args))
      (let ((listener (runtime-value->host (car args))))
        (unless (runtime-tcp-listener? listener)
          (runtime-raise 'type-error "tcp-listener-close expects tcp listener" (car args)))
        (guard (e (else #f))
          (socket-close (runtime-tcp-listener-socket listener)))
        (host->runtime-value #t))))
  (def 'tcp-connection-p
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tcp-connection-p expects 1 argument" args))
      (host->runtime-value
       (if (runtime-tcp-connection? (runtime-value->host (car args))) #t #f))))
  (def 'tcp-send
    (lambda (args state)
      (unless (= (length args) 2)
        (runtime-raise 'arity "tcp-send expects connection and text" args))
      (let ((conn (runtime-value->host (car args)))
            (text (runtime-string (cadr args) "tcp-send")))
        (unless (runtime-tcp-connection? conn)
          (runtime-raise 'type-error "tcp-send expects tcp connection" (car args)))
        (display text (runtime-tcp-connection-output conn))
        (flush (runtime-tcp-connection-output conn))
        (host->runtime-value text))))
  (def 'tcp-send-line
    (lambda (args state)
      (unless (= (length args) 2)
        (runtime-raise 'arity "tcp-send-line expects connection and text" args))
      (let ((conn (runtime-value->host (car args)))
            (text (runtime-string (cadr args) "tcp-send-line")))
        (unless (runtime-tcp-connection? conn)
          (runtime-raise 'type-error "tcp-send-line expects tcp connection" (car args)))
        (display text (runtime-tcp-connection-output conn))
        (newline (runtime-tcp-connection-output conn))
        (flush (runtime-tcp-connection-output conn))
        (host->runtime-value text))))
  (def 'tcp-receive-line
    (lambda (args state)
      (unless (or (= (length args) 1) (= (length args) 2))
        (runtime-raise 'arity "tcp-receive-line expects conn and optional eof-error-p" args))
      (let* ((conn (runtime-value->host (car args)))
             (eof-error-p (if (= (length args) 2) (runtime-truthy? (cadr args)) #t)))
        (unless (runtime-tcp-connection? conn)
          (runtime-raise 'type-error "tcp-receive-line expects tcp connection" (car args)))
        (let ((line (read-line (runtime-tcp-connection-input conn))))
          (if (eof-object? line)
              (if eof-error-p
                  (runtime-raise 'io-error "tcp-receive-line reached EOF")
                  (host->runtime-value '()))
              (host->runtime-value line))))))
  (def 'tcp-receive-char
    (lambda (args state)
      (unless (or (= (length args) 1) (= (length args) 2))
        (runtime-raise 'arity "tcp-receive-char expects conn and optional eof-error-p" args))
      (let* ((conn (runtime-value->host (car args)))
             (eof-error-p (if (= (length args) 2) (runtime-truthy? (cadr args)) #t)))
        (unless (runtime-tcp-connection? conn)
          (runtime-raise 'type-error "tcp-receive-char expects tcp connection" (car args)))
        (let ((ch (read-char (runtime-tcp-connection-input conn))))
          (if (eof-object? ch)
              (if eof-error-p
                  (runtime-raise 'io-error "tcp-receive-char reached EOF")
                  (host->runtime-value '()))
              (host->runtime-value ch))))))
  (def 'tcp-send-byte
    (lambda (args state)
      (unless (= (length args) 2)
        (runtime-raise 'arity "tcp-send-byte expects connection and byte" args))
      (let ((conn (runtime-value->host (car args)))
            (byte (runtime-byte (cadr args) "tcp-send-byte")))
        (unless (runtime-tcp-connection? conn)
          (runtime-raise 'type-error "tcp-send-byte expects tcp connection" (car args)))
        (write-byte byte (runtime-tcp-connection-output conn))
        (flush (runtime-tcp-connection-output conn))
        (host->runtime-value byte))))
  (def 'tcp-receive-byte
    (lambda (args state)
      (unless (or (= (length args) 1) (= (length args) 2))
        (runtime-raise 'arity "tcp-receive-byte expects conn and optional eof-error-p" args))
      (let* ((conn (runtime-value->host (car args)))
             (eof-error-p (if (= (length args) 2) (runtime-truthy? (cadr args)) #t)))
        (unless (runtime-tcp-connection? conn)
          (runtime-raise 'type-error "tcp-receive-byte expects tcp connection" (car args)))
        (let ((byte (read-byte (runtime-tcp-connection-input conn))))
          (if (eof-object? byte)
              (if eof-error-p
                  (runtime-raise 'io-error "tcp-receive-byte reached EOF")
                  (host->runtime-value '()))
              (host->runtime-value byte))))))
  (def 'tcp-flush
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tcp-flush expects connection" args))
      (let ((conn (runtime-value->host (car args))))
        (unless (runtime-tcp-connection? conn)
          (runtime-raise 'type-error "tcp-flush expects tcp connection" (car args)))
        (flush (runtime-tcp-connection-output conn))
        (host->runtime-value #t))))
  (def 'tcp-close
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tcp-close expects connection" args))
      (let ((conn (runtime-value->host (car args))))
        (unless (runtime-tcp-connection? conn)
          (runtime-raise 'type-error "tcp-close expects tcp connection" (car args)))
        (guard (e (else #f))
          (close-input-port (runtime-tcp-connection-input conn)))
        (guard (e (else #f))
          (close-output-port (runtime-tcp-connection-output conn)))
        (guard (e (else #f))
          (socket-close (runtime-tcp-connection-socket conn)))
        (host->runtime-value #t))))
  (def 'tls-listen
    (lambda (args state)
      (unless (or (= (length args) 3) (= (length args) 4))
        (runtime-raise 'arity "tls-listen expects port cert-file key-file and optional key-password" args))
      (let* ((port (runtime-port-number (car args) "tls-listen"))
             (cert-file (runtime-string (cadr args) "tls-listen"))
             (key-file (runtime-string (caddr args) "tls-listen"))
             (key-password (if (= (length args) 4)
                               (runtime-string (cadddr args) "tls-listen")
                               #f))
             (tls (gauche-make-tls)))
        (gauche-tls-load-certificate tls cert-file)
        (gauche-tls-load-private-key tls key-file key-password)
        (gauche-tls-bind tls "0.0.0.0" port 'tcp)
        (host->runtime-value (make-runtime-tls-listener tls)))))
  (def 'tls-listener-p
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tls-listener-p expects 1 argument" args))
      (host->runtime-value
       (if (runtime-tls-listener? (runtime-value->host (car args))) #t #f))))
  (def 'tls-accept
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tls-accept expects listener" args))
      (let ((listener (runtime-value->host (car args))))
        (unless (runtime-tls-listener? listener)
          (runtime-raise 'type-error "tls-accept expects tls listener" (car args)))
        (let ((conn (gauche-tls-accept (runtime-tls-listener-raw listener))))
          (host->runtime-value
           (make-runtime-tls-connection conn
                                        (gauche-connection-input-port conn)
                                        (gauche-connection-output-port conn)))))))
  (def 'tls-listener-close
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tls-listener-close expects listener" args))
      (let ((listener (runtime-value->host (car args))))
        (unless (runtime-tls-listener? listener)
          (runtime-raise 'type-error "tls-listener-close expects tls listener" (car args)))
        (guard (e (else #f))
          (gauche-tls-close (runtime-tls-listener-raw listener)))
        (host->runtime-value #t))))
  (def 'tls-connection-p
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tls-connection-p expects 1 argument" args))
      (host->runtime-value
       (if (runtime-tls-connection? (runtime-value->host (car args))) #t #f))))
  (def 'tls-send
    (lambda (args state)
      (unless (= (length args) 2)
        (runtime-raise 'arity "tls-send expects connection and text" args))
      (let ((conn (runtime-value->host (car args)))
            (text (runtime-string (cadr args) "tls-send")))
        (unless (runtime-tls-connection? conn)
          (runtime-raise 'type-error "tls-send expects tls connection" (car args)))
        (display text (runtime-tls-connection-output conn))
        (flush (runtime-tls-connection-output conn))
        (host->runtime-value text))))
  (def 'tls-send-line
    (lambda (args state)
      (unless (= (length args) 2)
        (runtime-raise 'arity "tls-send-line expects connection and text" args))
      (let ((conn (runtime-value->host (car args)))
            (text (runtime-string (cadr args) "tls-send-line")))
        (unless (runtime-tls-connection? conn)
          (runtime-raise 'type-error "tls-send-line expects tls connection" (car args)))
        (display text (runtime-tls-connection-output conn))
        (newline (runtime-tls-connection-output conn))
        (flush (runtime-tls-connection-output conn))
        (host->runtime-value text))))
  (def 'tls-receive-line
    (lambda (args state)
      (unless (or (= (length args) 1) (= (length args) 2))
        (runtime-raise 'arity "tls-receive-line expects conn and optional eof-error-p" args))
      (let* ((conn (runtime-value->host (car args)))
             (eof-error-p (if (= (length args) 2) (runtime-truthy? (cadr args)) #t)))
        (unless (runtime-tls-connection? conn)
          (runtime-raise 'type-error "tls-receive-line expects tls connection" (car args)))
        (let ((line (read-line (runtime-tls-connection-input conn))))
          (if (eof-object? line)
              (if eof-error-p
                  (runtime-raise 'io-error "tls-receive-line reached EOF")
                  (host->runtime-value '()))
              (host->runtime-value line))))))
  (def 'tls-receive-char
    (lambda (args state)
      (unless (or (= (length args) 1) (= (length args) 2))
        (runtime-raise 'arity "tls-receive-char expects conn and optional eof-error-p" args))
      (let* ((conn (runtime-value->host (car args)))
             (eof-error-p (if (= (length args) 2) (runtime-truthy? (cadr args)) #t)))
        (unless (runtime-tls-connection? conn)
          (runtime-raise 'type-error "tls-receive-char expects tls connection" (car args)))
        (let ((ch (read-char (runtime-tls-connection-input conn))))
          (if (eof-object? ch)
              (if eof-error-p
                  (runtime-raise 'io-error "tls-receive-char reached EOF")
                  (host->runtime-value '()))
              (host->runtime-value ch))))))
  (def 'tls-send-byte
    (lambda (args state)
      (unless (= (length args) 2)
        (runtime-raise 'arity "tls-send-byte expects connection and byte" args))
      (let ((conn (runtime-value->host (car args)))
            (byte (runtime-byte (cadr args) "tls-send-byte")))
        (unless (runtime-tls-connection? conn)
          (runtime-raise 'type-error "tls-send-byte expects tls connection" (car args)))
        (write-byte byte (runtime-tls-connection-output conn))
        (flush (runtime-tls-connection-output conn))
        (host->runtime-value byte))))
  (def 'tls-receive-byte
    (lambda (args state)
      (unless (or (= (length args) 1) (= (length args) 2))
        (runtime-raise 'arity "tls-receive-byte expects conn and optional eof-error-p" args))
      (let* ((conn (runtime-value->host (car args)))
             (eof-error-p (if (= (length args) 2) (runtime-truthy? (cadr args)) #t)))
        (unless (runtime-tls-connection? conn)
          (runtime-raise 'type-error "tls-receive-byte expects tls connection" (car args)))
        (let ((byte (read-byte (runtime-tls-connection-input conn))))
          (if (eof-object? byte)
              (if eof-error-p
                  (runtime-raise 'io-error "tls-receive-byte reached EOF")
                  (host->runtime-value '()))
              (host->runtime-value byte))))))
  (def 'tls-flush
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tls-flush expects connection" args))
      (let ((conn (runtime-value->host (car args))))
        (unless (runtime-tls-connection? conn)
          (runtime-raise 'type-error "tls-flush expects tls connection" (car args)))
        (flush (runtime-tls-connection-output conn))
        (host->runtime-value #t))))
  (def 'tls-close
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "tls-close expects connection" args))
      (let ((conn (runtime-value->host (car args))))
        (unless (runtime-tls-connection? conn)
          (runtime-raise 'type-error "tls-close expects tls connection" (car args)))
        (guard (e (else #f))
          (close-input-port (runtime-tls-connection-input conn)))
        (guard (e (else #f))
          (close-output-port (runtime-tls-connection-output conn)))
        (guard (e (else #f))
          (gauche-connection-close (runtime-tls-connection-raw conn)))
        (host->runtime-value #t))))
  (def 'thread-spawn
    (lambda (args state)
      (unless (>= (length args) 1)
        (runtime-raise 'arity "thread-spawn expects function and optional args" args))
      (let ((fn (car args))
            (fn-args (cdr args)))
        (host->runtime-value
         (let ((th (gauche-make-thread
                    (lambda ()
                      (guard (e (else e))
                        (runtime-apply fn fn-args state))))))
           (gauche-thread-start! th)
           th)))))
  (def 'thread-p
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "thread-p expects 1 argument" args))
      (host->runtime-value
       (if (gauche-thread? (runtime-value->host (car args))) #t #f))))
  (def 'thread-join
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "thread-join expects thread" args))
      (let ((th (runtime-value->host (car args))))
        (unless (gauche-thread? th)
          (runtime-raise 'type-error "thread-join expects thread object" (car args)))
        (host->runtime-value (gauche-thread-join! th)))))
  (def 'mutex-open
    (lambda (args state)
      (unless (= (length args) 0)
        (runtime-raise 'arity "mutex-open expects no arguments" args))
      (host->runtime-value (gauche-make-mutex))))
  (def 'mutex-p
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "mutex-p expects 1 argument" args))
      (host->runtime-value
       (if (gauche-mutex? (runtime-value->host (car args))) #t #f))))
  (def 'mutex-lock
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "mutex-lock expects mutex" args))
      (let ((m (runtime-value->host (car args))))
        (unless (gauche-mutex? m)
          (runtime-raise 'type-error "mutex-lock expects mutex object" (car args)))
        (gauche-mutex-lock! m)
        (host->runtime-value #t))))
  (def 'mutex-unlock
    (lambda (args state)
      (unless (= (length args) 1)
        (runtime-raise 'arity "mutex-unlock expects mutex" args))
      (let ((m (runtime-value->host (car args))))
        (unless (gauche-mutex? m)
          (runtime-raise 'type-error "mutex-unlock expects mutex object" (car args)))
        (gauche-mutex-unlock! m)
        (host->runtime-value #t))))
  )

(define (runtime-eval-special op payload env state)
  (define (handler-case-tag-match? tag)
    (or (eq? tag 'error)
        (eq? tag 'condition)
        (eq? tag 'serious-condition)
        (eq? tag 't)
        (eq? tag 'otherwise)))
  (case op
    ((setq)
     (unless (list? payload)
       (runtime-raise 'invalid-ir "setq payload must be list" payload))
     (if (null? payload)
         (host->runtime-value '())
         (let loop ((xs payload) (last (host->runtime-value '())))
           (if (null? xs)
               last
               (let ((entry (car xs)))
                 (unless (and (list? entry) (= (length entry) 2) (symbol? (car entry)))
                   (runtime-raise 'invalid-ir "setq entry must be (symbol expr)" entry))
                 (let ((v (runtime-eval-expr (cadr entry) env state)))
                   (env-set! env (car entry) v)
                   (loop (cdr xs) v)))))))
    ((let)
     (unless (and (list? payload) (= (length payload) 2))
       (runtime-raise 'invalid-ir "let payload must be (bindings body)" payload))
     (let* ((bindings (car payload))
            (body (cadr payload)))
       (unless (list? bindings)
         (runtime-raise 'invalid-ir "let bindings must be list" bindings))
       ;; Evaluation order fixed: init forms are evaluated left-to-right in outer env.
       (let ((init-values
              (map (lambda (b)
                     (unless (and (list? b) (= (length b) 2) (symbol? (car b)))
                       (runtime-raise 'invalid-ir "let binding must be (symbol expr)" b))
                     (list (car b) (runtime-eval-expr (cadr b) env state)))
                   bindings)))
         (let ((let-env (make-env env)))
           (for-each (lambda (x) (env-define! let-env (car x) (cadr x))) init-values)
           (runtime-eval-expr body let-env state)))))
    ((setf)
     (unless (and (list? payload) (= (length payload) 2))
       (runtime-raise 'invalid-ir "setf payload must be (place value)" payload))
     (let ((place (car payload))
           (value-expr (cadr payload)))
       (unless (and (list? place) (symbol? (car place)))
         (runtime-raise 'invalid-ir "setf place must be tagged place" place))
       (case (car place)
         ((place-vector-ref)
          (unless (= (length place) 3)
            (runtime-raise 'invalid-ir "place-vector-ref expects vec/index" place))
          (let* ((vec-rv (runtime-eval-expr (cadr place) env state))
                 (idx-rv (runtime-eval-expr (caddr place) env state))
                 (value-rv (runtime-eval-expr value-expr env state))
                 (vec (runtime-vector vec-rv "setf vector-ref"))
                 (idx (runtime-number idx-rv "setf vector-ref")))
            (vector-set! vec idx (runtime-value->host value-rv))
            value-rv))
         (else
         (runtime-raise 'unsupported-special "unsupported setf place" place)))))
    ((block)
     (unless (and (list? payload) (= (length payload) 2) (symbol? (car payload)))
       (runtime-raise 'invalid-ir "block payload must be (name body)" payload))
     (let ((name (car payload))
           (body (cadr payload)))
       (guard (e
               ((nonlocal-return? e)
                (if (eq? (nonlocal-return-name e) name)
                    (nonlocal-return-value e)
                    (raise e)))
               (else (raise e)))
         (runtime-eval-expr body env state))))
    ((return-from)
     (unless (and (list? payload) (= (length payload) 2) (symbol? (car payload)))
       (runtime-raise 'invalid-ir "return-from payload must be (name value)" payload))
     (let ((name (car payload))
           (value (runtime-eval-expr (cadr payload) env state)))
       (raise (make-nonlocal-return name value))))
    ((catch)
     (unless (and (list? payload) (= (length payload) 2))
       (runtime-raise 'invalid-ir "catch payload must be (tag body)" payload))
     (let ((tag (runtime-value->host (runtime-eval-expr (car payload) env state)))
           (body (cadr payload)))
       (dynamic-wind
         (lambda () (set! *runtime-catch-stack* (cons tag *runtime-catch-stack*)))
         (lambda ()
           (guard (e
                   ((throw-signal? e)
                    (if (eqv? (throw-signal-tag e) tag)
                        (throw-signal-value e)
                        (raise e)))
                   (else (raise e)))
             (runtime-eval-expr body env state)))
         (lambda () (set! *runtime-catch-stack* (cdr *runtime-catch-stack*))))))
    ((throw)
     (unless (and (list? payload) (= (length payload) 2))
       (runtime-raise 'invalid-ir "throw payload must be (tag value)" payload))
     (let ((tag (runtime-value->host (runtime-eval-expr (car payload) env state)))
           (value (runtime-eval-expr (cadr payload) env state)))
       (if (runtime-catch-active? tag)
           (raise (make-throw-signal tag value))
           (runtime-raise 'control-error "No enclosing catch for throw" tag))))
    ((go)
     (unless (and (list? payload) (= (length payload) 1))
       (runtime-raise 'invalid-ir "go payload must be (tag)" payload))
     (let ((tag (car payload)))
       (unless (or (symbol? tag) (integer? tag))
         (runtime-raise 'invalid-ir "go tag must be symbol or integer" tag))
       (raise (make-go-signal tag))))
    ((tagbody)
     (unless (list? payload)
       (runtime-raise 'invalid-ir "tagbody payload must be item list" payload))
     (let* ((items payload)
            (labels
             (let loop ((xs items) (idx 0) (acc '()))
               (if (null? xs)
                   (reverse acc)
                   (let ((it (car xs)))
                     (if (and (list? it) (= (length it) 2) (eq? (car it) 'label))
                         (if (assoc (cadr it) acc)
                             (runtime-raise 'invalid-ir "duplicate tagbody label" (cadr it))
                             (loop (cdr xs) (+ idx 1) (cons (cons (cadr it) idx) acc)))
                         (loop (cdr xs) (+ idx 1) acc)))))))
       (let loop ((i 0))
         (if (>= i (length items))
             (host->runtime-value '())
             (let ((it (list-ref items i)))
               (if (and (list? it) (= (length it) 2) (eq? (car it) 'label))
                   (loop (+ i 1))
                   (let ((next-i
                          (guard (e
                                  ((go-signal? e)
                                   (let ((p (assoc (go-signal-tag e) labels)))
                                     (if p
                                         (cdr p)
                                         (runtime-raise 'control-error "No enclosing tagbody label for go" (go-signal-tag e)))))
                                  (else (raise e)))
                            (if (and (list? it) (= (length it) 2) (eq? (car it) 'form))
                                (runtime-eval-expr (cadr it) env state)
                                (runtime-raise 'invalid-ir "tagbody item must be label/form pair" it))
                            (+ i 1))))
                     (loop next-i))))))))
    ((handler-case)
     (unless (and (list? payload) (= (length payload) 2))
       (runtime-raise 'invalid-ir "handler-case payload must be (protected clauses)" payload))
     (let ((protected (car payload))
           (clauses (cadr payload)))
       (unless (list? clauses)
         (runtime-raise 'invalid-ir "handler-case clauses must be list" clauses))
       (guard (e
               ;; Nonlocal control transfers are not condition errors.
               ((or (nonlocal-return? e) (throw-signal? e) (go-signal? e))
                (raise e))
               (else
                (let loop ((cs clauses))
                  (if (null? cs)
                      (raise e)
                      (let ((c (car cs)))
                        (unless (and (list? c) (= (length c) 3) (symbol? (car c)))
                          (runtime-raise 'invalid-ir "invalid handler-case clause shape" c))
                        (let ((tag (car c))
                              (var (cadr c))
                              (body (caddr c)))
                          (if (handler-case-tag-match? tag)
                              (let ((henv (make-env env)))
                                (when var
                                  (unless (symbol? var)
                                    (runtime-raise 'invalid-ir "handler-case var must be symbol or #f" var))
                                  (env-define! henv var (host->runtime-value e)))
                                (runtime-eval-expr body henv state))
                              (loop (cdr cs)))))))))
         (runtime-eval-expr protected env state))))
    ((defpackage)
     (unless (list? payload)
       (runtime-raise 'invalid-ir "defpackage payload must be list" payload))
     (host->runtime-value
      (with-module isl.core
        (eval-defpackage payload))))
    ((in-package)
     (unless (and (list? payload) (= (length payload) 1))
       (runtime-raise 'invalid-ir "in-package payload must be one argument list" payload))
     (host->runtime-value
      (with-module isl.core
        (eval-in-package payload))))
    ((defclass)
     (unless (and (list? payload) (= (length payload) 3) (symbol? (car payload)))
       (runtime-raise 'invalid-ir "defclass payload must be (name supers slots)" payload))
     (let* ((name (car payload))
            (super-forms (cadr payload))
            (slot-forms (caddr payload)))
       (unless (list? super-forms)
         (runtime-raise 'invalid-ir "defclass superclasses must be list" super-forms))
       (unless (list? slot-forms)
         (runtime-raise 'invalid-ir "defclass slots must be list" slot-forms))
       (let* ((supers
               (map (lambda (s)
                      (unless (symbol? s)
                        (runtime-raise 'invalid-ir "defclass superclass must be symbol" s))
                      (resolve-class-designator s env))
                    super-forms))
              (own-slots
               (map (lambda (slot)
                      (unless (and (list? slot) (= (length slot) 6) (eq? (car slot) 'slot-spec))
                        (runtime-raise 'invalid-ir "invalid defclass slot-spec payload" slot))
                      (make-rt-slot-spec (cadr slot) (caddr slot) (cadddr slot) (list-ref slot 4) (list-ref slot 5)))
                    slot-forms))
              (class-obj (make-rt-class name supers own-slots)))
         (env-set! env name (host->runtime-value class-obj))
         ;; Install generated readers/writers as generic methods.
         (for-each
          (lambda (s)
            (let ((slot-name (rt-slot-name s)))
              (for-each
               (lambda (reader)
                 (let* ((generic (ensure-generic-function! reader env '(obj)))
                        (reader-fn
                         (make-fn-value
                          (make-primitive
                           reader
                           (lambda (args st)
                             (unless (= (length args) 1)
                               (runtime-raise 'arity "reader expects 1 argument" args))
                             (host->runtime-value
                              (rt-instance-slot-ref (runtime-value->host (car args)) slot-name))))))
                        (method (make-rt-method (list class-obj) '(obj) reader-fn)))
                   (set-rt-generic-methods! generic (cons method (rt-generic-methods generic)))))
               (rt-slot-readers s))
              (for-each
               (lambda (writer)
                 (let* ((generic (ensure-generic-function! writer env '(obj value)))
                        (writer-fn
                         (make-fn-value
                          (make-primitive
                           writer
                           (lambda (args st)
                             (unless (= (length args) 2)
                               (runtime-raise 'arity "writer expects 2 arguments" args))
                             (let ((obj (runtime-value->host (car args)))
                                   (v (runtime-value->host (cadr args))))
                               (host->runtime-value
                                (rt-instance-slot-set! obj slot-name v)))))))
                        (method (make-rt-method (list class-obj #f) '(obj value) writer-fn)))
                   (set-rt-generic-methods! generic (cons method (rt-generic-methods generic)))))
               (rt-slot-writers s))))
          own-slots)
         (host->runtime-value name))))
    ((defgeneric)
     (unless (and (list? payload) (= (length payload) 2) (symbol? (car payload)))
       (runtime-raise 'invalid-ir "defgeneric payload must be (name params)" payload))
     (let ((name (car payload))
           (params (cadr payload)))
       (validate-params params)
       (ensure-generic-function! name env params)
       (host->runtime-value name)))
    ((defmethod)
     (unless (and (list? payload) (= (length payload) 3) (symbol? (car payload)))
       (runtime-raise 'invalid-ir "defmethod payload must be (name params body)" payload))
     (let* ((name (car payload))
            (raw-params (cadr payload))
            (body (caddr payload))
            (parsed (parse-method-params raw-params env))
            (plain-params (car parsed))
            (specializers (cadr parsed))
            (method-fn (make-fn-value (make-closure name plain-params body env)))
            (generic (ensure-generic-function! name env plain-params))
            (method (make-rt-method specializers plain-params method-fn)))
       (set-rt-generic-methods! generic (cons method (rt-generic-methods generic)))
       (host->runtime-value name)))
    (else
     (runtime-raise 'unsupported-special "special form is not yet lowered" (list op payload)))))

(define (make-runtime-state . maybe-profile)
  (let ((profile (if (null? maybe-profile) 'extended (car maybe-profile)))
        (global-env (make-env #f)))
    (env-define! global-env 'nil (host->runtime-value '()))
    (env-define! global-env 't (host->runtime-value #t))
    (env-define! global-env 'object (host->runtime-value (make-rt-class 'object '() '())))
    (install-primitives! global-env)
    (vector 'runtime-state profile global-env (host->runtime-value '()))))

(define (state-global-env state) (vector-ref state 2))
(define (state-last-value state) (vector-ref state 3))
(define (set-state-last-value! state v) (vector-set! state 3 v))

(define (runtime-eval-seq exprs env state)
  (let loop ((xs exprs) (last (host->runtime-value '())))
    (if (null? xs)
        last
        (loop (cdr xs) (runtime-eval-expr (car xs) env state)))))

(define (find-block cfg label)
  (let* ((blocks (caddr cfg))
         (p (find (lambda (b) (and (pair? b) (eq? (cadr b) label))) blocks)))
    (if p
        p
        (runtime-raise 'invalid-ir "unknown block label" label))))

(define (phi-pairs rhs)
  (if (and (pair? rhs) (eq? (car rhs) 'phi) (pair? (cdr rhs)))
      (cadr rhs)
      #f))

(define (eval-rhs rhs env state pred-label)
  (unless (and (pair? rhs) (symbol? (car rhs)))
    (runtime-raise 'invalid-ir "invalid assignment rhs" rhs))
  (case (car rhs)
    ((const)
     (if (= (length rhs) 2)
         (host->runtime-value (cadr rhs))
         (runtime-raise 'invalid-ir "const rhs expects one payload" rhs)))
    ((var)
     (if (= (length rhs) 2)
         (env-ref env (cadr rhs))
         (runtime-raise 'invalid-ir "var rhs expects one symbol" rhs)))
    ((call)
     (let ((fn (env-ref env (cadr rhs)))
           (args (map (lambda (s) (env-ref env s)) (caddr rhs))))
       (runtime-apply fn args state)))
    ((lambda)
     (if (= (length rhs) 3)
         (make-fn-value (make-closure #f (cadr rhs) (caddr rhs) env))
         (runtime-raise 'invalid-ir "lambda rhs expects params/body" rhs)))
    ((special)
     (if (= (length rhs) 3)
         (runtime-eval-special (cadr rhs) (caddr rhs) env state)
         (runtime-raise 'invalid-ir "special rhs expects op/payload" rhs)))
    ((invalid-special)
     (runtime-raise 'invalid-ir "invalid special form shape in rhs" rhs))
    ((phi)
     (let ((pairs (phi-pairs rhs)))
       (unless (list? pairs)
         (runtime-raise 'invalid-ir "phi rhs expects predecessor pairs" rhs))
       (let ((selected
              (if pred-label
                  (find (lambda (x) (and (pair? x) (eq? (car x) pred-label))) pairs)
                  #f)))
         (if selected
             (env-ref env (cadr selected))
             (if (null? pairs)
                 (runtime-raise 'invalid-ir "phi has no incoming pairs" rhs)
                 (env-ref env (cadar pairs)))))))
    (else
     (runtime-raise 'invalid-ir "unknown assignment rhs op" rhs))))

(define (exec-block-instrs instrs env state pred-label)
  (for-each
   (lambda (instr)
     (unless (and (pair? instr) (eq? (car instr) 'assign) (= (length instr) 3))
       (runtime-raise 'invalid-ir "instruction must be (assign dst rhs)" instr))
     (let ((dst (cadr instr))
           (rhs (caddr instr)))
       (unless (symbol? dst)
         (runtime-raise 'invalid-ir "assign destination must be symbol" dst))
       (env-define! env dst (eval-rhs rhs env state pred-label))))
   instrs))

(define (runtime-exec-cfg cfg env state)
  (unless (and (pair? cfg) (eq? (car cfg) 'cfg) (= (length cfg) 3))
    (runtime-raise 'invalid-ir "cfg shape must be (cfg entry blocks)" cfg))
  (let ((entry (cadr cfg)))
    (let loop ((label entry) (pred #f))
      (let* ((block (find-block cfg label))
             (instrs (caddr block))
             (term (cadddr block)))
        (exec-block-instrs instrs env state pred)
        (unless (and (pair? term) (symbol? (car term)))
          (runtime-raise 'invalid-ir "block terminator is missing or invalid" block))
        (case (car term)
          ((ret)
           (if (= (length term) 2)
               (env-ref env (cadr term))
               (runtime-raise 'invalid-ir "ret expects one value symbol" term)))
          ((jmp)
           (if (= (length term) 2)
               (loop (cadr term) label)
               (runtime-raise 'invalid-ir "jmp expects target label" term)))
          ((br)
           (if (= (length term) 4)
               (let ((cond-v (env-ref env (cadr term))))
                 (if (runtime-truthy? cond-v)
                     (loop (caddr term) label)
                     (loop (cadddr term) label)))
               (runtime-raise 'invalid-ir "br expects cond then else labels" term)))
          (else
           (runtime-raise 'invalid-ir "unknown terminator op" term)))))))

(define (runtime-apply fn-val arg-vals state)
  (let ((fn (fn-from-value fn-val)))
    (cond
     ((primitive? fn)
      ((primitive-proc fn) arg-vals state))
     ((rt-generic? fn)
      (let ((m (select-generic-method fn arg-vals)))
        (if m
            (runtime-apply (rt-method-fn m) arg-vals state)
            (runtime-raise 'invalid-ir "No applicable method for generic function" (rt-generic-name fn)))))
     ((closure? fn)
      (let ((call-env (make-env (closure-env fn))))
        (bind-params! call-env (closure-params fn) arg-vals)
        (if (eq? (closure-kind fn) 'cfg)
            (runtime-exec-cfg (closure-body fn) call-env state)
            (runtime-eval-expr (closure-body fn) call-env state))))
     (else
      (runtime-raise 'type-error "invalid function object" fn)))))

(define (runtime-eval-expr ir env state)
  (unless (and (pair? ir) (symbol? (car ir)))
    (runtime-raise 'invalid-ir "IR expression must be a tagged list" ir))
  (case (car ir)
    ((const)
     (if (= (length ir) 2)
         (host->runtime-value (cadr ir))
         (runtime-raise 'invalid-ir "const expects one payload" ir)))
    ((var)
     (if (= (length ir) 2)
         (env-ref env (cadr ir))
         (runtime-raise 'invalid-ir "var expects one symbol" ir)))
    ((if)
     (if (= (length ir) 4)
         (let ((test (runtime-eval-expr (cadr ir) env state)))
           (if (runtime-truthy? test)
               (runtime-eval-expr (caddr ir) env state)
               (runtime-eval-expr (cadddr ir) env state)))
         (runtime-raise 'invalid-ir "if expects test/then/else" ir)))
    ((seq)
     (runtime-eval-seq (cdr ir) env state))
    ((lambda)
     (if (= (length ir) 3)
         (make-fn-value (make-closure #f (cadr ir) (caddr ir) env))
         (runtime-raise 'invalid-ir "lambda expects params/body" ir)))
    ((call)
     (if (>= (length ir) 2)
         (let ((fn (runtime-eval-expr (cadr ir) env state))
               (args (map (lambda (x) (runtime-eval-expr x env state)) (cddr ir))))
           (runtime-apply fn args state))
         (runtime-raise 'invalid-ir "call expects callee" ir)))
    ((effect)
     (if (= (length ir) 2)
         (runtime-eval-expr (cadr ir) env state)
         (runtime-raise 'invalid-ir "effect expects one child" ir)))
    ((special)
     (if (= (length ir) 3)
         (runtime-eval-special (cadr ir) (caddr ir) env state)
         (runtime-raise 'invalid-ir "special node expects op/payload" ir)))
    ((invalid-special)
     (runtime-raise 'invalid-ir "invalid special form shape" ir))
    (else
     (runtime-raise 'invalid-ir "unknown IR node" ir))))

(define (runtime-eval-top top-ir state)
  (unless (and (pair? top-ir) (symbol? (car top-ir)))
    (runtime-raise 'invalid-ir "Top IR must be tagged" top-ir))
  (let ((global (state-global-env state)))
    (case (car top-ir)
      ((define-fun)
       (if (= (length top-ir) 4)
           (let ((name (cadr top-ir))
                 (params (caddr top-ir))
                 (body (cadddr top-ir)))
             (unless (symbol? name)
               (runtime-raise 'invalid-ir "define-fun name must be symbol" name))
             (let ((fn (make-fn-value (make-closure name params body global))))
               (env-define! global name fn)
               fn))
           (runtime-raise 'invalid-ir "define-fun expects name params body" top-ir)))
      ((ll-define-fun)
       (if (= (length top-ir) 4)
           (let ((name (cadr top-ir))
                 (params (caddr top-ir))
                 (cfg (cadddr top-ir)))
             (unless (symbol? name)
               (runtime-raise 'invalid-ir "ll-define-fun name must be symbol" name))
             (let ((fn (make-fn-value (make-closure/cfg name params cfg global))))
               (env-define! global name fn)
               fn))
           (runtime-raise 'invalid-ir "ll-define-fun expects name params cfg" top-ir)))
      ((define-global)
       (if (= (length top-ir) 3)
           (let ((name (cadr top-ir))
                 (expr-ir (caddr top-ir)))
             (unless (symbol? name)
               (runtime-raise 'invalid-ir "define-global name must be symbol" name))
             (let ((val (runtime-eval-expr expr-ir global state)))
               (env-define! global name val)
               val))
           (runtime-raise 'invalid-ir "define-global expects name expr" top-ir)))
      ((ll-define-global)
       (if (= (length top-ir) 3)
           (let ((name (cadr top-ir))
                 (cfg (caddr top-ir)))
             (unless (symbol? name)
               (runtime-raise 'invalid-ir "ll-define-global name must be symbol" name))
             (let ((val (runtime-exec-cfg cfg global state)))
               (env-define! global name val)
               val))
           (runtime-raise 'invalid-ir "ll-define-global expects name cfg" top-ir)))
      ((define-macro)
       ;; Macros are compile-time only and should be eliminated from executable IR.
       (host->runtime-value '()))
      ((ll-define-macro)
       ;; compile-time only
       (host->runtime-value '()))
      ((expr)
       (if (= (length top-ir) 2)
           (runtime-eval-expr (cadr top-ir) global state)
           (runtime-raise 'invalid-ir "expr expects one payload" top-ir)))
      ((ll-expr)
       (if (= (length top-ir) 2)
           (runtime-exec-cfg (cadr top-ir) global state)
           (runtime-raise 'invalid-ir "ll-expr expects one cfg payload" top-ir)))
      ((invalid-top)
       (runtime-raise 'invalid-ir "invalid top-level form" top-ir))
      (else
       (runtime-raise 'invalid-ir "unknown top-level IR node" top-ir)))))

(define (runtime-load-units! state units)
  (let loop ((xs units) (last (host->runtime-value '())))
    (if (null? xs)
        (begin
          (set-state-last-value! state last)
          last)
        (let* ((unit (car xs))
               (ll-pair (and (pair? unit) (assoc 'll (cdr unit))))
               (ir-pair (and (pair? unit) (assoc 'ir (cdr unit))))
               (top (cond
                     (ll-pair (cadr ll-pair))
                     (ir-pair (cadr ir-pair))
                     (else #f))))
          (unless top
            (runtime-raise 'invalid-unit "unit has no ll/ir field" unit))
          (loop (cdr xs)
                (guard (e
                        ((nonlocal-return? e)
                         (runtime-raise 'control-error "No enclosing block for return-from" (nonlocal-return-name e)))
                        ((throw-signal? e)
                         (runtime-raise 'control-error "No enclosing catch for throw" (throw-signal-tag e)))
                        ((go-signal? e)
                         (runtime-raise 'control-error "No enclosing tagbody for go" (go-signal-tag e)))
                        (else (raise e)))
                  (runtime-eval-top top state)))))))
