;; Minimal ISLISP core evaluator on Gauche 0.9.15.
;; The implementation keeps dependencies close to R7RS-level primitives.
(define-module isl.core
  (use srfi-1)
  (export make-initial-env eval-islisp apply-islisp repl read-all))

(select-module isl.core)

(define (truthy? v)
  (and (not (eq? v #f))
       (not (null? v))))

(define (make-frame parent)
  (vector 'frame '() parent))

(define (frame-bindings frame)
  (vector-ref frame 1))

(define (frame-parent frame)
  (vector-ref frame 2))

(define (set-frame-bindings! frame bindings)
  (vector-set! frame 1 bindings))

(define (frame-define! frame sym val)
  (let ((bindings (frame-bindings frame)))
    (let loop ((xs bindings) (acc '()))
      (cond
       ((null? xs)
        (set-frame-bindings! frame (append (reverse acc) (list (cons sym val)))))
       ((eq? (caar xs) sym)
        (set-frame-bindings! frame
                             (append (reverse acc) (cons (cons sym val) (cdr xs)))))
       (else
        (loop (cdr xs) (cons (car xs) acc)))))))

(define (frame-set! frame sym val)
  (let loop ((f frame))
    (if (not f)
        (error "Unbound variable" sym)
        (let ((pair (assoc sym (frame-bindings f))))
          (if pair
              (set-cdr! pair val)
              (loop (frame-parent f)))))))

(define (global-frame env)
  (let loop ((f env))
    (if (frame-parent f)
        (loop (frame-parent f))
        f)))

(define (frame-ref frame sym)
  (let loop ((f frame))
    (if (not f)
        (error "Unbound variable" sym)
        (let ((pair (assoc sym (frame-bindings f))))
          (if pair
              (cdr pair)
              (loop (frame-parent f)))))))

(define (frame-bound? frame sym)
  (let loop ((f frame))
    (if (not f)
        #f
        (if (assoc sym (frame-bindings f))
            #t
            (loop (frame-parent f))))))

(define (closure? obj)
  (and (vector? obj) (= (vector-length obj) 5) (eq? (vector-ref obj 0) 'closure)))

(define (make-closure params body env name)
  (vector 'closure params body env name))

(define (closure-params c) (vector-ref c 1))
(define (closure-body c) (vector-ref c 2))
(define (closure-env c) (vector-ref c 3))
(define (closure-name c) (vector-ref c 4))

(define (primitive? obj)
  (and (vector? obj) (= (vector-length obj) 3) (eq? (vector-ref obj 0) 'primitive)))

(define (make-primitive name proc)
  (vector 'primitive name proc))

(define (primitive-name p) (vector-ref p 1))
(define (primitive-proc p) (vector-ref p 2))

(define (validate-params params)
  (unless (and (list? params) (every symbol? params))
    (error "Parameter list must be a list of symbols" params)))

(define (eval-sequence forms env)
  (let loop ((xs forms) (result '()))
    (if (null? xs)
        result
        (loop (cdr xs) (eval-islisp (car xs) env)))))

(define (eval-list xs env)
  (map (lambda (x) (eval-islisp x env)) xs))

(define (write-to-string x)
  (let ((p (open-output-string)))
    (write x p)
    (get-output-string p)))

(define (display-to-string x)
  (let ((p (open-output-string)))
    (display x p)
    (get-output-string p)))

(define (render-format fmt args)
  (unless (string? fmt)
    (error "format control string must be a string" fmt))
  (let ((p (open-output-string)))
    (let loop ((i 0) (rest args))
      (if (>= i (string-length fmt))
          (begin
            (unless (null? rest)
              (error "too many arguments for format" rest))
            (get-output-string p))
          (let ((ch (string-ref fmt i)))
            (if (char=? ch #\~)
                (if (>= (+ i 1) (string-length fmt))
                    (error "unterminated format directive" fmt)
                    (let ((d (string-ref fmt (+ i 1))))
                      (cond
                       ((char=? d #\A)
                        (when (null? rest)
                          (error "too few arguments for format" fmt))
                        (display (display-to-string (car rest)) p)
                        (loop (+ i 2) (cdr rest)))
                       ((char=? d #\S)
                        (when (null? rest)
                          (error "too few arguments for format" fmt))
                        (display (write-to-string (car rest)) p)
                        (loop (+ i 2) (cdr rest)))
                       ((char=? d #\%)
                        (newline p)
                        (loop (+ i 2) rest))
                       ((char=? d #\~)
                        (write-char #\~ p)
                        (loop (+ i 2) rest))
                       (else
                        (error "unsupported format directive" d)))))
                (begin
                  (write-char ch p)
                  (loop (+ i 1) rest))))))))

(define (bind-params! frame params args)
  (cond
   ((and (null? params) (null? args))
    frame)
   ((null? params)
    (error "Too many arguments" args))
   ((null? args)
    (error "Too few arguments" params))
   (else
    (frame-define! frame (car params) (car args))
    (bind-params! frame (cdr params) (cdr args)))))

(define (apply-islisp fn args)
  (cond
   ((primitive? fn)
    (apply (primitive-proc fn) args))
   ((closure? fn)
    (let ((params (closure-params fn))
          (body (closure-body fn))
          (fenv (closure-env fn)))
      (validate-params params)
      (let ((call-env (make-frame fenv)))
        (bind-params! call-env params args)
        (eval-sequence body call-env))))
   (else
    (error "Attempt to call non-function" fn))))

(define (special-form? sym)
  (memq sym '(quote if cond case lambda defglobal defvar setq setf defun progn let let*)))

(define (eval-special form env)
  (let ((op (car form))
        (args (cdr form)))
    (case op
      ((quote)
       (if (= (length args) 1)
           (car args)
           (error "quote takes one argument" form)))
      ((if)
       (if (or (= (length args) 2) (= (length args) 3))
           (let ((test (eval-islisp (car args) env)))
             (if (truthy? test)
                 (eval-islisp (cadr args) env)
                 (if (= (length args) 3)
                     (eval-islisp (caddr args) env)
                     '())))
           (error "if takes 2 or 3 arguments" form)))
      ((cond)
       (let loop ((clauses args))
         (if (null? clauses)
             '()
             (let* ((clause (car clauses))
                    (test-form (and (pair? clause) (car clause)))
                    (body (and (pair? clause) (cdr clause))))
               (unless (and (list? clause) (not (null? clause)))
                 (error "invalid cond clause" clause))
               (let ((test-val (eval-islisp test-form env)))
                 (if (truthy? test-val)
                   (if (null? body)
                       test-val
                       (eval-sequence body env))
                   (loop (cdr clauses))))))))
      ((case)
       (if (>= (length args) 1)
           (let ((key (eval-islisp (car args) env))
                 (clauses (cdr args)))
             (let loop ((xs clauses))
               (if (null? xs)
                   '()
                   (let* ((clause (car xs))
                          (keys (and (pair? clause) (car clause)))
                          (body (and (pair? clause) (cdr clause))))
                     (unless (and (list? clause) (>= (length clause) 1))
                       (error "invalid case clause" clause))
                     (if (or (eq? keys 'otherwise) (eq? keys 't))
                         (if (null? body)
                             '()
                             (eval-sequence body env))
                         (let ((matched?
                                (if (list? keys)
                                    (any (lambda (k) (eqv? key k)) keys)
                                    (eqv? key keys))))
                           (if matched?
                               (if (null? body)
                                   '()
                                   (eval-sequence body env))
                               (loop (cdr xs)))))))))
           (error "case needs key and clauses" form)))
      ((lambda)
       (if (>= (length args) 2)
           (let ((params (car args))
                 (body (cdr args)))
             (validate-params params)
             (make-closure params body env #f))
           (error "lambda needs params and body" form)))
      ((defglobal)
       (if (= (length args) 2)
           (let ((sym (car args))
                 (val (eval-islisp (cadr args) env)))
             (unless (symbol? sym)
               (error "defglobal needs a symbol" sym))
             (let ((global (global-frame env)))
               (frame-define! global sym val)
               sym))
           (error "defglobal takes symbol and expression" form)))
      ((defvar)
       (if (= (length args) 2)
           (let ((sym (car args))
                 (global (global-frame env)))
             (unless (symbol? sym)
               (error "defvar needs a symbol" sym))
             (unless (frame-bound? global sym)
               (frame-define! global sym (eval-islisp (cadr args) env)))
             sym)
           (error "defvar takes symbol and expression" form)))
      ((setq)
       (if (= (length args) 2)
           (let ((sym (car args))
                 (val (eval-islisp (cadr args) env)))
             (unless (symbol? sym)
               (error "setq needs a symbol" sym))
             (frame-set! env sym val)
             val)
           (error "setq takes symbol and expression" form)))
      ((setf)
       (if (= (length args) 2)
           (let* ((place (car args))
                  (val (eval-islisp (cadr args) env)))
             (cond
              ((symbol? place)
               (frame-set! env place val)
               val)
              ((and (pair? place) (eq? (car place) 'car) (= (length place) 2))
               (let ((target (eval-islisp (cadr place) env)))
                 (set-car! target val)
                 val))
              ((and (pair? place) (eq? (car place) 'cdr) (= (length place) 2))
               (let ((target (eval-islisp (cadr place) env)))
                 (set-cdr! target val)
                 val))
              (else
               (error "Unsupported setf place" place))))
           (error "setf takes place and expression" form)))
      ((defun)
       (if (>= (length args) 3)
           (let ((name (car args))
                 (params (cadr args))
                 (body (cddr args)))
             (unless (symbol? name)
               (error "defun name must be symbol" name))
             (validate-params params)
             (let ((fun (make-closure params body env name)))
               (frame-define! (global-frame env) name fun)
               name))
           (error "defun needs name, params and body" form)))
      ((progn)
       (eval-sequence args env))
      ((let)
       (if (>= (length args) 2)
           (let ((bindings (car args))
                 (body (cdr args)))
             (unless (list? bindings)
               (error "let bindings must be a list" bindings))
             (let ((let-env (make-frame env)))
               (for-each
                (lambda (b)
                  (unless (and (list? b) (= (length b) 2) (symbol? (car b)))
                    (error "invalid let binding" b))
                  (frame-define! let-env (car b) (eval-islisp (cadr b) env)))
               bindings)
               (eval-sequence body let-env)))
           (error "let needs bindings and body" form)))
      ((let*)
       (if (>= (length args) 2)
           (let ((bindings (car args))
                 (body (cdr args)))
             (unless (list? bindings)
               (error "let* bindings must be a list" bindings))
             (let ((let-env (make-frame env)))
               (for-each
                (lambda (b)
                  (unless (and (list? b) (= (length b) 2) (symbol? (car b)))
                    (error "invalid let* binding" b))
                  (frame-define! let-env (car b) (eval-islisp (cadr b) let-env)))
                bindings)
               (eval-sequence body let-env)))
           (error "let* needs bindings and body" form)))
      (else
       (error "Unknown special form" op)))))

(define (eval-islisp form env)
  (cond
   ((or (number? form) (string? form) (char? form) (boolean? form)) form)
   ((symbol? form)
    (frame-ref env form))
   ((pair? form)
    (let ((op (car form))
          (args (cdr form)))
      (if (and (symbol? op) (special-form? op))
          (eval-special form env)
          (let ((fn (eval-islisp op env))
                (vals (eval-list args env)))
            (apply-islisp fn vals)))))
   ((null? form) '())
   (else
    form)))

(define (install-primitives! env)
  (define (def name proc)
    (frame-define! env name (make-primitive name proc)))

  (def '+ +)
  (def '- -)
  (def '* *)
  (def '/ /)
  (def '= =)
  (def '< <)
  (def '> >)
  (def '<= <=)
  (def '>= >=)
  (def 'cons cons)
  (def 'car car)
  (def 'cdr cdr)
  (def 'list list)
  (def 'append append)
  (def 'eq eq?)
  (def 'eql eqv?)
  (def 'equal equal?)
  (def 'null (lambda (x) (null? x)))
  (def 'atom (lambda (x) (not (pair? x))))
  (def 'numberp number?)
  (def 'symbolp symbol?)
  (def 'listp list?)
  (def 'print
    (lambda (x)
      (write x)
      (newline)
      x))
  (def 'format
    (lambda args
      (cond
       ((null? args)
        (error "format needs at least a control string"))
       ((string? (car args))
        (let ((out (render-format (car args) (cdr args))))
          (display out)
          '()))
       ((< (length args) 2)
        (error "format needs destination and control string"))
       ((eq? (car args) #t)
        (let ((out (render-format (cadr args) (cddr args))))
          (display out)
          '()))
       ((null? (car args))
        (render-format (cadr args) (cddr args)))
       (else
        (error "unsupported format destination" (car args))))))
  (def 'not
    (lambda (x)
      (if (truthy? x) #f #t)))
  (def 'apply
    (lambda (f xs)
      (apply-islisp f xs)))
  (def 'funcall
    (lambda (f . xs)
      (apply-islisp f xs)))
  (def 'exit
    (lambda args
      (apply exit args))))

(define (make-initial-env)
  (let ((env (make-frame #f)))
    (frame-define! env 'nil '())
    (frame-define! env 't #t)
    (install-primitives! env)
    env))

(define (read-all port)
  (let loop ((acc '()))
    (let ((x (read port)))
      (if (eof-object? x)
          (reverse acc)
          (loop (cons x acc))))))

(define (repl env)
  (display "ISLISP> ")
  (flush)
  (let ((x (read)))
    (if (eof-object? x)
        (begin
          (newline)
          'bye)
        (begin
          (guard (e (else
                     (display "Error: ")
                     (write e)
                     (newline)))
            (let ((result (eval-islisp x env)))
              (write result)
              (newline)))
          (repl env)))))
