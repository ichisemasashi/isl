;; Minimal ISLISP core evaluator on Gauche 0.9.15.
;; The implementation keeps dependencies close to R7RS-level primitives.
(define-module isl.core
  (use srfi-1)
  (export make-initial-env eval-islisp apply-islisp repl read-all))

(select-module isl.core)

(define (truthy? v)
  (and (not (eq? v #f))
       (not (null? v))))

(define (make-frame parent)
  (vector 'frame '() parent))

(define (frame-bindings frame)
  (vector-ref frame 1))

(define (frame-parent frame)
  (vector-ref frame 2))

(define (set-frame-bindings! frame bindings)
  (vector-set! frame 1 bindings))

(define (frame-find-pair frame sym)
  (let loop ((f frame))
    (if (not f)
        #f
        (let ((pair (assoc sym (frame-bindings f))))
          (if pair
              pair
              (loop (frame-parent f)))))))

(define (frame-define! frame sym val)
  (let ((bindings (frame-bindings frame)))
    (let loop ((xs bindings) (acc '()))
      (cond
       ((null? xs)
        (set-frame-bindings! frame (append (reverse acc) (list (cons sym val)))))
       ((eq? (caar xs) sym)
        (set-frame-bindings! frame
                             (append (reverse acc) (cons (cons sym val) (cdr xs)))))
       (else
        (loop (cdr xs) (cons (car xs) acc)))))))

(define (frame-set! frame sym val)
  (let ((pair (frame-find-pair frame sym)))
    (if pair
        (set-cdr! pair val)
        (error "Unbound variable" sym))))

(define (global-frame env)
  (let loop ((f env))
    (if (frame-parent f)
        (loop (frame-parent f))
        f)))

(define (frame-ref frame sym)
  (let ((pair (frame-find-pair frame sym)))
    (if pair
        (cdr pair)
        (error "Unbound variable" sym))))

(define (frame-bound? frame sym)
  (if (frame-find-pair frame sym) #t #f))

(define (assoc-string key alist)
  (let loop ((xs alist))
    (if (null? xs)
        #f
        (if (string=? key (caar xs))
            (car xs)
            (loop (cdr xs))))))

(define *package-registry* '())
(define *current-package* #f)

(define (make-package name)
  (vector 'package name '() '() '()))

(define (package-name pkg) (vector-ref pkg 1))
(define (package-internals pkg) (vector-ref pkg 2))
(define (package-externals pkg) (vector-ref pkg 3))
(define (package-uses pkg) (vector-ref pkg 4))
(define (set-package-internals! pkg v) (vector-set! pkg 2 v))
(define (set-package-externals! pkg v) (vector-set! pkg 3 v))
(define (set-package-uses! pkg v) (vector-set! pkg 4 v))

(define (normalize-package-name x)
  (let ((s
         (cond
          ((symbol? x) (symbol->string x))
          ((string? x) x)
          (else
           (error "package name must be symbol or string" x)))))
    (let* ((up (list->string (map char-upcase (string->list s))))
           (n (string-length up)))
      (if (and (> n 0) (char=? (string-ref up 0) #\:))
          (substring up 1 n)
          up))))

(define (find-package name)
  (let ((entry (assoc-string (normalize-package-name name) *package-registry*)))
    (and entry (cdr entry))))

(define (ensure-package! name)
  (let* ((n (normalize-package-name name))
         (p (find-package n)))
    (if p
        p
        (let ((pkg (make-package n)))
          (set! *package-registry* (cons (cons n pkg) *package-registry*))
          pkg))))

(define (package-internal-symbol pkg sym-name)
  (let ((entry (assoc-string sym-name (package-internals pkg))))
    (and entry (cdr entry))))

(define (package-external-symbol pkg sym-name)
  (let ((entry (assoc-string sym-name (package-externals pkg))))
    (and entry (cdr entry))))

(define (make-qualified-symbol pkg-name sym-name)
  (string->symbol (string-append pkg-name "::" sym-name)))

(define (package-intern! pkg sym-name)
  (let ((entry (assoc-string sym-name (package-internals pkg))))
    (if entry
        (cdr entry)
        (let ((qsym (make-qualified-symbol (package-name pkg) sym-name)))
          (set-package-internals! pkg (cons (cons sym-name qsym) (package-internals pkg)))
          qsym))))

(define (package-export! pkg sym-or-name)
  (let* ((sym-name (if (symbol? sym-or-name) (symbol->string sym-or-name) sym-or-name))
         (sym (package-intern! pkg sym-name)))
    (unless (assoc-string sym-name (package-externals pkg))
      (set-package-externals! pkg (cons (cons sym-name sym) (package-externals pkg))))
    sym))

(define (package-use! pkg used-pkg)
  (unless (memq used-pkg (package-uses pkg))
    (set-package-uses! pkg (cons used-pkg (package-uses pkg)))))

(define (package-visible-externals pkg sym-name seen)
  (if (memq pkg seen)
      '()
      (let* ((seen2 (cons pkg seen))
             (local (let ((e (package-external-symbol pkg sym-name)))
                      (if e (list e) '())))
             (from-uses
              (apply append
                     (map (lambda (u) (package-visible-externals u sym-name seen2))
                          (package-uses pkg)))))
        (delete-duplicates (append local from-uses) eq?))))

(define (package-import-symbol! pkg sym)
  (let ((name (symbol->string sym)))
    (unless (assoc-string name (package-internals pkg))
      (set-package-internals! pkg (cons (cons name sym) (package-internals pkg))))
    sym))

(define (string-find-substr s pat)
  (let ((n (string-length s))
        (m (string-length pat)))
    (let loop ((i 0))
      (cond
       ((> (+ i m) n) #f)
       ((string=? (substring s i (+ i m)) pat) i)
       (else (loop (+ i 1)))))))

(define (symbol-split-package sym)
  (let* ((s (symbol->string sym))
         (idx2 (string-find-substr s "::")))
    (if idx2
        (list (substring s 0 idx2) (substring s (+ idx2 2) (string-length s)) 'internal)
        (let ((idx1 (string-find-substr s ":")))
          (if idx1
              (list (substring s 0 idx1) (substring s (+ idx1 1) (string-length s)) 'external)
              #f)))))

(define (resolve-symbol-in-package sym)
  (let ((split (symbol-split-package sym)))
    (if split
        (let* ((pkg (find-package (car split)))
               (name (cadr split))
               (kind (caddr split)))
          (unless pkg
            (error "Unknown package" (car split)))
          (if (eq? kind 'internal)
              (package-intern! pkg name)
              (let ((x (package-external-symbol pkg name)))
                (unless x
                  (error "Symbol is not exported" sym))
                x)))
        (let* ((name (symbol->string sym))
               (here *current-package*)
               (internal (and here (or (package-internal-symbol here name)
                                       (package-external-symbol here name)))))
          (if internal
              internal
              (let ((hits
                     (if here
                         (delete-duplicates
                          (apply append
                                 (map (lambda (pkg)
                                        (package-visible-externals pkg name '()))
                                      (package-uses here)))
                          eq?)
                         '())))
                (cond
                 ((null? hits) (if here (package-intern! here name) sym))
                 ((null? (cdr hits)) (car hits))
                 (else (error "Ambiguous symbol reference" sym)))))))))

(define (resolve-binding-symbol sym)
  (unless (symbol? sym)
    (error "binding name must be symbol" sym))
  (when (keyword-symbol? sym)
    (error "keyword cannot be used as binding name" sym))
  (resolve-symbol-in-package sym))

(define (closure? obj)
  (and (vector? obj) (= (vector-length obj) 5) (eq? (vector-ref obj 0) 'closure)))

(define (make-closure params body env name)
  (vector 'closure params body env name))

(define (closure-params c) (vector-ref c 1))
(define (closure-body c) (vector-ref c 2))
(define (closure-env c) (vector-ref c 3))
(define (closure-name c) (vector-ref c 4))

(define (primitive? obj)
  (and (vector? obj) (= (vector-length obj) 3) (eq? (vector-ref obj 0) 'primitive)))

(define (make-primitive name proc)
  (vector 'primitive name proc))

(define (primitive-name p) (vector-ref p 1))
(define (primitive-proc p) (vector-ref p 2))

(define (macro? obj)
  (and (vector? obj) (= (vector-length obj) 5) (eq? (vector-ref obj 0) 'macro)))

(define (make-macro params body env name)
  (vector 'macro params body env name))

(define (macro-params m) (vector-ref m 1))
(define (macro-body m) (vector-ref m 2))
(define (macro-env m) (vector-ref m 3))
(define (macro-name m) (vector-ref m 4))

(define (validate-params params)
  (parse-params params)
  params)

(define (parse-params params)
  (unless (list? params)
    (error "Parameter list must be a list" params))
  (let loop ((xs params)
             (mode 'required)
             (required '())
             (optional '()))
    (if (null? xs)
        (list (reverse required) (reverse optional))
        (let ((x (car xs)))
          (cond
           ((eq? x '&optional)
            (when (eq? mode 'optional)
              (error "Duplicate &optional in parameter list" params))
            (loop (cdr xs) 'optional required optional))
           ((eq? mode 'required)
            (unless (symbol? x)
              (error "Required parameter must be a symbol" x))
            (loop (cdr xs) mode (cons x required) optional))
           (else
            (cond
             ((symbol? x)
              (loop (cdr xs) mode required (cons (list x #f '()) optional)))
             ((and (list? x) (= (length x) 2) (symbol? (car x)))
              (loop (cdr xs) mode required (cons (list (car x) #t (cadr x)) optional)))
             (else
              (error "Invalid &optional parameter specifier" x)))))))))

(define (tail-call? obj)
  (and (vector? obj) (= (vector-length obj) 3) (eq? (vector-ref obj 0) 'tail-call)))

(define (make-tail-call fn args)
  (vector 'tail-call fn args))

(define (tail-call-fn tc) (vector-ref tc 1))
(define (tail-call-args tc) (vector-ref tc 2))

(define *block-stack* '())

(define (keyword-symbol? sym)
  (and (symbol? sym)
       (> (string-length (symbol->string sym)) 0)
       (char=? (string-ref (symbol->string sym) 0) #\:)))

(define (go-signal? obj)
  (and (vector? obj) (= (vector-length obj) 2) (eq? (vector-ref obj 0) 'go-signal)))

(define (make-go-signal tag)
  (vector 'go-signal tag))

(define (go-signal-tag s) (vector-ref s 1))

(define (force-value v)
  (let loop ((x v))
    (if (tail-call? x)
        (loop (apply-islisp (tail-call-fn x) (tail-call-args x)))
        x)))

(define (eval-sequence* forms env tail?)
  (let loop ((xs forms))
    (cond
     ((null? xs) '())
     ((null? (cdr xs))
      (eval-islisp* (car xs) env tail?))
     (else
      (force-value (eval-islisp* (car xs) env #f))
      (loop (cdr xs))))))

(define (eval-sequence forms env)
  (force-value (eval-sequence* forms env #f)))

(define (eval-list xs env)
  (map (lambda (x) (force-value (eval-islisp* x env #f))) xs))

(define (write-to-string x)
  (let ((p (open-output-string)))
    (write x p)
    (get-output-string p)))

(define (display-to-string x)
  (let ((p (open-output-string)))
    (display x p)
    (get-output-string p)))

(define (render-format fmt args)
  (unless (string? fmt)
    (error "format control string must be a string" fmt))
  (let ((p (open-output-string)))
    (let loop ((i 0) (rest args))
      (if (>= i (string-length fmt))
          (begin
            (unless (null? rest)
              (error "too many arguments for format" rest))
            (get-output-string p))
          (let ((ch (string-ref fmt i)))
            (if (char=? ch #\~)
                (if (>= (+ i 1) (string-length fmt))
                    (error "unterminated format directive" fmt)
                    (let ((d (string-ref fmt (+ i 1))))
                      (cond
                       ((char=? d #\A)
                        (when (null? rest)
                          (error "too few arguments for format" fmt))
                        (display (display-to-string (car rest)) p)
                        (loop (+ i 2) (cdr rest)))
                       ((char=? d #\S)
                        (when (null? rest)
                          (error "too few arguments for format" fmt))
                        (display (write-to-string (car rest)) p)
                        (loop (+ i 2) (cdr rest)))
                       ((char=? d #\%)
                        (newline p)
                        (loop (+ i 2) rest))
                       ((char=? d #\~)
                        (write-char #\~ p)
                        (loop (+ i 2) rest))
                       (else
                        (error "unsupported format directive" d)))))
                (begin
                  (write-char ch p)
                  (loop (+ i 1) rest))))))))

(define (ensure-string x who)
  (unless (string? x)
    (error who "needs a string" x)))

(define (ensure-nonnegative-integer x who)
  (unless (and (integer? x) (>= x 0))
    (error who "needs a non-negative integer" x)))

(define (isl-substring s start end)
  (ensure-string s "substring")
  (ensure-nonnegative-integer start "substring")
  (ensure-nonnegative-integer end "substring")
  (let ((n (string-length s)))
    (when (> start end)
      (error "substring start must be <= end" start end))
    (when (> end n)
      (error "substring end out of range" end n))
    (substring s start end)))

(define (isl-length x)
  (cond
   ((string? x) (string-length x))
   ((list? x) (length x))
   ((vector? x) (vector-length x))
   (else
    (error "length supports string/list/vector only" x))))

(define (eval-while args env who)
  (if (>= (length args) 1)
      (let ((test-form (car args))
            (body (cdr args)))
        (let loop ()
          (if (truthy? (eval-islisp test-form env))
              (begin
                (eval-sequence body env)
                (loop))
              '())))
      (error who "needs test expression and optional body" args)))

(define (eval-loop args env)
  (let ((for-var #f)
        (start-form #f)
        (end-form #f)
        (until-form #f)
        (body '()))
    (let parse ((xs args))
      (cond
       ((null? xs) 'done)
       ((eq? (car xs) 'for)
        (when for-var
          (error "loop for clause appears multiple times" args))
        (unless (and (pair? (cdr xs))
                     (pair? (cddr xs))
                     (pair? (cdddr xs))
                     (pair? (cddddr xs))
                     (pair? (cddddr (cdr xs)))
                     (symbol? (cadr xs))
                     (eq? (caddr xs) 'from)
                     (eq? (car (cddddr xs)) 'to))
          (error "invalid loop for clause" xs))
        (set! for-var (cadr xs))
        (set! start-form (cadddr xs))
        (set! end-form (cadr (cddddr xs)))
        (parse (cddr (cddddr xs))))
       ((eq? (car xs) 'until)
        (when until-form
          (error "loop until clause appears multiple times" args))
        (unless (pair? (cdr xs))
          (error "loop until clause needs a test form" xs))
        (set! until-form (cadr xs))
        (parse (cddr xs)))
       ((eq? (car xs) 'do)
        (set! body (cdr xs)))
       (else
        (error "unknown loop clause" (car xs)))))
    (unless (or for-var until-form)
      (error "loop needs at least for-clause or until-clause" args))
    (let ((loop-env (make-frame env)))
      (if for-var
          (let ((start (eval-islisp start-form env))
                (end (eval-islisp end-form env)))
            (unless (and (integer? start) (integer? end))
              (error "loop from/to currently requires integers" start end))
            (frame-define! loop-env for-var start)
            (let loop-iter ()
              (let ((i (frame-ref loop-env for-var)))
                (if (> i end)
                    '()
                    (if (and until-form (truthy? (eval-islisp until-form loop-env)))
                        '()
                        (begin
                          (eval-sequence body loop-env)
                          (frame-set! loop-env for-var (+ i 1))
                          (loop-iter)))))))
          (let loop-iter ()
            (if (and until-form (truthy? (eval-islisp until-form loop-env)))
                '()
                (begin
                  (eval-sequence body loop-env)
                  (loop-iter))))))))

(define (eval-tagbody args env)
  (let ((items args))
    (let make-labels ((xs items) (idx 0) (acc '()))
      (if (null? xs)
          (let ((labels (reverse acc))
                (len (length items)))
            (let loop ((i 0))
              (if (>= i len)
                  '()
                  (let ((item (list-ref items i)))
                    (if (or (symbol? item) (integer? item))
                        (loop (+ i 1))
                        (let ((next-i
                               (guard (e
                                       ((go-signal? e)
                                        (let ((p (assoc (go-signal-tag e) labels)))
                                          (if p
                                              (cdr p)
                                              (raise e))))
                                       (else
                                        (raise e)))
                                 (force-value (eval-islisp* item env #f))
                                 (+ i 1))))
                          (loop next-i)))))))
          (let ((x (car xs)))
            (if (or (symbol? x) (integer? x))
                (if (assoc x acc)
                    (error "duplicate tagbody label" x)
                    (make-labels (cdr xs) (+ idx 1) (cons (cons x idx) acc)))
                (make-labels (cdr xs) (+ idx 1) acc)))))))

(define (eval-block args env tail?)
  (if (>= (length args) 1)
      (let ((name (resolve-binding-symbol (car args)))
            (body (cdr args)))
        (unless (symbol? name)
          (error "block name must be a symbol" name))
        (call/cc
         (lambda (escape)
           (dynamic-wind
             (lambda ()
               (set! *block-stack* (cons (cons name escape) *block-stack*)))
             (lambda ()
               (eval-sequence* body env tail?))
             (lambda ()
               (set! *block-stack* (cdr *block-stack*)))))))
      (error "block needs name and optional body" args)))

(define (init-do-bindings bindings env do-env)
  (for-each
   (lambda (b)
     (unless (and (list? b) (>= (length b) 2) (<= (length b) 3) (symbol? (car b)))
       (error "invalid do binding" b))
     (frame-define! do-env (car b) (eval-islisp (cadr b) env)))
   bindings))

(define (step-do-bindings! bindings do-env)
  (let ((nexts
         (map
          (lambda (b)
            (let ((sym (car b)))
              (cons sym
                    (if (= (length b) 3)
                        (eval-islisp (caddr b) do-env)
                        (frame-ref do-env sym)))))
          bindings)))
    (for-each (lambda (p) (frame-set! do-env (car p) (cdr p))) nexts)))

(define (eval-do args env tail?)
  (if (>= (length args) 2)
      (let ((bindings (car args))
            (end-clause (cadr args))
            (body (cddr args)))
        (unless (list? bindings)
          (error "do bindings must be a list" bindings))
        (unless (and (list? end-clause) (not (null? end-clause)))
          (error "do end clause must be (test . result-forms)" end-clause))
        (let ((test-form (car end-clause))
              (result-forms (cdr end-clause))
              (do-env (make-frame env)))
          (init-do-bindings bindings env do-env)
          (let loop ()
            (if (truthy? (eval-islisp test-form do-env))
                (if (null? result-forms)
                    '()
                    (if tail?
                        (eval-sequence* result-forms do-env #t)
                        (eval-sequence result-forms do-env)))
                (begin
                  (eval-sequence body do-env)
                  (step-do-bindings! bindings do-env)
                  (loop))))))
      (error "do needs bindings, end clause and optional body" args)))

(define (eval-dolist args env tail?)
  (if (>= (length args) 1)
      (let ((spec (car args))
            (body (cdr args)))
        (unless (and (list? spec) (>= (length spec) 2) (<= (length spec) 3) (symbol? (car spec)))
          (error "dolist spec must be (var list [result])" spec))
        (let* ((var (car spec))
               (list-form (cadr spec))
               (result-form (and (= (length spec) 3) (caddr spec)))
               (values (eval-islisp list-form env))
               (loop-env (make-frame env)))
          (unless (list? values)
            (error "dolist requires a list value" values))
          (frame-define! loop-env var '())
          (for-each
           (lambda (v)
             (frame-set! loop-env var v)
             (eval-sequence body loop-env))
           values)
          (frame-set! loop-env var '())
          (if result-form
              (if tail?
                  (eval-islisp* result-form loop-env #t)
                  (eval-islisp result-form loop-env))
              '())))
      (error "dolist needs (var list [result]) and optional body" args)))

(define (eval-dotimes args env tail?)
  (if (>= (length args) 1)
      (let ((spec (car args))
            (body (cdr args)))
        (unless (and (list? spec) (>= (length spec) 2) (<= (length spec) 3) (symbol? (car spec)))
          (error "dotimes spec must be (var count [result])" spec))
        (let* ((var (car spec))
               (count (eval-islisp (cadr spec) env))
               (result-form (and (= (length spec) 3) (caddr spec)))
               (loop-env (make-frame env)))
          (unless (and (integer? count) (>= count 0))
            (error "dotimes count must be a non-negative integer" count))
          (frame-define! loop-env var 0)
          (let loop ((i 0))
            (if (< i count)
                (begin
                  (frame-set! loop-env var i)
                  (eval-sequence body loop-env)
                  (loop (+ i 1)))
                (begin
                  (frame-set! loop-env var count)
                  (if result-form
                      (if tail?
                          (eval-islisp* result-form loop-env #t)
                          (eval-islisp result-form loop-env))
                      '()))))))
      (error "dotimes needs (var count [result]) and optional body" args)))

(define (eval-defpackage args)
  (unless (>= (length args) 1)
    (error "defpackage needs package name" args))
  (let* ((name (car args))
         (pkg (ensure-package! name)))
    (for-each
     (lambda (opt)
       (unless (and (list? opt) (not (null? opt)))
         (error "invalid defpackage option" opt))
       (let ((tag (car opt))
             (vals (cdr opt)))
         (cond
          ((eq? tag ':use)
           (for-each
            (lambda (x)
              (package-use! pkg (ensure-package! x)))
            vals))
          ((eq? tag ':export)
           (for-each
            (lambda (x)
              (unless (symbol? x)
                (error "defpackage :export expects symbols" x))
              (package-export! pkg x))
            vals))
          (else
           (error "unsupported defpackage option" tag)))))
     (cdr args))
    (string->symbol (package-name pkg))))

(define (eval-in-package args)
  (unless (= (length args) 1)
    (error "in-package takes exactly one argument" args))
  (let ((pkg (find-package (car args))))
    (unless pkg
      (error "Unknown package in in-package" (car args)))
    (set! *current-package* pkg)
    (string->symbol (package-name pkg))))

(define (bind-params! frame param-spec args)
  (let ((required (car param-spec))
        (optional (cadr param-spec)))
    (when (< (length args) (length required))
      (error "Too few arguments" args))
    (let bind-required ((rs required) (as args))
      (if (null? rs)
          (let bind-optional ((os optional) (rest as))
            (if (null? os)
                (if (null? rest)
                    frame
                    (error "Too many arguments" rest))
                (let* ((entry (car os))
                       (sym (car entry))
                       (has-init (cadr entry))
                       (init-form (caddr entry)))
                  (if (null? rest)
                      (begin
                        (frame-define! frame
                                       sym
                                       (if has-init
                                           (force-value (eval-islisp* init-form frame #f))
                                           '()))
                        (bind-optional (cdr os) rest))
                      (begin
                        (frame-define! frame sym (car rest))
                        (bind-optional (cdr os) (cdr rest)))))))
          (begin
            (frame-define! frame (car rs) (car as))
            (bind-required (cdr rs) (cdr as)))))))

(define (apply-macro m raw-args)
  (let ((params (macro-params m))
        (body (macro-body m))
        (menv (macro-env m)))
    (let ((param-spec (parse-params params))
          (call-env (make-frame menv)))
      (bind-params! call-env param-spec raw-args)
      (force-value (eval-sequence* body call-env #t)))))

(define (apply-islisp fn args)
  (let loop ((current-fn fn)
             (current-args args))
    (cond
     ((primitive? current-fn)
      (apply (primitive-proc current-fn) current-args))
     ((closure? current-fn)
      (let ((params (closure-params current-fn))
            (body (closure-body current-fn))
            (fenv (closure-env current-fn))
            (fname (closure-name current-fn)))
        (let ((param-spec (parse-params params)))
        (let ((call-env (make-frame fenv)))
          (bind-params! call-env param-spec current-args)
          (let ((result
                 (if fname
                     (call/cc
                      (lambda (escape)
                        (dynamic-wind
                          (lambda ()
                            (set! *block-stack* (cons (cons fname escape) *block-stack*)))
                          (lambda ()
                            (eval-sequence* body call-env #t))
                          (lambda ()
                            (set! *block-stack* (cdr *block-stack*))))))
                     (eval-sequence* body call-env #t))))
            (if (tail-call? result)
                (loop (tail-call-fn result) (tail-call-args result))
                result))))))
     (else
      (error "Attempt to call non-function" current-fn)))))

(define (special-form? sym)
  (memq sym '(quote if cond case loop while do dolist dotimes return-from go tagbody lambda defpackage in-package defglobal defvar setq setf defun defmacro progn block let let*)))

(define (eval-special form env tail?)
  (let ((op (car form))
        (args (cdr form)))
    (case op
      ((quote)
       (if (= (length args) 1)
           (car args)
           (error "quote takes one argument" form)))
      ((if)
       (if (or (= (length args) 2) (= (length args) 3))
           (let ((test (eval-islisp* (car args) env #f)))
             (if (truthy? test)
                 (eval-islisp* (cadr args) env tail?)
                 (if (= (length args) 3)
                     (eval-islisp* (caddr args) env tail?)
                     '())))
           (error "if takes 2 or 3 arguments" form)))
      ((cond)
       (let loop ((clauses args))
         (if (null? clauses)
             '()
             (let* ((clause (car clauses))
                    (test-form (and (pair? clause) (car clause)))
                    (body (and (pair? clause) (cdr clause))))
               (unless (and (list? clause) (not (null? clause)))
                 (error "invalid cond clause" clause))
               (let ((test-val (eval-islisp* test-form env #f)))
                 (if (truthy? test-val)
                   (if (null? body)
                       test-val
                       (eval-sequence* body env tail?))
                   (loop (cdr clauses))))))))
      ((case)
       (if (>= (length args) 1)
           (let ((key (eval-islisp* (car args) env #f))
                 (clauses (cdr args)))
             (let loop ((xs clauses))
               (if (null? xs)
                   '()
                   (let* ((clause (car xs))
                          (keys (and (pair? clause) (car clause)))
                          (body (and (pair? clause) (cdr clause))))
                     (unless (and (list? clause) (>= (length clause) 1))
                       (error "invalid case clause" clause))
                     (if (or (eq? keys 'otherwise) (eq? keys 't))
                         (if (null? body)
                             '()
                             (eval-sequence* body env tail?))
                         (let ((matched?
                                (if (list? keys)
                                    (any (lambda (k) (eqv? key k)) keys)
                                    (eqv? key keys))))
                           (if matched?
                               (if (null? body)
                                   '()
                                   (eval-sequence* body env tail?))
                               (loop (cdr xs)))))))))
           (error "case needs key and clauses" form)))
      ((loop)
       (eval-loop args env))
      ((while)
       (eval-while args env "while"))
      ((do)
       (eval-do args env tail?))
      ((dolist)
       (eval-dolist args env tail?))
      ((dotimes)
       (eval-dotimes args env tail?))
      ((return-from)
       (if (or (= (length args) 1) (= (length args) 2))
           (let* ((name (resolve-binding-symbol (car args)))
                  (value (if (= (length args) 2)
                             (eval-islisp* (cadr args) env #f)
                             '())))
             (unless (symbol? name)
               (error "return-from name must be a symbol" name))
             (let ((entry (assoc name *block-stack*)))
               (unless entry
                 (error "No enclosing block for return-from" name))
               ((cdr entry) value)))
           (error "return-from takes block-name and optional value" form)))
      ((go)
       (if (= (length args) 1)
           (let ((tag (car args)))
             (unless (or (symbol? tag) (integer? tag))
               (error "go tag must be a symbol or integer" tag))
             (raise (make-go-signal tag)))
           (error "go takes one tag argument" form)))
      ((tagbody)
       (eval-tagbody args env))
      ((lambda)
       (if (>= (length args) 2)
           (let ((params (car args))
                 (body (cdr args)))
             (validate-params params)
             (make-closure params body env #f))
           (error "lambda needs params and body" form)))
      ((defglobal)
       (if (= (length args) 2)
           (let ((sym (resolve-binding-symbol (car args)))
                 (val (eval-islisp* (cadr args) env #f)))
             (unless (symbol? sym)
               (error "defglobal needs a symbol" sym))
             (let ((global (global-frame env)))
               (frame-define! global sym val)
               sym))
           (error "defglobal takes symbol and expression" form)))
      ((defvar)
       (if (= (length args) 2)
           (let ((sym (resolve-binding-symbol (car args)))
                 (global (global-frame env)))
             (unless (symbol? sym)
               (error "defvar needs a symbol" sym))
             (unless (frame-bound? global sym)
               (frame-define! global sym (eval-islisp* (cadr args) env #f)))
             sym)
           (error "defvar takes symbol and expression" form)))
      ((setq)
       (if (= (length args) 2)
           (let* ((raw (car args))
                  (sym (if (frame-bound? env raw)
                           raw
                           (resolve-binding-symbol raw)))
                 (val (eval-islisp* (cadr args) env #f)))
             (unless (symbol? sym)
               (error "setq needs a symbol" sym))
             (frame-set! env sym val)
             val)
           (error "setq takes symbol and expression" form)))
      ((setf)
       (if (= (length args) 2)
           (let* ((place (car args))
                  (val (eval-islisp* (cadr args) env #f)))
             (cond
              ((symbol? place)
               (frame-set! env
                           (if (frame-bound? env place)
                               place
                               (resolve-binding-symbol place))
                           val)
               val)
              ((and (pair? place) (eq? (car place) 'car) (= (length place) 2))
               (let ((target (eval-islisp* (cadr place) env #f)))
                 (set-car! target val)
                 val))
              ((and (pair? place) (eq? (car place) 'cdr) (= (length place) 2))
               (let ((target (eval-islisp* (cadr place) env #f)))
                 (set-cdr! target val)
                 val))
              (else
               (error "Unsupported setf place" place))))
           (error "setf takes place and expression" form)))
      ((defun)
       (if (>= (length args) 3)
           (let ((name (resolve-binding-symbol (car args)))
                 (params (cadr args))
                 (body (cddr args)))
             (unless (symbol? name)
               (error "defun name must be symbol" name))
             (validate-params params)
             (let ((fun (make-closure params body env name)))
               (frame-define! (global-frame env) name fun)
               name))
           (error "defun needs name, params and body" form)))
      ((defmacro)
       (if (>= (length args) 3)
           (let ((name (resolve-binding-symbol (car args)))
                 (params (cadr args))
                 (body (cddr args)))
             (unless (symbol? name)
               (error "defmacro name must be symbol" name))
             (validate-params params)
             (let ((m (make-macro params body env name)))
               (frame-define! (global-frame env) name m)
               name))
           (error "defmacro needs name, params and body" form)))
      ((defpackage)
       (eval-defpackage args))
      ((in-package)
       (eval-in-package args))
      ((progn)
       (eval-sequence* args env tail?))
      ((block)
       (eval-block args env tail?))
      ((let)
       (if (>= (length args) 2)
           (let ((bindings (car args))
                 (body (cdr args)))
             (unless (list? bindings)
               (error "let bindings must be a list" bindings))
             (let ((let-env (make-frame env)))
               (for-each
               (lambda (b)
                  (unless (and (list? b) (= (length b) 2) (symbol? (car b)))
                    (error "invalid let binding" b))
                  (frame-define! let-env (car b) (eval-islisp* (cadr b) env #f)))
               bindings)
               (eval-sequence* body let-env tail?)))
           (error "let needs bindings and body" form)))
      ((let*)
       (if (>= (length args) 2)
           (let ((bindings (car args))
                 (body (cdr args)))
             (unless (list? bindings)
               (error "let* bindings must be a list" bindings))
             (let ((let-env (make-frame env)))
               (for-each
                (lambda (b)
                  (unless (and (list? b) (= (length b) 2) (symbol? (car b)))
                    (error "invalid let* binding" b))
                  (frame-define! let-env (car b) (eval-islisp* (cadr b) let-env #f)))
                bindings)
               (eval-sequence* body let-env tail?)))
           (error "let* needs bindings and body" form)))
      (else
       (error "Unknown special form" op)))))

(define (eval-islisp* form env tail?)
  (cond
   ((or (number? form) (string? form) (char? form) (boolean? form)) form)
   ((symbol? form)
    (if (keyword-symbol? form)
        form
        (let ((pair (frame-find-pair env form)))
          (if pair
              (cdr pair)
              (frame-ref env (resolve-symbol-in-package form))))))
   ((pair? form)
    (let ((op (car form))
          (args (cdr form)))
      (if (and (symbol? op) (special-form? op))
          (eval-special form env tail?)
          (let* ((op-sym (and (symbol? op)
                              (if (frame-bound? env op)
                                  op
                                  (resolve-symbol-in-package op))))
                 (op-pair (and op-sym (frame-find-pair env op-sym)))
                 (op-val (and op-pair (cdr op-pair))))
            (if (and op-pair (macro? op-val))
                (eval-islisp* (apply-macro op-val args) env tail?)
                (let ((fn (eval-islisp* op env #f))
                      (vals (eval-list args env)))
                  (if tail?
                      (make-tail-call fn vals)
                      (apply-islisp fn vals))))))))
   ((null? form) '())
   (else
    form)))

(define (eval-islisp form env)
  (force-value (eval-islisp* form env #t)))

(define (install-primitives! env)
  (define (def name proc)
    (let ((sym (resolve-binding-symbol name)))
      (frame-define! env sym (make-primitive name proc))
      (when *current-package*
        (package-export! *current-package* name))))

  (def '+ +)
  (def '- -)
  (def '* *)
  (def '/ /)
  (def 'mod modulo)
  (def 'floor floor)
  (def 'ceiling ceiling)
  (def 'truncate truncate)
  (def 'round round)
  (def '= =)
  (def '< <)
  (def '> >)
  (def '<= <=)
  (def '>= >=)
  (def 'cons cons)
  (def 'car car)
  (def 'cdr cdr)
  (def 'list list)
  (def 'append append)
  (def 'mapcar
    (lambda (f xs)
      (unless (list? xs)
        (error "mapcar needs a list as second argument" xs))
      (map (lambda (x) (apply-islisp f (list x))) xs)))
  (def 'reduce
    (lambda args
      (unless (or (= (length args) 2) (= (length args) 3))
        (error "reduce takes function, list, and optional initial-value" args))
      (let ((f (car args))
            (xs (cadr args))
            (has-init (= (length args) 3))
            (init (if (= (length args) 3) (caddr args) '())))
        (unless (list? xs)
          (error "reduce needs a list as second argument" xs))
        (if has-init
            (let loop ((acc init) (rest xs))
              (if (null? rest)
                  acc
                  (loop (apply-islisp f (list acc (car rest)))
                        (cdr rest))))
            (if (null? xs)
                (error "reduce on empty list needs initial-value")
                (let loop ((acc (car xs)) (rest (cdr xs)))
                  (if (null? rest)
                      acc
                      (loop (apply-islisp f (list acc (car rest)))
                            (cdr rest)))))))))
  (def 'remove-if
    (lambda (pred xs)
      (unless (list? xs)
        (error "remove-if needs a list as second argument" xs))
      (let loop ((rest xs) (acc '()))
        (if (null? rest)
            (reverse acc)
            (let ((v (car rest)))
              (if (truthy? (apply-islisp pred (list v)))
                  (loop (cdr rest) acc)
                  (loop (cdr rest) (cons v acc))))))))
  (def 'remove-if-not
    (lambda (pred xs)
      (unless (list? xs)
        (error "remove-if-not needs a list as second argument" xs))
      (let loop ((rest xs) (acc '()))
        (if (null? rest)
            (reverse acc)
            (let ((v (car rest)))
              (if (truthy? (apply-islisp pred (list v)))
                  (loop (cdr rest) (cons v acc))
                  (loop (cdr rest) acc)))))))
  (def 'find
    (lambda args
      (unless (>= (length args) 2)
        (error "find needs item and sequence" args))
      (let ((item (car args))
            (seq (cadr args))
            (opts (cddr args))
            (test #f)
            (key #f))
        (let parse ((rest opts))
          (unless (null? rest)
            (unless (pair? (cdr rest))
              (error "find keyword arguments must be pairs" rest))
            (let ((k (car rest))
                  (v (cadr rest)))
              (cond
               ((eq? k ':test) (set! test v))
               ((eq? k ':key) (set! key v))
               (else (error "unknown find keyword" k))))
            (parse (cddr rest))))
        (letrec
            ((apply-key
              (lambda (x)
                (if key
                    (apply-islisp key (list x))
                    x)))
             (match?
              (lambda (x)
                (if test
                    (truthy? (apply-islisp test (list item (apply-key x))))
                    (eqv? item (apply-key x))))))
          (cond
           ((list? seq)
            (let loop ((rest seq))
              (if (null? rest)
                  '()
                  (let ((v (car rest)))
                    (if (match? v)
                        v
                        (loop (cdr rest)))))))
           ((vector? seq)
            (let loop ((i 0) (n (vector-length seq)))
              (if (>= i n)
                  '()
                  (let ((v (vector-ref seq i)))
                    (if (match? v)
                        v
                        (loop (+ i 1) n))))))
           ((string? seq)
            (let loop ((i 0) (n (string-length seq)))
              (if (>= i n)
                  '()
                  (let ((v (string-ref seq i)))
                    (if (match? v)
                        v
                        (loop (+ i 1) n))))))
           (else
            (error "find needs list/vector/string as sequence" seq)))))))
  (def 'eq eq?)
  (def 'eql eqv?)
  (def 'equal equal?)
  (def 'null (lambda (x) (null? x)))
  (def 'atom (lambda (x) (not (pair? x))))
  (def 'numberp number?)
  (def 'zerop zero?)
  (def 'plusp
    (lambda (x)
      (> x 0)))
  (def 'minusp
    (lambda (x)
      (< x 0)))
  (def 'evenp
    (lambda (x)
      (unless (integer? x)
        (error "evenp needs an integer" x))
      (zero? (modulo x 2))))
  (def 'oddp
    (lambda (x)
      (unless (integer? x)
        (error "oddp needs an integer" x))
      (not (zero? (modulo x 2)))))
  (def 'symbolp symbol?)
  (def 'listp list?)
  (def 'string=
    (lambda (a b)
      (ensure-string a "string=")
      (ensure-string b "string=")
      (string=? a b)))
  (def 'string-concat
    (lambda xs
      (for-each (lambda (x) (ensure-string x "string-concat")) xs)
      (apply string-append xs)))
  (def 'substring
    (lambda args
      (cond
       ((= (length args) 2)
        (isl-substring (car args) (cadr args) (string-length (car args))))
       ((= (length args) 3)
        (isl-substring (car args) (cadr args) (caddr args)))
       (else
        (error "substring takes string start [end]" args)))))
  (def 'length isl-length)
  (def 'print
    (lambda (x)
      (write x)
      (newline)
      x))
  (def 'format
    (lambda args
      (cond
       ((null? args)
        (error "format needs at least a control string"))
       ((string? (car args))
        (let ((out (render-format (car args) (cdr args))))
          (display out)
          '()))
       ((< (length args) 2)
        (error "format needs destination and control string"))
       ((eq? (car args) #t)
        (let ((out (render-format (cadr args) (cddr args))))
          (display out)
          '()))
       ((null? (car args))
        (render-format (cadr args) (cddr args)))
       (else
        (error "unsupported format destination" (car args))))))
  (def 'not
    (lambda (x)
      (if (truthy? x) #f #t)))
  (def 'apply
    (lambda (f xs)
      (apply-islisp f xs)))
  (def 'funcall
    (lambda (f . xs)
      (apply-islisp f xs)))
  (def 'current-package
    (lambda ()
      (string->symbol (package-name *current-package*))))
  (def 'find-package
    (lambda (name)
      (let ((p (find-package name)))
        (if p
            (string->symbol (package-name p))
            '()))))
  (def 'use-package
    (lambda args
      (unless (or (= (length args) 1) (= (length args) 2))
        (error "use-package takes package-name and optional target-package" args))
      (let* ((used (ensure-package! (car args)))
             (target (if (= (length args) 2)
                         (ensure-package! (cadr args))
                         *current-package*)))
        (package-use! target used)
        #t)))
  (def 'export
    (lambda args
      (unless (or (= (length args) 1) (= (length args) 2))
        (error "export takes symbol(s) and optional package-name" args))
      (let ((syms (car args))
            (pkg (if (= (length args) 2)
                     (ensure-package! (cadr args))
                     *current-package*)))
        (cond
         ((symbol? syms)
          (package-export! pkg syms))
         ((list? syms)
          (for-each
           (lambda (s)
             (unless (symbol? s)
               (error "export list must contain symbols" s))
             (package-export! pkg s))
           syms))
         (else
          (error "export expects symbol or list of symbols" syms)))
        #t)))
  (def 'intern
    (lambda args
      (unless (or (= (length args) 1) (= (length args) 2))
        (error "intern takes name and optional package-name" args))
      (let* ((name-arg (car args))
             (name (cond
                    ((symbol? name-arg) (symbol->string name-arg))
                    ((string? name-arg) name-arg)
                    (else (error "intern name must be symbol or string" name-arg))))
             (pkg (if (= (length args) 2)
                      (ensure-package! (cadr args))
                      *current-package*)))
        (package-intern! pkg name))))
  (def 'import
    (lambda args
      (unless (or (= (length args) 1) (= (length args) 2))
        (error "import takes symbol(s) and optional package-name" args))
      (let ((vals (car args))
            (pkg (if (= (length args) 2)
                     (ensure-package! (cadr args))
                     *current-package*)))
        (cond
         ((symbol? vals)
          (package-import-symbol! pkg vals))
         ((list? vals)
          (for-each
           (lambda (s)
             (unless (symbol? s)
               (error "import list must contain symbols" s))
             (package-import-symbol! pkg s))
           vals))
         (else
          (error "import expects symbol or list of symbols" vals)))
        #t)))
  (def 'exit
    (lambda args
      (apply exit args))))

(define (make-initial-env)
  (let ((env (make-frame #f)))
    (set! *package-registry* '())
    (let ((islisp (ensure-package! "ISLISP"))
          (common-lisp (ensure-package! "COMMON-LISP"))
          (user (ensure-package! "ISLISP-USER")))
      (package-use! common-lisp islisp)
      (package-use! user islisp)
      (set! *current-package* islisp)
      (frame-define! env (resolve-binding-symbol 'nil) '())
      (package-export! *current-package* 'nil)
      (frame-define! env (resolve-binding-symbol 't) #t)
      (package-export! *current-package* 't)
      (install-primitives! env)
      (set! *current-package* user))
    env))

(define (read-all port)
  (let loop ((acc '()))
    (let ((x (read port)))
      (if (eof-object? x)
          (reverse acc)
          (loop (cons x acc))))))

(define (repl env)
  (define (write-result x)
    (cond
     ((closure? x)
      (let ((name (closure-name x)))
        (if name
            (begin
              (display "#<function ")
              (display name)
              (display ">"))
            (display "#<closure>"))))
     ((primitive? x)
      (begin
        (display "#<primitive ")
        (display (primitive-name x))
        (display ">")))
     ((macro? x)
      (let ((name (macro-name x)))
        (if name
            (begin
              (display "#<macro ")
              (display name)
              (display ">"))
            (display "#<macro>"))))
     (else
      (write x))))
  (display "ISLISP> ")
  (flush)
  (let ((x (read)))
    (if (eof-object? x)
        (begin
          (newline)
          'bye)
        (begin
          (guard (e (else
                     (display "Error: ")
                     (write e)
                     (newline)))
            (let ((result (eval-islisp x env)))
              (write-result result)
              (newline)))
          (repl env)))))
