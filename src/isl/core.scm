;; Minimal ISLISP core evaluator on Gauche 0.9.15.
;; The implementation keeps dependencies close to R7RS-level primitives.
(define-module isl.core
  (use srfi-1)
  (export make-initial-env eval-islisp apply-islisp repl read-all))

(select-module isl.core)

(define (truthy? v)
  (and (not (eq? v #f))
       (not (null? v))))

(define (make-frame parent)
  (vector 'frame '() parent))

(define (frame-bindings frame)
  (vector-ref frame 1))

(define (frame-parent frame)
  (vector-ref frame 2))

(define (set-frame-bindings! frame bindings)
  (vector-set! frame 1 bindings))

(define (frame-define! frame sym val)
  (let ((bindings (frame-bindings frame)))
    (let loop ((xs bindings) (acc '()))
      (cond
       ((null? xs)
        (set-frame-bindings! frame (append (reverse acc) (list (cons sym val)))))
       ((eq? (caar xs) sym)
        (set-frame-bindings! frame
                             (append (reverse acc) (cons (cons sym val) (cdr xs)))))
       (else
        (loop (cdr xs) (cons (car xs) acc)))))))

(define (frame-set! frame sym val)
  (let loop ((f frame))
    (if (not f)
        (error "Unbound variable" sym)
        (let ((pair (assoc sym (frame-bindings f))))
          (if pair
              (set-cdr! pair val)
              (loop (frame-parent f)))))))

(define (global-frame env)
  (let loop ((f env))
    (if (frame-parent f)
        (loop (frame-parent f))
        f)))

(define (frame-ref frame sym)
  (let loop ((f frame))
    (if (not f)
        (error "Unbound variable" sym)
        (let ((pair (assoc sym (frame-bindings f))))
          (if pair
              (cdr pair)
              (loop (frame-parent f)))))))

(define (frame-bound? frame sym)
  (let loop ((f frame))
    (if (not f)
        #f
        (if (assoc sym (frame-bindings f))
            #t
            (loop (frame-parent f))))))

(define (closure? obj)
  (and (vector? obj) (= (vector-length obj) 5) (eq? (vector-ref obj 0) 'closure)))

(define (make-closure params body env name)
  (vector 'closure params body env name))

(define (closure-params c) (vector-ref c 1))
(define (closure-body c) (vector-ref c 2))
(define (closure-env c) (vector-ref c 3))
(define (closure-name c) (vector-ref c 4))

(define (primitive? obj)
  (and (vector? obj) (= (vector-length obj) 3) (eq? (vector-ref obj 0) 'primitive)))

(define (make-primitive name proc)
  (vector 'primitive name proc))

(define (primitive-name p) (vector-ref p 1))
(define (primitive-proc p) (vector-ref p 2))

(define (validate-params params)
  (parse-params params)
  params)

(define (parse-params params)
  (unless (list? params)
    (error "Parameter list must be a list" params))
  (let loop ((xs params)
             (mode 'required)
             (required '())
             (optional '()))
    (if (null? xs)
        (list (reverse required) (reverse optional))
        (let ((x (car xs)))
          (cond
           ((eq? x '&optional)
            (when (eq? mode 'optional)
              (error "Duplicate &optional in parameter list" params))
            (loop (cdr xs) 'optional required optional))
           ((eq? mode 'required)
            (unless (symbol? x)
              (error "Required parameter must be a symbol" x))
            (loop (cdr xs) mode (cons x required) optional))
           (else
            (cond
             ((symbol? x)
              (loop (cdr xs) mode required (cons (list x #f '()) optional)))
             ((and (list? x) (= (length x) 2) (symbol? (car x)))
              (loop (cdr xs) mode required (cons (list (car x) #t (cadr x)) optional)))
             (else
              (error "Invalid &optional parameter specifier" x)))))))))

(define (tail-call? obj)
  (and (vector? obj) (= (vector-length obj) 3) (eq? (vector-ref obj 0) 'tail-call)))

(define (make-tail-call fn args)
  (vector 'tail-call fn args))

(define (tail-call-fn tc) (vector-ref tc 1))
(define (tail-call-args tc) (vector-ref tc 2))

(define *block-stack* '())

(define (go-signal? obj)
  (and (vector? obj) (= (vector-length obj) 2) (eq? (vector-ref obj 0) 'go-signal)))

(define (make-go-signal tag)
  (vector 'go-signal tag))

(define (go-signal-tag s) (vector-ref s 1))

(define (force-value v)
  (let loop ((x v))
    (if (tail-call? x)
        (loop (apply-islisp (tail-call-fn x) (tail-call-args x)))
        x)))

(define (eval-sequence* forms env tail?)
  (let loop ((xs forms))
    (cond
     ((null? xs) '())
     ((null? (cdr xs))
      (eval-islisp* (car xs) env tail?))
     (else
      (force-value (eval-islisp* (car xs) env #f))
      (loop (cdr xs))))))

(define (eval-sequence forms env)
  (force-value (eval-sequence* forms env #f)))

(define (eval-list xs env)
  (map (lambda (x) (force-value (eval-islisp* x env #f))) xs))

(define (write-to-string x)
  (let ((p (open-output-string)))
    (write x p)
    (get-output-string p)))

(define (display-to-string x)
  (let ((p (open-output-string)))
    (display x p)
    (get-output-string p)))

(define (render-format fmt args)
  (unless (string? fmt)
    (error "format control string must be a string" fmt))
  (let ((p (open-output-string)))
    (let loop ((i 0) (rest args))
      (if (>= i (string-length fmt))
          (begin
            (unless (null? rest)
              (error "too many arguments for format" rest))
            (get-output-string p))
          (let ((ch (string-ref fmt i)))
            (if (char=? ch #\~)
                (if (>= (+ i 1) (string-length fmt))
                    (error "unterminated format directive" fmt)
                    (let ((d (string-ref fmt (+ i 1))))
                      (cond
                       ((char=? d #\A)
                        (when (null? rest)
                          (error "too few arguments for format" fmt))
                        (display (display-to-string (car rest)) p)
                        (loop (+ i 2) (cdr rest)))
                       ((char=? d #\S)
                        (when (null? rest)
                          (error "too few arguments for format" fmt))
                        (display (write-to-string (car rest)) p)
                        (loop (+ i 2) (cdr rest)))
                       ((char=? d #\%)
                        (newline p)
                        (loop (+ i 2) rest))
                       ((char=? d #\~)
                        (write-char #\~ p)
                        (loop (+ i 2) rest))
                       (else
                        (error "unsupported format directive" d)))))
                (begin
                  (write-char ch p)
                  (loop (+ i 1) rest))))))))

(define (ensure-string x who)
  (unless (string? x)
    (error who "needs a string" x)))

(define (ensure-nonnegative-integer x who)
  (unless (and (integer? x) (>= x 0))
    (error who "needs a non-negative integer" x)))

(define (isl-substring s start end)
  (ensure-string s "substring")
  (ensure-nonnegative-integer start "substring")
  (ensure-nonnegative-integer end "substring")
  (let ((n (string-length s)))
    (when (> start end)
      (error "substring start must be <= end" start end))
    (when (> end n)
      (error "substring end out of range" end n))
    (substring s start end)))

(define (isl-length x)
  (cond
   ((string? x) (string-length x))
   ((list? x) (length x))
   ((vector? x) (vector-length x))
   (else
    (error "length supports string/list/vector only" x))))

(define (eval-while args env who)
  (if (>= (length args) 1)
      (let ((test-form (car args))
            (body (cdr args)))
        (let loop ()
          (if (truthy? (eval-islisp test-form env))
              (begin
                (eval-sequence body env)
                (loop))
              '())))
      (error who "needs test expression and optional body" args)))

(define (eval-loop args env)
  (let ((for-var #f)
        (start-form #f)
        (end-form #f)
        (until-form #f)
        (body '()))
    (let parse ((xs args))
      (cond
       ((null? xs) 'done)
       ((eq? (car xs) 'for)
        (when for-var
          (error "loop for clause appears multiple times" args))
        (unless (and (pair? (cdr xs))
                     (pair? (cddr xs))
                     (pair? (cdddr xs))
                     (pair? (cddddr xs))
                     (pair? (cddddr (cdr xs)))
                     (symbol? (cadr xs))
                     (eq? (caddr xs) 'from)
                     (eq? (car (cddddr xs)) 'to))
          (error "invalid loop for clause" xs))
        (set! for-var (cadr xs))
        (set! start-form (cadddr xs))
        (set! end-form (cadr (cddddr xs)))
        (parse (cddr (cddddr xs))))
       ((eq? (car xs) 'until)
        (when until-form
          (error "loop until clause appears multiple times" args))
        (unless (pair? (cdr xs))
          (error "loop until clause needs a test form" xs))
        (set! until-form (cadr xs))
        (parse (cddr xs)))
       ((eq? (car xs) 'do)
        (set! body (cdr xs)))
       (else
        (error "unknown loop clause" (car xs)))))
    (unless (or for-var until-form)
      (error "loop needs at least for-clause or until-clause" args))
    (let ((loop-env (make-frame env)))
      (if for-var
          (let ((start (eval-islisp start-form env))
                (end (eval-islisp end-form env)))
            (unless (and (integer? start) (integer? end))
              (error "loop from/to currently requires integers" start end))
            (frame-define! loop-env for-var start)
            (let loop-iter ()
              (let ((i (frame-ref loop-env for-var)))
                (if (> i end)
                    '()
                    (if (and until-form (truthy? (eval-islisp until-form loop-env)))
                        '()
                        (begin
                          (eval-sequence body loop-env)
                          (frame-set! loop-env for-var (+ i 1))
                          (loop-iter)))))))
          (let loop-iter ()
            (if (and until-form (truthy? (eval-islisp until-form loop-env)))
                '()
                (begin
                  (eval-sequence body loop-env)
                  (loop-iter))))))))

(define (eval-tagbody args env)
  (let ((items args))
    (let make-labels ((xs items) (idx 0) (acc '()))
      (if (null? xs)
          (let ((labels (reverse acc))
                (len (length items)))
            (let loop ((i 0))
              (if (>= i len)
                  '()
                  (let ((item (list-ref items i)))
                    (if (or (symbol? item) (integer? item))
                        (loop (+ i 1))
                        (let ((next-i
                               (guard (e
                                       ((go-signal? e)
                                        (let ((p (assoc (go-signal-tag e) labels)))
                                          (if p
                                              (cdr p)
                                              (raise e))))
                                       (else
                                        (raise e)))
                                 (force-value (eval-islisp* item env #f))
                                 (+ i 1))))
                          (loop next-i)))))))
          (let ((x (car xs)))
            (if (or (symbol? x) (integer? x))
                (if (assoc x acc)
                    (error "duplicate tagbody label" x)
                    (make-labels (cdr xs) (+ idx 1) (cons (cons x idx) acc)))
                (make-labels (cdr xs) (+ idx 1) acc)))))))

(define (eval-block args env tail?)
  (if (>= (length args) 1)
      (let ((name (car args))
            (body (cdr args)))
        (unless (symbol? name)
          (error "block name must be a symbol" name))
        (call/cc
         (lambda (escape)
           (dynamic-wind
             (lambda ()
               (set! *block-stack* (cons (cons name escape) *block-stack*)))
             (lambda ()
               (eval-sequence* body env tail?))
             (lambda ()
               (set! *block-stack* (cdr *block-stack*)))))))
      (error "block needs name and optional body" args)))

(define (init-do-bindings bindings env do-env)
  (for-each
   (lambda (b)
     (unless (and (list? b) (>= (length b) 2) (<= (length b) 3) (symbol? (car b)))
       (error "invalid do binding" b))
     (frame-define! do-env (car b) (eval-islisp (cadr b) env)))
   bindings))

(define (step-do-bindings! bindings do-env)
  (let ((nexts
         (map
          (lambda (b)
            (let ((sym (car b)))
              (cons sym
                    (if (= (length b) 3)
                        (eval-islisp (caddr b) do-env)
                        (frame-ref do-env sym)))))
          bindings)))
    (for-each (lambda (p) (frame-set! do-env (car p) (cdr p))) nexts)))

(define (eval-do args env tail?)
  (if (>= (length args) 2)
      (let ((bindings (car args))
            (end-clause (cadr args))
            (body (cddr args)))
        (unless (list? bindings)
          (error "do bindings must be a list" bindings))
        (unless (and (list? end-clause) (not (null? end-clause)))
          (error "do end clause must be (test . result-forms)" end-clause))
        (let ((test-form (car end-clause))
              (result-forms (cdr end-clause))
              (do-env (make-frame env)))
          (init-do-bindings bindings env do-env)
          (let loop ()
            (if (truthy? (eval-islisp test-form do-env))
                (if (null? result-forms)
                    '()
                    (if tail?
                        (eval-sequence* result-forms do-env #t)
                        (eval-sequence result-forms do-env)))
                (begin
                  (eval-sequence body do-env)
                  (step-do-bindings! bindings do-env)
                  (loop))))))
      (error "do needs bindings, end clause and optional body" args)))

(define (eval-dolist args env tail?)
  (if (>= (length args) 1)
      (let ((spec (car args))
            (body (cdr args)))
        (unless (and (list? spec) (>= (length spec) 2) (<= (length spec) 3) (symbol? (car spec)))
          (error "dolist spec must be (var list [result])" spec))
        (let* ((var (car spec))
               (list-form (cadr spec))
               (result-form (and (= (length spec) 3) (caddr spec)))
               (values (eval-islisp list-form env))
               (loop-env (make-frame env)))
          (unless (list? values)
            (error "dolist requires a list value" values))
          (frame-define! loop-env var '())
          (for-each
           (lambda (v)
             (frame-set! loop-env var v)
             (eval-sequence body loop-env))
           values)
          (frame-set! loop-env var '())
          (if result-form
              (if tail?
                  (eval-islisp* result-form loop-env #t)
                  (eval-islisp result-form loop-env))
              '())))
      (error "dolist needs (var list [result]) and optional body" args)))

(define (eval-dotimes args env tail?)
  (if (>= (length args) 1)
      (let ((spec (car args))
            (body (cdr args)))
        (unless (and (list? spec) (>= (length spec) 2) (<= (length spec) 3) (symbol? (car spec)))
          (error "dotimes spec must be (var count [result])" spec))
        (let* ((var (car spec))
               (count (eval-islisp (cadr spec) env))
               (result-form (and (= (length spec) 3) (caddr spec)))
               (loop-env (make-frame env)))
          (unless (and (integer? count) (>= count 0))
            (error "dotimes count must be a non-negative integer" count))
          (frame-define! loop-env var 0)
          (let loop ((i 0))
            (if (< i count)
                (begin
                  (frame-set! loop-env var i)
                  (eval-sequence body loop-env)
                  (loop (+ i 1)))
                (begin
                  (frame-set! loop-env var count)
                  (if result-form
                      (if tail?
                          (eval-islisp* result-form loop-env #t)
                          (eval-islisp result-form loop-env))
                      '()))))))
      (error "dotimes needs (var count [result]) and optional body" args)))

(define (bind-params! frame param-spec args)
  (let ((required (car param-spec))
        (optional (cadr param-spec)))
    (when (< (length args) (length required))
      (error "Too few arguments" args))
    (let bind-required ((rs required) (as args))
      (if (null? rs)
          (let bind-optional ((os optional) (rest as))
            (if (null? os)
                (if (null? rest)
                    frame
                    (error "Too many arguments" rest))
                (let* ((entry (car os))
                       (sym (car entry))
                       (has-init (cadr entry))
                       (init-form (caddr entry)))
                  (if (null? rest)
                      (begin
                        (frame-define! frame
                                       sym
                                       (if has-init
                                           (force-value (eval-islisp* init-form frame #f))
                                           '()))
                        (bind-optional (cdr os) rest))
                      (begin
                        (frame-define! frame sym (car rest))
                        (bind-optional (cdr os) (cdr rest)))))))
          (begin
            (frame-define! frame (car rs) (car as))
            (bind-required (cdr rs) (cdr as)))))))

(define (apply-islisp fn args)
  (let loop ((current-fn fn)
             (current-args args))
    (cond
     ((primitive? current-fn)
      (apply (primitive-proc current-fn) current-args))
     ((closure? current-fn)
      (let ((params (closure-params current-fn))
            (body (closure-body current-fn))
            (fenv (closure-env current-fn))
            (fname (closure-name current-fn)))
        (let ((param-spec (parse-params params)))
        (let ((call-env (make-frame fenv)))
          (bind-params! call-env param-spec current-args)
          (let ((result
                 (if fname
                     (call/cc
                      (lambda (escape)
                        (dynamic-wind
                          (lambda ()
                            (set! *block-stack* (cons (cons fname escape) *block-stack*)))
                          (lambda ()
                            (eval-sequence* body call-env #t))
                          (lambda ()
                            (set! *block-stack* (cdr *block-stack*))))))
                     (eval-sequence* body call-env #t))))
            (if (tail-call? result)
                (loop (tail-call-fn result) (tail-call-args result))
                result))))))
     (else
      (error "Attempt to call non-function" current-fn)))))

(define (special-form? sym)
  (memq sym '(quote if cond case loop while do dolist dotimes return-from go tagbody lambda defglobal defvar setq setf defun progn block let let*)))

(define (eval-special form env tail?)
  (let ((op (car form))
        (args (cdr form)))
    (case op
      ((quote)
       (if (= (length args) 1)
           (car args)
           (error "quote takes one argument" form)))
      ((if)
       (if (or (= (length args) 2) (= (length args) 3))
           (let ((test (eval-islisp* (car args) env #f)))
             (if (truthy? test)
                 (eval-islisp* (cadr args) env tail?)
                 (if (= (length args) 3)
                     (eval-islisp* (caddr args) env tail?)
                     '())))
           (error "if takes 2 or 3 arguments" form)))
      ((cond)
       (let loop ((clauses args))
         (if (null? clauses)
             '()
             (let* ((clause (car clauses))
                    (test-form (and (pair? clause) (car clause)))
                    (body (and (pair? clause) (cdr clause))))
               (unless (and (list? clause) (not (null? clause)))
                 (error "invalid cond clause" clause))
               (let ((test-val (eval-islisp* test-form env #f)))
                 (if (truthy? test-val)
                   (if (null? body)
                       test-val
                       (eval-sequence* body env tail?))
                   (loop (cdr clauses))))))))
      ((case)
       (if (>= (length args) 1)
           (let ((key (eval-islisp* (car args) env #f))
                 (clauses (cdr args)))
             (let loop ((xs clauses))
               (if (null? xs)
                   '()
                   (let* ((clause (car xs))
                          (keys (and (pair? clause) (car clause)))
                          (body (and (pair? clause) (cdr clause))))
                     (unless (and (list? clause) (>= (length clause) 1))
                       (error "invalid case clause" clause))
                     (if (or (eq? keys 'otherwise) (eq? keys 't))
                         (if (null? body)
                             '()
                             (eval-sequence* body env tail?))
                         (let ((matched?
                                (if (list? keys)
                                    (any (lambda (k) (eqv? key k)) keys)
                                    (eqv? key keys))))
                           (if matched?
                               (if (null? body)
                                   '()
                                   (eval-sequence* body env tail?))
                               (loop (cdr xs)))))))))
           (error "case needs key and clauses" form)))
      ((loop)
       (eval-loop args env))
      ((while)
       (eval-while args env "while"))
      ((do)
       (eval-do args env tail?))
      ((dolist)
       (eval-dolist args env tail?))
      ((dotimes)
       (eval-dotimes args env tail?))
      ((return-from)
       (if (or (= (length args) 1) (= (length args) 2))
           (let* ((name (car args))
                  (value (if (= (length args) 2)
                             (eval-islisp* (cadr args) env #f)
                             '())))
             (unless (symbol? name)
               (error "return-from name must be a symbol" name))
             (let ((entry (assoc name *block-stack*)))
               (unless entry
                 (error "No enclosing block for return-from" name))
               ((cdr entry) value)))
           (error "return-from takes block-name and optional value" form)))
      ((go)
       (if (= (length args) 1)
           (let ((tag (car args)))
             (unless (or (symbol? tag) (integer? tag))
               (error "go tag must be a symbol or integer" tag))
             (raise (make-go-signal tag)))
           (error "go takes one tag argument" form)))
      ((tagbody)
       (eval-tagbody args env))
      ((lambda)
       (if (>= (length args) 2)
           (let ((params (car args))
                 (body (cdr args)))
             (validate-params params)
             (make-closure params body env #f))
           (error "lambda needs params and body" form)))
      ((defglobal)
       (if (= (length args) 2)
           (let ((sym (car args))
                 (val (eval-islisp* (cadr args) env #f)))
             (unless (symbol? sym)
               (error "defglobal needs a symbol" sym))
             (let ((global (global-frame env)))
               (frame-define! global sym val)
               sym))
           (error "defglobal takes symbol and expression" form)))
      ((defvar)
       (if (= (length args) 2)
           (let ((sym (car args))
                 (global (global-frame env)))
             (unless (symbol? sym)
               (error "defvar needs a symbol" sym))
             (unless (frame-bound? global sym)
               (frame-define! global sym (eval-islisp* (cadr args) env #f)))
             sym)
           (error "defvar takes symbol and expression" form)))
      ((setq)
       (if (= (length args) 2)
           (let ((sym (car args))
                 (val (eval-islisp* (cadr args) env #f)))
             (unless (symbol? sym)
               (error "setq needs a symbol" sym))
             (frame-set! env sym val)
             val)
           (error "setq takes symbol and expression" form)))
      ((setf)
       (if (= (length args) 2)
           (let* ((place (car args))
                  (val (eval-islisp* (cadr args) env #f)))
             (cond
              ((symbol? place)
               (frame-set! env place val)
               val)
              ((and (pair? place) (eq? (car place) 'car) (= (length place) 2))
               (let ((target (eval-islisp* (cadr place) env #f)))
                 (set-car! target val)
                 val))
              ((and (pair? place) (eq? (car place) 'cdr) (= (length place) 2))
               (let ((target (eval-islisp* (cadr place) env #f)))
                 (set-cdr! target val)
                 val))
              (else
               (error "Unsupported setf place" place))))
           (error "setf takes place and expression" form)))
      ((defun)
       (if (>= (length args) 3)
           (let ((name (car args))
                 (params (cadr args))
                 (body (cddr args)))
             (unless (symbol? name)
               (error "defun name must be symbol" name))
             (validate-params params)
             (let ((fun (make-closure params body env name)))
               (frame-define! (global-frame env) name fun)
               name))
           (error "defun needs name, params and body" form)))
      ((progn)
       (eval-sequence* args env tail?))
      ((block)
       (eval-block args env tail?))
      ((let)
       (if (>= (length args) 2)
           (let ((bindings (car args))
                 (body (cdr args)))
             (unless (list? bindings)
               (error "let bindings must be a list" bindings))
             (let ((let-env (make-frame env)))
               (for-each
               (lambda (b)
                  (unless (and (list? b) (= (length b) 2) (symbol? (car b)))
                    (error "invalid let binding" b))
                  (frame-define! let-env (car b) (eval-islisp* (cadr b) env #f)))
               bindings)
               (eval-sequence* body let-env tail?)))
           (error "let needs bindings and body" form)))
      ((let*)
       (if (>= (length args) 2)
           (let ((bindings (car args))
                 (body (cdr args)))
             (unless (list? bindings)
               (error "let* bindings must be a list" bindings))
             (let ((let-env (make-frame env)))
               (for-each
                (lambda (b)
                  (unless (and (list? b) (= (length b) 2) (symbol? (car b)))
                    (error "invalid let* binding" b))
                  (frame-define! let-env (car b) (eval-islisp* (cadr b) let-env #f)))
                bindings)
               (eval-sequence* body let-env tail?)))
           (error "let* needs bindings and body" form)))
      (else
       (error "Unknown special form" op)))))

(define (eval-islisp* form env tail?)
  (cond
   ((or (number? form) (string? form) (char? form) (boolean? form)) form)
   ((symbol? form)
    (frame-ref env form))
   ((pair? form)
    (let ((op (car form))
          (args (cdr form)))
      (if (and (symbol? op) (special-form? op))
          (eval-special form env tail?)
          (let ((fn (eval-islisp* op env #f))
                (vals (eval-list args env)))
            (if tail?
                (make-tail-call fn vals)
                (apply-islisp fn vals))))))
   ((null? form) '())
   (else
    form)))

(define (eval-islisp form env)
  (force-value (eval-islisp* form env #t)))

(define (install-primitives! env)
  (define (def name proc)
    (frame-define! env name (make-primitive name proc)))

  (def '+ +)
  (def '- -)
  (def '* *)
  (def '/ /)
  (def 'mod modulo)
  (def 'floor floor)
  (def 'ceiling ceiling)
  (def 'truncate truncate)
  (def 'round round)
  (def '= =)
  (def '< <)
  (def '> >)
  (def '<= <=)
  (def '>= >=)
  (def 'cons cons)
  (def 'car car)
  (def 'cdr cdr)
  (def 'list list)
  (def 'append append)
  (def 'mapcar
    (lambda (f xs)
      (unless (list? xs)
        (error "mapcar needs a list as second argument" xs))
      (map (lambda (x) (apply-islisp f (list x))) xs)))
  (def 'reduce
    (lambda args
      (unless (or (= (length args) 2) (= (length args) 3))
        (error "reduce takes function, list, and optional initial-value" args))
      (let ((f (car args))
            (xs (cadr args))
            (has-init (= (length args) 3))
            (init (if (= (length args) 3) (caddr args) '())))
        (unless (list? xs)
          (error "reduce needs a list as second argument" xs))
        (if has-init
            (let loop ((acc init) (rest xs))
              (if (null? rest)
                  acc
                  (loop (apply-islisp f (list acc (car rest)))
                        (cdr rest))))
            (if (null? xs)
                (error "reduce on empty list needs initial-value")
                (let loop ((acc (car xs)) (rest (cdr xs)))
                  (if (null? rest)
                      acc
                      (loop (apply-islisp f (list acc (car rest)))
                            (cdr rest)))))))))
  (def 'remove-if
    (lambda (pred xs)
      (unless (list? xs)
        (error "remove-if needs a list as second argument" xs))
      (let loop ((rest xs) (acc '()))
        (if (null? rest)
            (reverse acc)
            (let ((v (car rest)))
              (if (truthy? (apply-islisp pred (list v)))
                  (loop (cdr rest) acc)
                  (loop (cdr rest) (cons v acc))))))))
  (def 'eq eq?)
  (def 'eql eqv?)
  (def 'equal equal?)
  (def 'null (lambda (x) (null? x)))
  (def 'atom (lambda (x) (not (pair? x))))
  (def 'numberp number?)
  (def 'symbolp symbol?)
  (def 'listp list?)
  (def 'string=
    (lambda (a b)
      (ensure-string a "string=")
      (ensure-string b "string=")
      (string=? a b)))
  (def 'string-concat
    (lambda xs
      (for-each (lambda (x) (ensure-string x "string-concat")) xs)
      (apply string-append xs)))
  (def 'substring
    (lambda args
      (cond
       ((= (length args) 2)
        (isl-substring (car args) (cadr args) (string-length (car args))))
       ((= (length args) 3)
        (isl-substring (car args) (cadr args) (caddr args)))
       (else
        (error "substring takes string start [end]" args)))))
  (def 'length isl-length)
  (def 'print
    (lambda (x)
      (write x)
      (newline)
      x))
  (def 'format
    (lambda args
      (cond
       ((null? args)
        (error "format needs at least a control string"))
       ((string? (car args))
        (let ((out (render-format (car args) (cdr args))))
          (display out)
          '()))
       ((< (length args) 2)
        (error "format needs destination and control string"))
       ((eq? (car args) #t)
        (let ((out (render-format (cadr args) (cddr args))))
          (display out)
          '()))
       ((null? (car args))
        (render-format (cadr args) (cddr args)))
       (else
        (error "unsupported format destination" (car args))))))
  (def 'not
    (lambda (x)
      (if (truthy? x) #f #t)))
  (def 'apply
    (lambda (f xs)
      (apply-islisp f xs)))
  (def 'funcall
    (lambda (f . xs)
      (apply-islisp f xs)))
  (def 'exit
    (lambda args
      (apply exit args))))

(define (make-initial-env)
  (let ((env (make-frame #f)))
    (frame-define! env 'nil '())
    (frame-define! env 't #t)
    (install-primitives! env)
    env))

(define (read-all port)
  (let loop ((acc '()))
    (let ((x (read port)))
      (if (eof-object? x)
          (reverse acc)
          (loop (cons x acc))))))

(define (repl env)
  (define (write-result x)
    (cond
     ((closure? x)
      (let ((name (closure-name x)))
        (if name
            (begin
              (display "#<function ")
              (display name)
              (display ">"))
            (display "#<closure>"))))
     ((primitive? x)
      (begin
        (display "#<primitive ")
        (display (primitive-name x))
        (display ">")))
     (else
      (write x))))
  (display "ISLISP> ")
  (flush)
  (let ((x (read)))
    (if (eof-object? x)
        (begin
          (newline)
          'bye)
        (begin
          (guard (e (else
                     (display "Error: ")
                     (write e)
                     (newline)))
            (let ((result (eval-islisp x env)))
              (write-result result)
              (newline)))
          (repl env)))))
