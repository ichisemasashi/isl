それでは、**第7章：ISLISPにおけるオブジェクト指向プログラミング**に飛び込みましょう。



### **7. ISLISPにおけるオブジェクト指向プログラミング**

ISLISPには、クラス、オブジェクト、メソッドを定義および管理できるオブジェクト指向プログラミング（OOP）システムが含まれています。このシステムは、Common Lispのオブジェクト指向モデルをベースにしていますが、ISLISP独自の機能もいくつか備えています。

#### **1. ISLISPのオブジェクトシステム**

ISLISPのオブジェクトシステムは、クラスを定義し、オブジェクトを作成し、メソッドを扱うことができるシンプルで軽量な実装です。より大規模なオブジェクト指向システムが提供するような機能一式は提供していませんが、カプセル化、継承、多態性などのオブジェクト指向プログラミングの主要な原則をサポートしています。

- ISLISPでは、クラスを定義するには `defclass` マクロを、メソッドを定義するには `defmethod` を使用します。
- オブジェクトはクラスのインスタンスであり、メッセージパッシングのテクニックを使用してこれらのオブジェクトとやりとりすることができます。

#### **2. `defclass` によるクラスの定義**

ISLISPでクラスを定義するには、`defclass` マクロを使用します。 クラスのデータメンバである要素（スロット）を指定し、その初期値を指定することができます。また、クラス定義では親クラスからの継承も可能です。

#### **例: 単純なクラスの定義**

```lisp
(defclass person ()
  ((name :initarg :name :accessor person-name)
   (age :initarg :age :accessor person-age)))
```

- 上記の例では、クラス `person` が `name` と `age` という2つの要素を持つように定義されています。
- `:initarg` は、クラスのインスタンスを作成するための初期化引数を指定します。
- `:accessor` は、スロットの値にアクセスするためのゲッター関数を指定します。

##### **defclass の説明 引数:**

- クラス名の後に `()` を指定すると、そのクラスが親クラスを持たない (ベースクラスである) ことを表します。
- スロットのリストは属性を定義し、それらのアクセサを提供します。

#### **3. オブジェクトの作成と使用**

クラスが定義されると、`make-instance` 関数を使用してオブジェクトを作成できます。 この関数はクラスをインスタンス化し、`:initarg` キーワードで定義された要素の値を返します。

##### **例: オブジェクトの作成**

```lisp
(setq john (make-instance 'person :name "John Doe" :age 30))
(print (person-name john)) ; 「John Doe」と表示
(print (person-age john)) ; 30と表示
```

- オブジェクト `john` は `person` クラスのインスタンスです。
- `defclass` で `:accessor` キーワードで定義された `person-name` および `person-age` 関数は、スロットの値を取得します。

#### **4. defmethod によるメソッドと継承**

defmethod マクロを使用して、クラスにメソッドを定義することができます。 メソッドは、オブジェクト（クラスのインスタンス）上で動作する関数です。 ISLISP では、渡されたオブジェクトの型に基づいてメソッドをディスパッチすることができます。

##### **例: メソッドの定義**

```lisp
(defmethod greet ((p person))
  (format t "Hello, my name is ~A and I am ~A years old." 
          (person-name p) (person-age p)))
```

- `greet` メソッドは `person` クラスに対して定義されます。 このメソッドは `person` のインスタンス (`p`) を受け取り、その人の名前と年齢を使用して挨拶メッセージを表示します。
  
##### **例：メソッドの呼び出し**

```lisp
(greet john) ; 出力: 「Hello, my name is John Doe and I am 30 years old.」
```

- `greet` メソッドを呼び出すと、`person-name` および `person-age` アクセサにアクセスして `john` のスロット値を取得します。

#### **5. メソッドのオーバーライド**

ISLISPでは、親クラスから継承したメソッドをオーバーライドすることができます。オーバーライドにより、オブジェクトの型やメソッドが呼び出されるコンテキストに基づいて、メソッドの異なる動作を定義することができます。

##### **例：メソッドのオーバーライド**

`person` を継承する `employee` という別のクラスを定義するとします。

```lisp
(defclass employee (person)
  ((employee-id :initarg :employee-id :accessor employee-id)))
```

次に、`employee` オブジェクトの `greet` メソッドをオーバーライドします。

```lisp
(defmethod greet ((e employee))
  (format t "Hello, my name is ~A, I am ~A years old, and my employee ID is ~A."
          (person-name e) (person-age e) (employee-id e)))
```

この例では、`employee` が `greet` メソッドを上書きして、挨拶に従業員のIDを含めています。

##### **例: 上書きされたメソッドの呼び出し**

```lisp
(setq jane (make-instance 'employee :name "Jane Doe" :age 28 :employee-id 12345))
(greet jane) ; 出力: 「こんにちは、私の名前はジェーン・ドウ、28歳、従業員IDは12345です。」
```

- `jane` は `employee` クラスのインスタンスであるため、`person` 用に定義されたメソッドではなく、`employee` 用に定義された `greet` メソッドが呼び出されます。

#### **6. ジェネリック関数による多重ディスパッチ**

ISLISPでは、引数の型に基づいて異なるメソッドを持つことができる汎用関数を定義することができます。これにより、引数の型に基づいて正しいメソッドが選択されるマルチプルディスパッチが可能になります。

##### **例：マルチプルディスパッチを持つ汎用関数**

```lisp
(defgeneric introduce (person))

(defmethod introduce ((p person))
  (format t "This is ~A." (person-name p)))

(defmethod introduce ((e employee))
 (format t "This is employee ~A, ID ~A." (person-name e) (employee-id e)))
```

- ここでは、`introduce` 関数はジェネリック関数であり、引数が `person` であるか `employee` であるかによって異なる動作を定義しています。

##### **例：ジェネリック関数の呼び出し**

```lisp
(introduce john)  ; 出力：「これはジョン・ドウです。」
(introduce jane)  ; 出力：「これは従業員ジェーン・ドウ、ID 12345 です。」
```

- 引数の型に基づいて適切なメソッドがディスパッチされます（「john」は「person」、「jane」は「employee」）。



#### **オブジェクト指向プログラミングにおける主要概念のまとめ**

1. **`defclass` によるクラスの定義：**
   - `defclass` は、属性と初期化引数のスロットを持つクラスを定義するために使用します。

2. **オブジェクトの作成と使用：**
   - オブジェクトは `make-instance` を使用して作成され、スロット値は生成されたアクセサでアクセスできます。

3. **`defmethod` によるメソッドと継承：**
   - `defmethod` はオブジェクト上で動作するメソッドを定義し、メソッドはサブクラスで継承およびオーバーライドすることができます。

4. **メソッドのオーバーライド:**
   - サブクラスでメソッドをオーバーライドして、動作を修正または拡張することができます。

5. **ジェネリック関数によるマルチプルディスパッチ:**
   - ISLISPではマルチプルディスパッチが可能であり、異なるタイプの引数に対してメソッドを定義し、それに応じてディスパッチすることができます。
