ISLISPの**第5章：リストとシーケンス**に飛び込みましょう！



### **5. リストとシーケンス**

リストはISLISPにおける最も重要なデータ構造のひとつです。 リストは項目の集合を格納するために使用されます。 ISLISPはリストを操作し、それらを扱うためのさまざまな関数を提供しています。また、シーケンスを操作する高レベル関数も提供しています。

#### **基本的なリスト操作 (`car`, `cdr`, `cons`)**

ISLISPでは、リストは*consセル*で構成されており、これはデータのペアです。これらのconsセルは、基本的なリスト操作である`car`、`cdr`、および`cons`を使用して操作することができます。

##### **1. `car`**
`car` 関数はリストの最初の要素（またはヘッド）を取得します。つまり、最初の cons セルの値を取得します。

例：
```lisp
(setq my-list '(1 2 3 4)) ; リスト: (1 2 3 4)
(car my-list) ; 1 を返します
```

- `car` は最初の要素にアクセスします。この例では `1` です。

##### **2. `cdr`**
`cdr` 関数はリストの残りの部分、すなわち最初の要素を除くすべてを取得します。

例：
```lisp
(setq my-list '(1 2 3 4)) ; リスト: (1 2 3 4)
(cdr my-list)               ; 戻り値 (2 3 4)
```

- `cdr` はリストの末尾を返します。つまり、`(2 3 4)` です。

##### **3. `cons`**
`cons` 関数は、既存のリストに要素を追加して新しいリストを構築します。

例:
```lisp
(setq my-list '(2 3 4)) ; リスト: (2 3 4)
(cons 1 my-list) ; 結果: (1 2 3 4)
```

- `cons` はリストの先頭に `1` を追加し、新しいリスト `(1 2 3 4)` を生成します。



#### **マッピングとフィルタリング (`mapcar`, `remove-if`)**

ISLISPは、リストのすべての要素に1つの関数を適用したり、リストから要素をフィルタリングしたりできるような、`mapcar`や`remove-if`のような高階関数を提供します。

##### **1. `mapcar`**
`mapcar`は、リストの各要素に1つの関数を適用し、その結果を新しいリストとして返します。

例 (リストの各要素に 1 を加算する):
```lisp
(mapcar (lambda (x) (+ x 1)) '(1 2 3 4)) ; 戻り値は (2 3 4 5)
```

- ラムダ関数 `(+ x 1)` がリスト `(1 2 3 4)` の各要素に適用され、結果は新しいリスト `(2 3 4 5)` となります。

##### **2. `remove-if`**
`remove-if` は、与えられた述語を満たすリストの要素を削除します。

例 (リストから偶数を削除):
```lisp
(remove-if (lambda (x) (evenp x)) '(1 2 3 4 5 6)) ; 結果は (1 3 5)
```

- ラムダ関数 `(lambda (x) (evenp x))` は各要素が偶数であるかどうかを調べます。 偶数である要素 (`2`, `4`, `6`) が削除され、リスト `(1 3 5)` が残ります。

#### **3. `remove-if-not`**
remove-if` の反対の動作をする `remove-if-not` は、述語を満たす要素を残します。

例 (偶数だけを残す):
```lisp
(remove-if-not (lambda (x) (evenp x)) '(1 2 3 4 5 6)) ; 戻り値は (2 4 6)
```

これは、偶数だけを残したリスト `(2 4 6)` を返します。



#### **`reduce` と再帰**

##### **1. `reduce`**
`reduce` は高階関数であり、二項関数を受け取り、それをリストの要素に累積的に適用し、リストを単一の結果に還元します。

例 (リストの要素の合計):
```lisp
(reduce #'+ '(1 2 3 4)) ; 10 を返します
```

- `reduce` は、リスト `(1 2 3 4)` のすべての要素に `+` 関数を適用し、結果として `10` を返します。

##### **2. カスタムの還元関数**
より複雑な操作を行うために、カスタムの還元関数を定義することもできます。例えば、すべての要素を掛け合わせる場合：
```lisp
(reduce #'* '(1 2 3 4)) ; 24 を返します
```

- これはリストのすべての要素を掛け合わせ、結果として `24` を返します。

##### **3. カスタム還元のための再帰**
再帰は Lisp における強力なテクニックであり、特に複雑な構造やロジックを扱う場合、手動で還元を実装する際に頻繁に使用されます。

例 (リストの合計を手動で再帰処理):
```lisp
(defun sum-list (lst)
  (if (null lst)          ; 基本ケース：リストが空の場合
      0                   ; 0 を返す
      (+ (car lst) (sum-list (cdr lst)))))  ; 要素を再帰的に合計する

(sum-list '(1 2 3 4))  ; 10 を返す
```

この場合、`sum-list` はリストが空になるまで（基本ケース）、残りのリストの合計（`sum-list (cdr lst)`）に最初の要素（`car lst`）を再帰的に追加します。

##### **4. 末尾再帰**
再帰関数を最適化してパフォーマンスを向上させるため、ISLISPは末尾再帰をサポートしています。 末尾再帰により、コンパイラは再帰呼び出しを最適化して、大きなリストのスタックオーバーフローを回避することができます。

例 (末尾再帰のsum):
```lisp
(defun sum-list-tail (lst acc)
  (if (null lst) acc
      (sum-list-tail (cdr lst) (+ acc (car lst)))))

(sum-list-tail '(1 2 3 4) 0)  ; Returns 10
```

- ここでは、累算器 `acc` が部分和を保持しており、再帰呼び出しが最後のアクションであるため、これは末尾再帰的です。



#### **リストおよびシーケンスの操作における主要概念のまとめ**

1. **基本的なリスト操作:**
   - `car`: リストの最初の要素にアクセスします。
   - `cdr`: リストの残りの部分にアクセスします。
   - `cons`: リストの最初に要素を追加する。

2. **マッピングとフィルタリング:**
   - `mapcar`: リストの各要素に1つの関数を適用し、新しいリストを返す。
   - `remove-if`: 述語を満たす要素をリストから削除する。
   - `remove-if-not`: 述語を満たすリストの要素を保持する。

3. **`reduce`と再帰:**
   - `reduce`: 二項関数を適用して、リストを単一の結果にまとめる。
   - 再帰: リストを操作する強力なテクニック。カスタムの集約やアルゴリズムを含む。
   - 末尾再帰: 大きなリストでより良いパフォーマンスを発揮するよう最適化された再帰。
