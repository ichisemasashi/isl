ISLISPの**第3章：制御構造と関数**に進みましょう！



### **3. 制御構造と関数**

#### **条件分岐：`if`、`cond`、`case`**

ISLISPでは、条件分岐は特定の条件に基づいてプログラムの流れを制御するために使用されます。

##### **1. `if`**  
`if`文は条件を評価し、真であれば最初の式を実行し、そうでなければ2番目の式（オプション）を実行します。

```lisp
(if (> 5 3) 
    (print "True") ; 5 > 3の場合、"True"と表示
    (print "False")) ; それ以外の場合、"False"と表示
```

**構文:**
```lisp
(if <condition> <then-expression> [<else-expression>])
```

- `<condition>` が真と評価された場合、`<then-expression>` が実行されます。
- 条件が偽の場合、`<else-expression>` が実行されます（指定されている場合）。

##### **2. `cond`**  
`cond` ステートメントは、複数の条件をテストする必要がある場合に利用します。これは汎用の条件文です。

```lisp
(cond
  ((> 5 3) (print "5 は 3 より大きい"))
  ((< 2 1) (print "2 は 1 より小さい"))
  (t (print "条件に一致するものなし")))  ; t はデフォルトの場合の 'true' を表します
```

**構文:**
```lisp
(cond
  ((<condition1>) <expression1>)
  ((<condition2>) <expression2>)
  (t <else-expression>))  ; t はデフォルトの"else"として機能します
```

- それぞれの条件を順番に評価します。最初に"真"と評価された条件に対応する式が実行されます。

##### **3. `case`**  
`case` ステートメントは、等価性に基づく条件を処理するための `cond` の特殊な形式であり、通常は変数の値として考えられる有限のセットを処理するために使用されます。

```lisp
(case 3
  (1 (print "One"))
  (2 (print "Two"))
  (3 (print "Three"))
  (t (print "Other")))  ; デフォルトのケース
```

**構文：**
```lisp
(case <expression>
  (<value1> <expression1>)
  (<value2> <expression2>)
  (t <else-expression>))
```

- `case` 式は、変数の値がいずれかの case に一致するかどうかを確認します。一致する場合は、対応する式が実行されます。



#### **ループ：`loop`、`while`、`do`**

ISLISP には、反復的なタスクを実行するためのいくつかのループ構文が用意されています。

##### **1. `loop`**  
`loop` は、さまざまな値を繰り返し処理したり、反復的なアクションを実行したり、条件に応じて終了したりできる強力で柔軟なループ構文です。

例（固定回数のループ）：
```lisp
(loop for i from 1 to 5 do (print i)) ; 1 から 5 までの数字を表示
```

**構文：**
```lisp
(loop [for <var> from <start> to <end>] [do <action>])
```

また、以下のように複雑なアクションや条件を含めることもできます。
```lisp
(loop for i from 1 to 5
      until (> i 3)
      do (print i))  ; Prints 1 2 3
```

##### **2. `while`**  
whileループは、条件が真である限り繰り返し実行されます。

例：
```lisp
(setq i 1)
(while (< i 5)
  (print i)
  (setq i (+ i 1)))  ; 1 2 3 4 と表示
```

**構文：**
```lisp
(while <condition> <body>)  
```

##### **3. `do`**  
`do` ループは、反復処理中に状態を維持しながら、一連の式を反復処理するために使用されます。複雑な反復処理パターンには、`while` よりも柔軟に対応できます。

例：
```lisp
(do ((i 0 (+ i 1)))  ; i を 0 に初期化し、ループごとに 1 ずつインクリメントする
    ((>= i 5))        ; i が 5 以上になるまでループ
  (print i))          ; ループごとに i を表示
```

**構文:**
```lisp
(do ((<var1> <init1> <update1>) 
     (<var2> <init2> <update2>)) 
    ((<condition>))  
  (<body>))
```



#### **`defun` による関数の定義**

ISLISPでは、関数は `defun` を使用して定義されます。これにより、コード全体で再利用可能な名前付き関数を定義することができます。

例：
```lisp
(defun add (x y)    ; 関数 'add' を定義
  (+ x y))          ; x と y を足し合わせます

(add 3 4)            ; 7 を返します
```

**構文:**
```lisp
(defun <function-name> (<arg1> <arg2> ...) <body>)
```

- `defun` は、名前、引数、本体（実行されるコード）を持つ関数を定義します。
- この関数は定義後、コード内のどこからでも呼び出すことができます。



#### **再帰**

再帰はLispの基本的な概念です。再帰は、問題をより小さく同様のサブ問題に分割することで解決するために、関数を自身に呼び出させることを意味します。

例（階乗）：
```lisp
(defun factorial (n)
  (if (= n 0)          ; 基本ケース：nが0の場合、1を返す
      1
      (* n (factorial (- n 1)))))  ; 再帰的な場合

(factorial 5)  ; 120を返す
```

この例では、`factorial` は基本ケースに到達するまで、`n-1` を引数として自身を呼び出します。ここで、`n` は0に等しくなります。



#### **`progn` および `block` 構文**

##### **1. `progn`**  
`progn` 構文は、条件分岐やループなど、単一の式のみが期待される状況で複数の式をグループ化することができます。

例：
```lisp
(progn
  (print "Hello")
  (print "World"))  ; "Hello" と "World" の両方を表示
```

- `progn` の各式は順に評価され、最後の式の結果が返されます。

##### **2. `block`**  
`block` 構文は複数の式をグループ化するために使用され、`return-from` 文で早期終了することができます。

例：
```lisp
(block my-block
  (print "Before return")
  (return-from my-block "Exited early")  ; ブロックを早期終了
  (print "After return"))  ; この行は決して到達されない
```

**構文：**
```lisp
(block <name> <body>)
```



#### **`return-from` と `go` の使用**

##### **1. `return-from`**  
`return-from` 文は、ブロックまたは関数を早期に終了し、指定した値を返すために使用します。

例：
```lisp
(defun double (x)
  (if (< x 0)
      (return-from double "Negative value")
      (* 2 x)))

(double -3)   ; "Negative value"を返す
(double 4)    ; 8を返す
```

##### **2. `go`**  
go`文はブロック内のラベルに制御を移し、コード内の異なるポイントにジャンプすることを可能にします。一般的に、ループや条件分岐ブロックを早期に抜けるために使用されます。

例：
```lisp
(block my-block
  (go my-label)
  (print "これはスキップされます")
  (my-label (print "ジャンプしました"))  ; これは表示されます)

```
