
## **第4部：実世界のISLISPアプリケーション**  

**第13章：ISLISPで小さなアプリケーションを作成する**に進みましょう。この章では、ISLISPを使用して実用的なアプリケーションを作成することに焦点を当てます。この章では、シンプルなコマンドラインツールの設計、ユーザー入力の解析と処理、モジュール化された再利用可能なコードの記述について説明します。これらは、ISLISPで実用的なアプリケーションを作成する上で不可欠なスキルです。



### **13. ISLISPで小さなアプリケーションを作成する**

ISLISPで小規模なアプリケーションを構築することは、この言語の持つ力と柔軟性を示すのに最適な方法です。ここでは、シンプルなコマンドラインツールの設計、ユーザー入力の解析と処理、モジュール化された再利用可能なコードの記述といったプロセスを順を追って説明します。この章を終える頃には、現実のアプリケーションのためのコードの構造化方法が理解できるでしょう。

#### **1. シンプルなコマンドラインツールの設計**

コマンドラインツール（CLI）とは、通常はターミナルやシェル環境で実行され、テキストの入出力によりユーザーとやりとりするアプリケーションです。ISLISPで、ファイルの存在確認、ファイルの読み込み、ファイルへのデータの書き込みなど、基本的なファイル操作を実行できるシンプルなツールを作成してみましょう。

##### **ステップ 1: コア機能の定義**

まず、コマンドラインツールがサポートする基本的なファイル操作を定義します。

- **ファイルが存在するか確認**
- **ファイルの内容を読み込む**
- **ファイルに内容を書き込む**

以下に実装例を示します。

```lisp
(defpackage :file-tool
  (:use :common-lisp))

(in-package :file-tool)

;; ファイルが存在するかどうかを確認する関数
(defun file-exists-p (filename)
   "Check if a file exists."
  (not (zerop (probe-file filename))))

;; ファイルの内容を読み込む関数
(defun read-file (filename)
  "Read the contents of a file."
  (with-open-file (stream filename)
    (let ((contents (make-string (file-length stream))))
      (read-sequence contents stream)
      contents)))

;; データをファイルに書き込む関数
(defun write-file (filename content)
   "Write content to a file.” 
  (with-open-file (stream filename
                          :direction :output
                          :if-exists :supersede)
    (write-string content stream)))
```

この例では、

- `file-exists-p` は指定されたファイルが存在するかどうかを確認します。
- `read-file` はファイルを開き、その内容を文字列に読み込みます。
- `write-file` はファイルに内容を書き込み、ファイルがすでに存在する場合は上書きします。

ステップ2：コマンドライン引数の処理**

次に、スクリプトに渡された引数を解析し、ユーザー入力を処理します。ISLISPでは、`argv`変数を使用してコマンドライン引数にアクセスできます。この変数には、スクリプトの実行時に指定された引数のリストが含まれています。

```lisp
(defun parse-arguments (args)
  "Parse command-line arguments."
  (cond
    ((null args) (error "No command provided"))
    ((equal (car args) "check")
     (if (file-exists-p (cadr args))
         (format t "File exists: ~A~%" (cadr args))
         (format t "File does not exist: ~A~%" (cadr args))))
    ((equal (car args) "read")
     (format t "File content: ~A~%" (read-file (cadr args))))
    ((equal (car args) "write")
     (write-file (cadr args) (cadr (cdr args)))
     (format t "Content written to file: ~A~%" (cadr args)))
    (t (error "Unknown command: ~A" (car args)))))
```

この例では、

- どのアクションを取るかを決定するために、引数 (`args`) を解析します。
- `check` コマンドでは、ファイルが存在するかどうかを確認します。
- `read` コマンドでは、ファイルの内容を読み込んで表示します。
- `write` コマンドでは、指定された内容をファイルに書き込みます。

##### **ステップ 3: コマンドラインツールの実行**

次に、このツールを実行する方法が必要です。ISLISPの `argv` と `funcall` を使用して、コマンドラインからコマンドを実行することができます。

```lisp
(defun main ()
  (parse-arguments (cdr (function-arguments))))
```

`main` 関数は、解析された引数に基づいてロジックを実行します。スクリプトを実行するには、コマンドラインから次のように呼び出します。

```bash
$ (load "file-tool.lisp")
$ (main "check" "test.txt")
File exists: test.txt
```

これは、ファイルのチェック、読み込み、書き込みができるISLISPの基本的なコマンドラインツールの例です。



#### **2. ユーザー入力の解析と処理**

ユーザー入力の解析は、対話型アプリケーションを構築する上で重要な要素です。 前節では、基本的なコマンドライン引数の処理方法を示しましたが、より複雑なユーザー入力には、異なるタイプのデータ（数値、日付、ファイルパスなど）の解析など、より高度な処理が必要です。

##### **ユーザー入力を処理する**

ユーザーからさまざまなタイプのデータを受け取れるように、ツールを拡張してみましょう。

```lisp
(defun parse-number (input)
  "文字列を整数に変換, 失敗したらnilを返す."
  (ignore-errors (parse-integer input)))

(defun parse-date (input)
  "文字列(YYYY-MM-DD)を日付オブジェクトに変換."
  (ignore-errors (parse-date input :format "%Y-%m-%d")))
```

ここで:
- `parse-number` は文字列を整数に変換しようと試みます。
- `parse-date` は文字列を日付オブジェクトに変換しようと試みます（ISLISPがサポートしている場合、そうでなければ同様のアプローチを使用します）。

これらの関数は、より堅牢にユーザー入力を受け入れ処理するために、より大きなコマンドラインツール内で使用することができます。



#### **3. モジュール化と再利用可能なコードの記述**

現実のアプリケーションでは、コードのモジュール化と再利用性が重要な原則となります。ツールを独立して再利用可能なより小さなモジュールに分割してみましょう。

##### **コードのモジュール化**

1. **ファイル操作モジュール** (別ファイル `file-operations.lisp`):

```lisp
;; file-operations.lisp
(defun file-exists-p (filename) ...)
(defun read-file (filename) ...)
(defun write-file (filename content) ...)
```

2. **コマンドライン引数解析** (別ファイル `argument-parser.lisp`):

```lisp
;; argument-parser.lisp
(defun parse-arguments (args) ...)
```

3. **メインツール**（別ファイル `file-tool.lisp`）：

```lisp
;; file-tool.lisp
(load "file-operations.lisp")
(load "argument-parser.lisp")

(defun main ()
  (parse-arguments (cdr (function-arguments))))
```

このように分離することで、コマンドライン引数解析機能を組み込むことなく、他のプロジェクトで `file-operations.lisp` モジュールを再利用することができます。



#### **まとめ**

この章では、以下のことを学びました。
- 基本的なファイル操作を行うための ISLISP によるシンプルなコマンドラインツールの設計
- ユーザー入力を解析および処理し、ツールをより対話的かつ柔軟なものにする
- 関心を異なるモジュールに分けることで、モジュール化され再利用可能なコードを記述する

これらの慣例に従うことで、保守や拡張が容易な堅牢な ISLISP アプリケーションを構築することができます。

