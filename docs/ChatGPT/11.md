ISLISPの**第11章：モジュールとコードの構成**に飛び込みましょう。



### **11. モジュールとコードの構成**

この章では、ISLISPでコードを管理し構成するために必要な基本的な概念とツールを説明します。コードを分割するためのモジュールの使用方法、プログラムの異なる部分間でコードを共有する方法、再利用可能なコードを書くためのベストプラクティスを紹介します。

#### **1. モジュールの作成と使用**

ISLISPは、他の多くのLisp方言と同様に、コードをモジュールに構造化して、より良い整理と問題の分離を行うことができます。モジュールは、関連する関数、マクロ、変数をグループ化することで、大規模なプロジェクトの整理に役立ちます。

ISLISPでは、モジュールは通常、**パッケージ**の概念を使用して実装されます。パッケージは、シンボル（関数、変数など）を整理し、名前の衝突を回避するための名前空間です。

**パッケージによるモジュールの定義**

ISLISPでモジュールを定義するには、通常パッケージを作成します。以下に、簡単なパッケージの作成と使用の例を示します。

```lisp
(defpackage :my-module
  (:use :common-lisp))  ; common-lispパッケージをベースとして使用
```

- `defpackage` は新しいパッケージを定義します。 `:my-module` の部分はパッケージの名前です。
- `(:use :common-lisp)` の節は、このパッケージが `common-lisp` パッケージを使用することを示します。

パッケージが定義されると、プログラムの他の部分にインポートすることができます。

##### **パッケージの使用**

定義済みのパッケージの関数やシンボルを使用するには、`use-package` フォームを使用します。

```lisp
(use-package :my-module)
```

これで、`:my-module` で定義された関数やシンボルはすべて、現在のコンテキストで利用可能になります。これは、他のプログラミング言語におけるモジュールのインポートに似ています。

#### **2. `require` と `provide` システム**

ISLISPは、多くのモダンなLispシステムと同様に、モジュール間のコードの読み込みと共有を制御するメカニズムを提供しています。これらは通常、`require`と`provide`で実装されます。

#### **`provide`**

`provide`は、モジュールが使用可能であることを示すために使用されます。通常、使用可能にしたい関数、マクロ、シンボルを定義するモジュール内に置かれます。

```lisp
(provide :my-module)
```

これにより、プログラムの他の部分で `:my-module` を `require` できるようになります。

##### **`require`**

`require` は、モジュールまたはパッケージがまだロードされていない場合に、それらをロードするために使用します。これにより、コードが一度だけ確実にロードされ、冗長な評価が防止されます。

```lisp
(require :my-module)
```

- `require` 関数は、モジュールがすでにロードされているかどうかを確認します。ロードされていない場合は、モジュールをロードし、その中のすべてのシンボルを利用可能にします。
- モジュールがすでにロードされている場合は、`require` は何も行わず、冗長な計算を回避し、リソースを節約します。

#### **3. 再利用可能なコードの記述**

コードをモジュールやパッケージに整理する際には、再利用可能で保守可能なモジュール化されたコードを書くことに重点を置くことが重要です。再利用可能なコードは複数のプロジェクトで共有でき、冗長性を必要とする度合いを減らすことができます。以下に、再利用可能なISLISPコードを書くためのヒントをいくつか示します。

##### **モジュール化を念頭に置く**

関数を書く際には、できるだけ一般化し、独立したものとなるようにしてください。 プログラムの異なる部分を密結合することは避けてください。 各関数やモジュールは、単一の責任を持つことが理想的です。

##### **ライブラリとユーティリティの作成**

再利用可能なコードを書く良い方法は、複数のプログラムで使用できるライブラリやユーティリティ関数を作成することです。 例えば、行列操作、文字列操作、または多くのアプリケーションで必要となる可能性があるその他の一般的なタスク用のライブラリを作成することができます。

例：

```lisp
;; 行列操作用のユーティリティモジュール
(defpackage :matrix-utils
  (:use :common-lisp))

(in-package :matrix-utils)

(defun add-matrices (matrix1 matrix2)
  (mapcar #'(lambda (row1 row2) (mapcar #'+ row1 row2))
          matrix1 matrix2))

(provide :matrix-utils)
```

上記のコードでは、
- `add-matrices` 関数は2つの行列を足し合わせるように定義されています。これは行列操作を必要とする他のプログラムで再利用できるユーティリティです。
- モジュール `:matrix-utils` が提供されているので、コードの他の部分でそれを `require` して使用することができます。

##### **大規模プロジェクトの整理**

プロジェクトが大きくなればなるほど、コードをモジュールに整理することがより重要になります。プロジェクトを管理、デバッグ、拡張しやすいように構造化することを目指すべきです。

コードのモジュール性を反映したディレクトリ構造を使用することを検討してください。

```
my_project/
    ├── src/
    │   ├── core.lisp
    │   ├── utils.lisp
    │   └── matrix.lisp
    ├── test/
    │   ├── core-tests.lisp
    │   └── matrix-tests.lisp
    ├── README.md
    └── main.lisp
```

上記の構造では、

- `src` フォルダには、プロジェクトの特定の部分に焦点を当てた複数のファイルに分割されたソースコードが含まれます。
- `test` フォルダには各モジュールのテストが含まれており、開発中にシステムが堅牢性を維持できるようにします。
- `main.lisp` ファイルはアプリケーションのエントリーポイントとなり、必要なモジュールをロードしてアプリケーションロジックを開始します。

このようにプロジェクトを整理することで、各モジュールのインポートやテストが容易になり、コードが長期間にわたってメンテナンス可能で再利用可能な状態を維持できます。

#### **再利用可能なコードのベストプラクティス**

- **ドキュメント化：** 関数、モジュール、パッケージについて、わかりやすいドキュメントを用意しましょう。これにより、他の人（そして将来のあなた自身）がコードの使用方法を理解しやすくなります。
- **グローバル変数の使用を避ける：** グローバル変数は、絶対に必要な場合を除いて使用しないようにしましょう。代わりに、関数の引数と戻り値を使用します。
- **小さく、目的を絞った関数を作成する：** 各関数は、1つのことをうまく行うべきです。これにより、関数の再利用性が高まり、テストが容易になります。
- **バージョン管理：** Gitなどのバージョン管理システムを使用して変更を追跡し、他の人との共同作業を容易にします。
- **ユニットテスト：** コードのテストを作成し、期待通りに動作することを確認します。これは、複数のコンテキストで使用されるため、再利用可能なコードでは特に重要です。



#### **モジュールとコードの整理における主要概念のまとめ**

1. **モジュールの作成と使用：**
   ISLISPではパッケージを使用してコードをモジュールに整理・分割します。モジュールはシンボルに名前空間を提供し、名前の衝突を防止するのに役立ちます。

2. **`require`および`provide`システム：**
   - `provide`はモジュールを使用可能にします。一方、`require`はモジュールがまだロードされていない場合にモジュールをロードします。このシステムはコードの異なる部分間の依存関係を管理するのに役立ちます。

3. **再利用可能なコードの記述：**
   - モジュール性を考慮してコードを設計します。 焦点を絞った小さな関数を記述し、一般的なタスク用の再利用可能なライブラリを作成します。 大規模なプロジェクトは、管理を容易にするために、構造化されたディレクトリに整理します。


