# ISLISP コンパイラ標準準拠仕様（難所定義）

この文書は、`isl` に LLVM ベースのコンパイラを追加する際の「標準準拠の難所」を、実装可能な仕様として固定する。
目的は最適化ではなく、まず意味論の一致（interpreter と compiler の観測可能挙動一致）を達成すること。

## 0. 適用範囲と用語

- 基準: ISO/IEC 13816:2007 (ISLISP)
- 参照実装: 現在の `src/isl/core.scm` の評価器
- 非目標:
  - 標準外拡張（DB/TCP/UDP/FFI 等）の初期段階でのネイティブ最適化
  - 未定義動作の固定化
- 一致判定:
  - 値
  - エラー発生有無（エラー型詳細は段階的）
  - 副作用順序
  - 非局所脱出の到達先

## 1. 準拠プロファイル

実装を 2 プロファイルに分離する。

- `strict`: 標準機能のみ（処理系拡張はデフォルト無効）
- `extended`: 現行拡張を有効

規範要件:

1. コンパイラは `strict` を第一級ターゲットにする。
2. `strict` では標準外シンボルを暗黙導入しない。
3. `extended` の追加機能は名前空間または feature フラグで明示分離する。

受け入れ基準:

1. `strict` で標準テスト群が pass。
2. `strict` と `extended` の差分表が文書化されている。

## 2. 評価順序と副作用

難所:

- 引数評価順序
- `let`/`let*` 初期化評価順序
- `setf` 相当の place 評価順序

規範要件:

1. 1 つのフォーム内で副作用観測順序は interpreter と一致させる。
2. コンパイラ最適化は、副作用順序を変更してはならない。
3. 未規定順序に依存するコードは、`strict` では警告対象とする。

実装規則:

1. IR 生成時に effect barrier を導入する。
2. 関数呼び出し、代入、I/O、例外可能操作を「順序固定ノード」に分類する。

受け入れ基準:

1. 順序検証テスト（ログ append）で interpreter/compiler のログ一致。
2. `-O0/-O2` でログ一致。

## 3. 非局所制御（block/return-from, catch/throw, tagbody/go）

難所:

- スタック巻き戻し
- 動的文脈の正しい破棄
- 脱出先不在時のエラー

規範要件:

1. `return-from` は対応 `block` のみへ脱出可能。
2. `throw` は対応 `catch` のみへ脱出可能。
3. `go` は同一 `tagbody` 文脈に限定。
4. 脱出時に dynamic cleanup が必ず実行される。

実装規則:

1. IR に `BLOCK_ENTER/BLOCK_EXIT/NONLOCAL_EXIT` を持つ。
2. LLVM 側は以下のいずれかで統一する。
   - `invoke`/`landingpad` ベース例外
   - ランタイム `setjmp/longjmp` ベース
3. 方式は 1 つに固定し、混在させない。

受け入れ基準:

1. ネスト脱出の組合せテストを追加（`block` in `catch`、`catch` in `block`）。
2. 失敗ケース（脱出先なし）でエラー発生一致。

## 4. 条件処理とハンドラ

難所:

- `handler-case` の捕捉範囲
- 再送出時の動作
- 条件オブジェクトの観測可能性

規範要件:

1. ハンドラ探索順序は interpreter と一致。
2. 例外発生点からハンドラまでの副作用順序を保持。
3. ハンドラ未捕捉時は同等エラーを上位へ伝播。

実装規則:

1. ランタイムに handler stack を明示的に持つ。
2. 非局所脱出機構と条件処理機構を同一 unwind 基盤で扱う。

受け入れ基準:

1. 捕捉/未捕捉/再送出の 3 系列テストを整備。

## 5. レキシカル環境とクロージャ

難所:

- 変数捕捉
- 可変長引数・rest バインディング
- 末尾呼び出しと環境寿命

規範要件:

1. レキシカル変数参照は束縛点と一致。
2. クロージャは必要な環境のみ捕捉（ただし意味優先、最適化は任意）。
3. パラメータ不一致時のエラー条件は interpreter と一致。

実装規則:

1. コンパイル時に変数を lexical slot 化。
2. 逃避クロージャは heap 環境化。
3. TCO は段階導入し、導入時も観測意味を変えない。

受け入れ基準:

1. 変数シャドーイング、入れ子クロージャ、rest 引数の同値テスト。

## 6. マクロ展開境界

難所:

- コンパイル時環境と実行時環境の混同
- 展開結果の再帰安定性

規範要件:

1. コンパイラ入力は「展開済みフォーム」とする。
2. 展開規則は interpreter の `macroexpand` と一致。
3. 展開時副作用の扱いを明示（禁止/限定許可）する。

実装規則:

1. フロントエンドは `read -> macroexpand -> normalize(IR)` の 3 段固定。
2. コンパイル単位間でマクロ定義可視性ルールを固定。

受け入れ基準:

1. `macroexpand-1` と最終評価の一致テスト。
2. ネストマクロ + ローカル束縛の回帰テスト。

## 7. オブジェクトシステム（class/generic/method）

難所:

- メソッド適用可能性判定
- 曖昧性処理
- スロット初期化/アクセサ生成

規範要件:

1. `defgeneric`/`defmethod` のディスパッチ結果は interpreter と一致。
2. 曖昧メソッド時のエラー判定条件を固定。
3. `slot-value`/accessor の可視動作を一致。

実装規則:

1. メソッド解決はまずランタイム実装（JIT 側で過度に埋め込まない）。
2. 高速化（inline cache 等）は意味一致がテストで担保された後に追加。

受け入れ基準:

1. 多重継承を含む解決テスト。
2. 曖昧ケースのエラーテスト。

## 8. 数値・型・比較の境界

難所:

- exact/inexact の扱い
- 比較述語の型境界
- オーバーフロー時挙動

規範要件:

1. 数値演算結果は interpreter と一致。
2. 型エラー境界（許容/非許容）を一致。
3. 実装依存差分は `strict` で封じるか明示記録。

実装規則:

1. 値表現（tagged immediate/boxed）と変換規則を仕様化。
2. LLVM 最適化は fast-math 禁止を既定にする。

受け入れ基準:

1. 境界値テスト（0, 負数, 大値, 小数）を interpreter と比較。

## 9. パッケージ・シンボル解決

難所:

- 読み取り時/評価時のシンボル解決の差
- export/import/use-package の可視規則

規範要件:

1. シンボル解決規則は interpreter と一致。
2. コンパイル済みコードでも package 変更の影響範囲を規定する。

実装規則:

1. フロントエンドでシンボル解決を早期固定する場合、再現可能な条件を文書化。
2. 遅延解決方式の場合、ランタイム lookup のコストを許容し意味を優先。

受け入れ基準:

1. package 切替と同名シンボル衝突テスト。

## 10. LLVM バックエンド仕様

規範要件:

1. ネイティブ生成は LLVM を利用し、独自命令選択は行わない。
2. GC セーフポイントを LLVM IR に反映する。
3. FFI 呼び出し ABI はランタイム層で吸収し、言語意味と分離する。

実装規則:

1. 最初は AOT（`IR -> LLVM IR -> obj`）を正とする。
2. JIT は ORC v2 を後段導入。
3. 最適化パスは whitelist 方式で段階開放。

受け入れ基準:

1. `-O0/-O2` で意味一致。
2. 対象アーキごとに smoke テスト（x86_64, arm64）。

## 11. 準拠判定ゲート（リリース基準）

マイルストーンごとに以下を満たすまで次へ進まない。

1. セマンティクスゲート
   - interpreter/compiler 差分ゼロ（既知除外なし）
2. 例外ゲート
   - 非局所制御・条件処理の失敗系含め pass
3. プロファイルゲート
   - `strict` で標準外機能が漏れない
4. 最適化ゲート
   - `-O0` と `-O2` の観測結果一致

## 12. 実装優先順位（標準準拠優先）

1. 評価順序固定
2. 非局所制御
3. 条件処理
4. レキシカル環境/クロージャ
5. マクロ展開境界
6. オブジェクトシステム
7. 数値境界
8. パッケージ解決
9. LLVM 最適化拡大

この順序を崩す場合は、崩した理由と影響範囲を設計記録に残すこと。
